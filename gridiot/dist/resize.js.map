{
  "version": 3,
  "sources": ["../../engine.ts", "../../utils/flip.ts", "../../plugins/resize.ts"],
  "sourcesContent": ["import type { GridCell, GridiotCore, InitOptions, Plugin, PluginOptions, ProviderRegistry } from './types';\n\n// Global plugin registry\nconst plugins = new Map<string, Plugin>();\n\nexport function registerPlugin(plugin: Plugin): void {\n\tplugins.set(plugin.name, plugin);\n}\n\nexport function getPlugin(name: string): Plugin | undefined {\n\treturn plugins.get(name);\n}\n\n/**\n * Initialize Gridiot on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options including layoutModel, styleElement, and plugin options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): GridiotCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t\tplugins: pluginOptions = {},\n\t\tdisablePlugins = [],\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\tlet selectedItem: HTMLElement | null = null;\n\n\t// Provider registry for inter-plugin communication\n\tconst providerMap = new Map<string, () => unknown>();\n\tconst providers: ProviderRegistry = {\n\t\tregister<T>(capability: string, provider: () => T): void {\n\t\t\tif (providerMap.has(capability)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Gridiot: Provider for \"${capability}\" already registered, overwriting`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tproviderMap.set(capability, provider);\n\t\t},\n\n\t\tget<T>(capability: string): T | undefined {\n\t\t\tconst provider = providerMap.get(capability);\n\t\t\treturn provider ? (provider() as T) : undefined;\n\t\t},\n\n\t\thas(capability: string): boolean {\n\t\t\treturn providerMap.has(capability);\n\t\t},\n\t};\n\n\tconst core: GridiotCore = {\n\t\telement,\n\t\tproviders,\n\n\t\t// Selection state\n\t\tget selectedItem() {\n\t\t\treturn selectedItem;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedItem) return;\n\n\t\t\tconst previousItem = selectedItem;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-gridiot-selected');\n\t\t\t}\n\n\t\t\t// Set new selection\n\t\t\tselectedItem = item;\n\n\t\t\tif (item) {\n\t\t\t\titem.setAttribute('data-gridiot-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else if (previousItem) {\n\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`gridiot:${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tobserver.disconnect();\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Observe position changes and animate with View Transitions\n\tconst observer = new MutationObserver((mutations) => {\n\t\t// Collect items that changed position\n\t\tconst changedItems = new Set<HTMLElement>();\n\n\t\tfor (const mutation of mutations) {\n\t\t\tif (\n\t\t\t\tmutation.type === 'attributes' &&\n\t\t\t\tmutation.target instanceof HTMLElement\n\t\t\t) {\n\t\t\t\tconst item = mutation.target.closest(\n\t\t\t\t\t'[data-gridiot-item]',\n\t\t\t\t) as HTMLElement | null;\n\t\t\t\tif (item && element.contains(item)) {\n\t\t\t\t\tchangedItems.add(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Animate changes with View Transitions if available\n\t\tif (changedItems.size > 0 && 'startViewTransition' in document) {\n\t\t\t// Items already moved - View Transitions will handle animation\n\t\t\t// The browser captures before/after states automatically\n\t\t}\n\t});\n\n\tobserver.observe(element, {\n\t\tsubtree: true,\n\t\tattributes: true,\n\t\tattributeFilter: ['style', 'class'],\n\t});\n\n\t// Initialize all registered plugins with options\n\tfor (const plugin of plugins.values()) {\n\t\t// Skip disabled plugins\n\t\tif (disablePlugins.includes(plugin.name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Build options for this plugin\n\t\tconst pluginSpecificOptions = pluginOptions[plugin.name as keyof PluginOptions] ?? {};\n\t\tconst opts = {\n\t\t\t...pluginSpecificOptions,\n\t\t\t// Pass shared resources to all plugins that might need them\n\t\t\tlayoutModel,\n\t\t\tstyleElement,\n\t\t\tcore,\n\t\t};\n\n\t\tconst cleanup = plugin.init(core, opts);\n\t\tif (cleanup) {\n\t\t\tcleanups.push(cleanup);\n\t\t}\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Set an item's grid position\n */\nexport function setItemCell(item: HTMLElement, cell: GridCell): void {\n\titem.style.gridColumn = String(cell.column);\n\titem.style.gridRow = String(cell.row);\n}\n\n/**\n * Get grid info for a grid element\n */\nexport function getGridInfo(element: HTMLElement) {\n\tconst rect = element.getBoundingClientRect();\n\tconst style = getComputedStyle(element);\n\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\tconst columnGap = parseFloat(style.columnGap) || 0;\n\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\treturn {\n\t\trect,\n\t\tcolumns,\n\t\trows,\n\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\tcellWidth: columns[0] || 0,\n\t\tcellHeight: rows[0] || 0,\n\t};\n}\n", "/**\n * FLIP Animation Utility\n *\n * Provides shared FLIP (First, Last, Invert, Play) animation utilities\n * used by pointer and resize plugins for smooth position/scale transitions.\n */\n\nexport interface FLIPOptions {\n\t/** Animation duration in milliseconds. @default 200 */\n\tduration?: number;\n\t/** CSS easing function. @default 'cubic-bezier(0.2, 0, 0, 1)' */\n\teasing?: string;\n\t/** Include scale transform (for resize). @default false */\n\tincludeScale?: boolean;\n\t/** Transform origin for scale animations. @default undefined (uses center) */\n\ttransformOrigin?: string;\n\t/** Callback when animation starts */\n\tonStart?: () => void;\n\t/** Callback when animation finishes */\n\tonFinish?: () => void;\n}\n\n/**\n * Animate an element from its previous position/size to its new position/size using FLIP.\n *\n * @param element - The element to animate\n * @param firstRect - The element's bounding rect before the DOM change (the \"First\" in FLIP)\n * @param options - Animation options\n * @returns The Animation object, or null if no animation was needed\n *\n * @example\n * ```ts\n * // Capture position before DOM change\n * const firstRect = element.getBoundingClientRect();\n *\n * // Make DOM changes (e.g., update grid position)\n * element.style.gridColumn = '2 / span 2';\n *\n * // Animate from old position to new\n * requestAnimationFrame(() => {\n *   animateFLIP(element, firstRect);\n * });\n * ```\n */\nexport function animateFLIP(\n\telement: HTMLElement,\n\tfirstRect: DOMRect,\n\toptions: FLIPOptions = {},\n): Animation | null {\n\tconst {\n\t\tduration = 200,\n\t\teasing = 'cubic-bezier(0.2, 0, 0, 1)',\n\t\tincludeScale = false,\n\t\ttransformOrigin,\n\t\tonStart,\n\t\tonFinish,\n\t} = options;\n\n\t// Measure final position (the \"Last\" in FLIP)\n\tconst lastRect = element.getBoundingClientRect();\n\n\t// Calculate position deltas (the \"Invert\" in FLIP)\n\tconst deltaX = firstRect.left - lastRect.left;\n\tconst deltaY = firstRect.top - lastRect.top;\n\n\tconst needsTranslate = Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1;\n\n\t// Calculate scale deltas (for resize)\n\tlet scaleX = 1;\n\tlet scaleY = 1;\n\tlet needsScale = false;\n\n\tif (includeScale) {\n\t\tscaleX = firstRect.width / lastRect.width;\n\t\tscaleY = firstRect.height / lastRect.height;\n\t\tneedsScale = Math.abs(scaleX - 1) > 0.01 || Math.abs(scaleY - 1) > 0.01;\n\t}\n\n\t// Skip animation if no significant change\n\tif (!needsTranslate && !needsScale) {\n\t\tonFinish?.();\n\t\treturn null;\n\t}\n\n\tonStart?.();\n\n\t// Build keyframes based on what's needed\n\tconst keyframes: Keyframe[] = includeScale\n\t\t? [\n\t\t\t\t{\n\t\t\t\t\ttransform: `translate(${deltaX}px, ${deltaY}px) scale(${scaleX}, ${scaleY})`,\n\t\t\t\t\ttransformOrigin: transformOrigin ?? 'top left',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttransform: 'translate(0, 0) scale(1, 1)',\n\t\t\t\t\ttransformOrigin: transformOrigin ?? 'top left',\n\t\t\t\t},\n\t\t\t]\n\t\t: [\n\t\t\t\t{ transform: `translate(${deltaX}px, ${deltaY}px)` },\n\t\t\t\t{ transform: 'translate(0, 0)' },\n\t\t\t];\n\n\t// Play the animation\n\tconst animation = element.animate(keyframes, {\n\t\tduration,\n\t\teasing,\n\t});\n\n\tanimation.onfinish = () => onFinish?.();\n\n\treturn animation;\n}\n\n/**\n * Get the item's view transition name from various sources.\n * Checks --item-id CSS property, id attribute, and data-id attribute.\n */\nexport function getItemViewTransitionName(element: HTMLElement): string | null {\n\treturn (\n\t\telement.style.getPropertyValue('--item-id') ||\n\t\telement.id ||\n\t\telement.dataset.id ||\n\t\tnull\n\t);\n}\n\n/**\n * Execute a FLIP animation while temporarily excluding the element from View Transitions.\n *\n * This is useful when you want to use FLIP for an animation instead of View Transitions,\n * to prevent the two from conflicting.\n *\n * @param element - The element to animate\n * @param fn - Function that performs the animation (receives firstRect)\n * @returns The Animation object, or null if no animation was needed\n *\n * @example\n * ```ts\n * const firstRect = element.getBoundingClientRect();\n *\n * // Make DOM changes\n * element.style.gridColumn = '2 / span 2';\n *\n * // Animate with View Transition exclusion\n * requestAnimationFrame(() => {\n *   withViewTransitionExclusion(element, () =>\n *     animateFLIP(element, firstRect)\n *   );\n * });\n * ```\n */\nexport function withViewTransitionExclusion(\n\telement: HTMLElement,\n\tfn: () => Animation | null,\n): Animation | null {\n\t// Exclude from View Transitions during FLIP\n\telement.style.viewTransitionName = 'none';\n\n\tconst animation = fn();\n\n\tconst restoreViewTransitionName = () => {\n\t\tconst itemId = getItemViewTransitionName(element);\n\t\tif (itemId) {\n\t\t\telement.style.viewTransitionName = itemId;\n\t\t}\n\t};\n\n\tif (animation) {\n\t\tanimation.addEventListener('finish', restoreViewTransitionName, { once: true });\n\t} else {\n\t\t// No animation needed, restore immediately\n\t\trestoreViewTransitionName();\n\t}\n\n\treturn animation;\n}\n\n/**\n * Perform a complete FLIP animation with data attribute tracking.\n *\n * This is a higher-level helper that:\n * 1. Excludes the element from View Transitions\n * 2. Sets a tracking attribute during animation\n * 3. Animates using FLIP\n * 4. Restores View Transition name when done\n *\n * @param element - The element to animate\n * @param firstRect - The element's bounding rect before the DOM change\n * @param options - Animation options plus optional attribute name\n *\n * @example\n * ```ts\n * const firstRect = element.getBoundingClientRect();\n * element.style.gridColumn = '2 / span 2';\n *\n * requestAnimationFrame(() => {\n *   animateFLIPWithTracking(element, firstRect, {\n *     attributeName: 'data-gridiot-dropping',\n *     includeScale: true,\n *     transformOrigin: 'top left',\n *   });\n * });\n * ```\n */\nexport function animateFLIPWithTracking(\n\telement: HTMLElement,\n\tfirstRect: DOMRect,\n\toptions: FLIPOptions & { attributeName?: string } = {},\n): Animation | null {\n\tconst { attributeName = 'data-gridiot-dropping', ...flipOptions } = options;\n\n\t// Exclude from View Transitions\n\telement.style.viewTransitionName = 'none';\n\n\tconst animation = animateFLIP(element, firstRect, {\n\t\t...flipOptions,\n\t\tonStart: () => {\n\t\t\telement.setAttribute(attributeName, '');\n\t\t\tflipOptions.onStart?.();\n\t\t},\n\t\tonFinish: () => {\n\t\t\telement.removeAttribute(attributeName);\n\t\t\t// Restore view transition name\n\t\t\tconst itemId = getItemViewTransitionName(element);\n\t\t\tif (itemId) {\n\t\t\t\telement.style.viewTransitionName = itemId;\n\t\t\t}\n\t\t\tflipOptions.onFinish?.();\n\t\t},\n\t});\n\n\t// If no animation was needed, clean up immediately\n\tif (!animation) {\n\t\tconst itemId = getItemViewTransitionName(element);\n\t\tif (itemId) {\n\t\t\telement.style.viewTransitionName = itemId;\n\t\t}\n\t}\n\n\treturn animation;\n}\n", "/**\n * Resize plugin for Gridiot\n *\n * Allows users to resize grid items by dragging corners/edges.\n * Resizes modify colspan/rowspan using actual CSS grid changes during resize.\n *\n * Usage:\n *   import { attachResize } from 'gridiot/resize';\n *\n *   const detach = attachResize(gridElement, {\n *     handles: 'corners',  // 'corners' | 'edges' | 'all'\n *     handleSize: 12,\n *     minSize: { colspan: 1, rowspan: 1 },\n *     maxSize: { colspan: 6, rowspan: 6 },\n *   });\n */\n\nimport { registerPlugin } from '../engine';\nimport type {\n\tGridCell,\n\tGridiotCore,\n\tResizeCancelDetail,\n\tResizeEndDetail,\n\tResizeHandle,\n\tResizeMoveDetail,\n\tResizePluginOptions,\n\tResizeStartDetail,\n\tResizeState,\n} from '../types';\nimport { animateFLIPWithTracking } from '../utils/flip';\n\nconst DEBUG = false;\nfunction log(...args: unknown[]) {\n\tif (DEBUG) console.log('[resize]', ...args);\n}\n\nexport interface ResizeOptions {\n\t/** Which handles to show: 'corners' | 'edges' | 'all' (default: 'corners') */\n\thandles?: 'corners' | 'edges' | 'all';\n\t/** Size of the hit zone for handles in pixels (default: 12) */\n\thandleSize?: number;\n\t/** Minimum size in grid cells (default: { colspan: 1, rowspan: 1 }) */\n\tminSize?: { colspan: number; rowspan: number };\n\t/** Maximum size in grid cells (default: { colspan: 6, rowspan: 6 }) */\n\tmaxSize?: { colspan: number; rowspan: number };\n\t/** Show size label during resize (default: true) */\n\tshowSizeLabel?: boolean;\n\t/** GridiotCore instance for provider registration */\n\tcore?: GridiotCore;\n}\n\ninterface ActiveResize {\n\titem: HTMLElement;\n\tpointerId: number;\n\thandle: ResizeHandle;\n\t/** Original cell position at start of resize - never changes */\n\tstartCell: GridCell;\n\t/** Original size at start of resize - never changes */\n\toriginalSize: { colspan: number; rowspan: number };\n\t/** Current position (may differ from startCell for NW/NE/SW handles) */\n\tcurrentCell: GridCell;\n\t/** Current size during resize */\n\tcurrentSize: { colspan: number; rowspan: number };\n\toriginalGridColumn: string;\n\toriginalGridRow: string;\n\tsizeLabel: HTMLElement | null;\n\t/** Initial bounding rect for smooth resize */\n\tinitialRect: DOMRect;\n\t/** Pointer position at start */\n\tstartPointerX: number;\n\tstartPointerY: number;\n}\n\n/**\n * Detect which resize handle (if any) is under the pointer\n */\nfunction detectHandle(\n\te: PointerEvent,\n\titem: HTMLElement,\n\tsize: number,\n\tmode: 'corners' | 'edges' | 'all',\n): ResizeHandle | null {\n\tconst rect = item.getBoundingClientRect();\n\tconst x = e.clientX - rect.left;\n\tconst y = e.clientY - rect.top;\n\n\tconst nearLeft = x < size;\n\tconst nearRight = x > rect.width - size;\n\tconst nearTop = y < size;\n\tconst nearBottom = y > rect.height - size;\n\n\t// Corners\n\tif (mode === 'corners' || mode === 'all') {\n\t\tif (nearTop && nearLeft) return 'nw';\n\t\tif (nearTop && nearRight) return 'ne';\n\t\tif (nearBottom && nearLeft) return 'sw';\n\t\tif (nearBottom && nearRight) return 'se';\n\t}\n\n\t// Edges (only if not at corners)\n\tif (mode === 'edges' || mode === 'all') {\n\t\tif (nearTop) return 'n';\n\t\tif (nearBottom) return 's';\n\t\tif (nearLeft) return 'w';\n\t\tif (nearRight) return 'e';\n\t}\n\n\treturn null;\n}\n\n/**\n * Get cursor style for a resize handle\n */\nfunction getCursor(handle: ResizeHandle | null): string {\n\tswitch (handle) {\n\t\tcase 'nw':\n\t\tcase 'se':\n\t\t\treturn 'nwse-resize';\n\t\tcase 'ne':\n\t\tcase 'sw':\n\t\t\treturn 'nesw-resize';\n\t\tcase 'n':\n\t\tcase 's':\n\t\t\treturn 'ns-resize';\n\t\tcase 'e':\n\t\tcase 'w':\n\t\t\treturn 'ew-resize';\n\t\tdefault:\n\t\t\treturn '';\n\t}\n}\n\n/**\n * Calculate new size based on pointer position and handle\n */\nfunction calculateNewSize(\n\tcore: GridiotCore,\n\thandle: ResizeHandle,\n\tstartCell: GridCell,\n\toriginalSize: { colspan: number; rowspan: number },\n\tpointerX: number,\n\tpointerY: number,\n\tminSize: { colspan: number; rowspan: number },\n\tmaxSize: { colspan: number; rowspan: number },\n): { colspan: number; rowspan: number; column: number; row: number } {\n\tconst gridInfo = core.getGridInfo();\n\tconst maxColumn = gridInfo.columns.length;\n\tconst maxRow = gridInfo.rows.length;\n\n\t// Get pointer cell, clamping to grid bounds if outside\n\t// This allows resizing to continue even when pointer is outside grid\n\tlet pointerCell = core.getCellFromPoint(pointerX, pointerY);\n\tif (!pointerCell) {\n\t\t// Clamp to grid bounds based on pointer position relative to grid\n\t\tconst rect = gridInfo.rect;\n\t\tconst cellWidth = gridInfo.cellWidth + gridInfo.gap;\n\t\tconst cellHeight = gridInfo.cellHeight + gridInfo.gap;\n\n\t\tlet column: number;\n\t\tlet row: number;\n\n\t\tif (pointerX < rect.left) {\n\t\t\tcolumn = 1;\n\t\t} else if (pointerX > rect.right) {\n\t\t\tcolumn = maxColumn;\n\t\t} else {\n\t\t\tcolumn = Math.max(1, Math.min(maxColumn, Math.floor((pointerX - rect.left) / cellWidth) + 1));\n\t\t}\n\n\t\tif (pointerY < rect.top) {\n\t\t\trow = 1;\n\t\t} else if (pointerY > rect.bottom) {\n\t\t\trow = maxRow;\n\t\t} else {\n\t\t\trow = Math.max(1, Math.min(maxRow, Math.floor((pointerY - rect.top) / cellHeight) + 1));\n\t\t}\n\n\t\tpointerCell = { column, row };\n\t}\n\n\tlet newColspan = originalSize.colspan;\n\tlet newRowspan = originalSize.rowspan;\n\tlet newColumn = startCell.column;\n\tlet newRow = startCell.row;\n\n\t// Handle horizontal resizing\n\tif (handle === 'e' || handle === 'se' || handle === 'ne') {\n\t\t// Right edge: column stays, span grows right\n\t\tnewColspan = Math.max(\n\t\t\tminSize.colspan,\n\t\t\tMath.min(\n\t\t\t\tmaxSize.colspan,\n\t\t\t\tpointerCell.column - startCell.column + 1,\n\t\t\t\tmaxColumn - startCell.column + 1,\n\t\t\t),\n\t\t);\n\t} else if (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t// Left edge: column moves left, right edge stays fixed\n\t\tconst rightEdge = startCell.column + originalSize.colspan - 1;\n\t\tconst newLeft = Math.max(1, Math.min(pointerCell.column, rightEdge));\n\t\tnewColspan = Math.max(\n\t\t\tminSize.colspan,\n\t\t\tMath.min(maxSize.colspan, rightEdge - newLeft + 1),\n\t\t);\n\t\tnewColumn = rightEdge - newColspan + 1;\n\t}\n\n\t// Handle vertical resizing\n\tif (handle === 's' || handle === 'se' || handle === 'sw') {\n\t\t// Bottom edge: row stays, span grows down\n\t\tnewRowspan = Math.max(\n\t\t\tminSize.rowspan,\n\t\t\tMath.min(\n\t\t\t\tmaxSize.rowspan,\n\t\t\t\tpointerCell.row - startCell.row + 1,\n\t\t\t\tmaxRow - startCell.row + 1,\n\t\t\t),\n\t\t);\n\t} else if (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t// Top edge: row moves up, bottom edge stays fixed\n\t\tconst bottomEdge = startCell.row + originalSize.rowspan - 1;\n\t\tconst newTop = Math.max(1, Math.min(pointerCell.row, bottomEdge));\n\t\tnewRowspan = Math.max(\n\t\t\tminSize.rowspan,\n\t\t\tMath.min(maxSize.rowspan, bottomEdge - newTop + 1),\n\t\t);\n\t\tnewRow = bottomEdge - newRowspan + 1;\n\t}\n\n\treturn {\n\t\tcolspan: newColspan,\n\t\trowspan: newRowspan,\n\t\tcolumn: newColumn,\n\t\trow: newRow,\n\t};\n}\n\n/**\n * Create a size label element\n */\nfunction createSizeLabel(): HTMLElement {\n\tconst label = document.createElement('div');\n\tlabel.className = 'gridiot-resize-label';\n\tlabel.style.cssText = `\n\t\tposition: absolute;\n\t\ttop: 50%;\n\t\tleft: 50%;\n\t\ttransform: translate(-50%, -50%);\n\t\tbackground: rgba(0, 0, 0, 0.8);\n\t\tcolor: white;\n\t\tpadding: 4px 8px;\n\t\tborder-radius: 4px;\n\t\tfont-size: 14px;\n\t\tfont-weight: 600;\n\t\tfont-family: system-ui, sans-serif;\n\t\tpointer-events: none;\n\t\tz-index: 1000;\n\t\twhite-space: nowrap;\n\t`;\n\treturn label;\n}\n\n/**\n * Attach resize functionality to a grid element.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach resize\n */\nexport function attachResize(\n\tgridElement: HTMLElement,\n\toptions: ResizeOptions = {},\n): {\n\tsetSize(item: HTMLElement, size: { colspan: number; rowspan: number }): void;\n\tdestroy(): void;\n} {\n\tconst {\n\t\thandles = 'corners',\n\t\thandleSize = 12,\n\t\tminSize = { colspan: 1, rowspan: 1 },\n\t\tmaxSize = { colspan: 6, rowspan: 6 },\n\t\tshowSizeLabel = true,\n\t\tcore,\n\t} = options;\n\n\tlet activeResize: ActiveResize | null = null;\n\tlet hoveredItem: HTMLElement | null = null;\n\tlet hoveredHandle: ResizeHandle | null = null;\n\n\t// Register provider if core is provided\n\tif (core) {\n\t\tcore.providers.register<ResizeState | null>('resize', () => {\n\t\t\tif (!activeResize) return null;\n\t\t\treturn {\n\t\t\t\titem: activeResize.item,\n\t\t\t\toriginalSize: activeResize.originalSize,\n\t\t\t\tcurrentSize: activeResize.currentSize,\n\t\t\t\thandle: activeResize.handle,\n\t\t\t};\n\t\t});\n\t}\n\n\tfunction emit<T>(event: string, detail: T): void {\n\t\tgridElement.dispatchEvent(\n\t\t\tnew CustomEvent(`gridiot:${event}`, {\n\t\t\t\tbubbles: true,\n\t\t\t\tdetail,\n\t\t\t}),\n\t\t);\n\t}\n\n\tfunction getCore(): GridiotCore {\n\t\tif (core) return core;\n\t\t// Fallback: create minimal core-like interface from grid element\n\t\t// This is for standalone usage without full gridiot initialization\n\t\treturn {\n\t\t\telement: gridElement,\n\t\t\tgetCellFromPoint(x: number, y: number) {\n\t\t\t\tconst rect = gridElement.getBoundingClientRect();\n\t\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst style = getComputedStyle(gridElement);\n\t\t\t\tconst columns = style.gridTemplateColumns.split(' ').filter(Boolean);\n\t\t\t\tconst rows = style.gridTemplateRows.split(' ').filter(Boolean);\n\t\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\t\tconst relX = x - rect.left;\n\t\t\t\tconst relY = y - rect.top;\n\n\t\t\t\tconst cellWidth =\n\t\t\t\t\t(parseFloat(columns[0] ?? '0') || 0) + columnGap;\n\t\t\t\tconst cellHeight = (parseFloat(rows[0] ?? '0') || 0) + rowGap;\n\n\t\t\t\tconst column = cellWidth > 0 ? Math.floor(relX / cellWidth) + 1 : 1;\n\t\t\t\tconst row = cellHeight > 0 ? Math.floor(relY / cellHeight) + 1 : 1;\n\n\t\t\t\treturn {\n\t\t\t\t\tcolumn: Math.max(1, Math.min(column, columns.length)),\n\t\t\t\t\trow: Math.max(1, Math.min(row, rows.length)),\n\t\t\t\t};\n\t\t\t},\n\t\t\tgetGridInfo() {\n\t\t\t\tconst rect = gridElement.getBoundingClientRect();\n\t\t\t\tconst style = getComputedStyle(gridElement);\n\t\t\t\tconst columns = style.gridTemplateColumns\n\t\t\t\t\t.split(' ')\n\t\t\t\t\t.filter(Boolean)\n\t\t\t\t\t.map((v) => parseFloat(v) || 0);\n\t\t\t\tconst rows = style.gridTemplateRows\n\t\t\t\t\t.split(' ')\n\t\t\t\t\t.filter(Boolean)\n\t\t\t\t\t.map((v) => parseFloat(v) || 0);\n\t\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\n\t\t\t\treturn {\n\t\t\t\t\trect,\n\t\t\t\t\tcolumns,\n\t\t\t\t\trows,\n\t\t\t\t\tgap: columnGap,\n\t\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t\t};\n\t\t\t},\n\t\t\temit,\n\t\t\tdestroy() {},\n\t\t\tselectedItem: null,\n\t\t\tselect() {},\n\t\t\tdeselect() {},\n\t\t\tproviders: {\n\t\t\t\tregister() {},\n\t\t\t\tget() {\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t\thas() {\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t}\n\n\tfunction startResize(item: HTMLElement, handle: ResizeHandle, e: PointerEvent) {\n\t\tconst colspan =\n\t\t\tparseInt(item.getAttribute('data-gridiot-colspan') || '1', 10) || 1;\n\t\tconst rowspan =\n\t\t\tparseInt(item.getAttribute('data-gridiot-rowspan') || '1', 10) || 1;\n\n\t\tconst style = getComputedStyle(item);\n\t\tconst column = parseInt(style.gridColumnStart, 10) || 1;\n\t\tconst row = parseInt(style.gridRowStart, 10) || 1;\n\n\t\tconst originalSize = { colspan, rowspan };\n\t\tconst startCell = { column, row };\n\t\tconst initialRect = item.getBoundingClientRect();\n\n\t\t// Create size label if enabled\n\t\tlet sizeLabel: HTMLElement | null = null;\n\t\tif (showSizeLabel) {\n\t\t\tsizeLabel = createSizeLabel();\n\t\t\tsizeLabel.textContent = `${colspan}\u00D7${rowspan}`;\n\t\t\titem.appendChild(sizeLabel);\n\t\t}\n\n\t\tactiveResize = {\n\t\t\titem,\n\t\t\tpointerId: e.pointerId,\n\t\t\thandle,\n\t\t\tstartCell,\n\t\t\toriginalSize,\n\t\t\tcurrentCell: { ...startCell },\n\t\t\tcurrentSize: { ...originalSize },\n\t\t\toriginalGridColumn: item.style.gridColumn,\n\t\t\toriginalGridRow: item.style.gridRow,\n\t\t\tsizeLabel,\n\t\t\tinitialRect,\n\t\t\tstartPointerX: e.clientX,\n\t\t\tstartPointerY: e.clientY,\n\t\t};\n\n\t\t// Switch to fixed positioning for smooth resize (like drag)\n\t\titem.style.position = 'fixed';\n\t\titem.style.left = `${initialRect.left}px`;\n\t\titem.style.top = `${initialRect.top}px`;\n\t\titem.style.width = `${initialRect.width}px`;\n\t\titem.style.height = `${initialRect.height}px`;\n\t\titem.style.zIndex = '100';\n\t\t// Set to 'auto' to override CSS stylesheet rules and remove from grid layout\n\t\titem.style.gridColumn = 'auto';\n\t\titem.style.gridRow = 'auto';\n\t\t// Exclude from view transitions during resize (like drag uses 'dragging')\n\t\titem.style.viewTransitionName = 'resizing';\n\n\t\titem.setAttribute('data-gridiot-resizing', '');\n\t\titem.setPointerCapture(e.pointerId);\n\n\t\tlog('resize-start', { handle, startCell, originalSize });\n\n\t\temit<ResizeStartDetail>('resize-start', {\n\t\t\titem,\n\t\t\tcell: startCell,\n\t\t\tcolspan: originalSize.colspan,\n\t\t\trowspan: originalSize.rowspan,\n\t\t\thandle,\n\t\t});\n\t}\n\n\tfunction updateResize(e: PointerEvent) {\n\t\tif (!activeResize) return;\n\n\t\tconst { item, handle, startCell, originalSize, currentCell, currentSize, sizeLabel, initialRect, startPointerX, startPointerY } =\n\t\t\tactiveResize;\n\n\t\tconst coreInstance = getCore();\n\t\tconst gridInfo = coreInstance.getGridInfo();\n\n\t\t// Calculate pointer delta\n\t\tconst deltaX = e.clientX - startPointerX;\n\t\tconst deltaY = e.clientY - startPointerY;\n\n\t\t// Calculate new visual dimensions based on handle\n\t\tlet newWidth = initialRect.width;\n\t\tlet newHeight = initialRect.height;\n\t\tlet newLeft = initialRect.left;\n\t\tlet newTop = initialRect.top;\n\n\t\t// Minimum visual size (1 cell)\n\t\tconst minWidth = gridInfo.cellWidth;\n\t\tconst minHeight = gridInfo.cellHeight;\n\t\t// Maximum visual size\n\t\tconst maxWidth = maxSize.colspan * gridInfo.cellWidth + (maxSize.colspan - 1) * gridInfo.gap;\n\t\tconst maxHeight = maxSize.rowspan * gridInfo.cellHeight + (maxSize.rowspan - 1) * gridInfo.gap;\n\n\t\t// Apply delta based on handle direction\n\t\tif (handle === 'e' || handle === 'se' || handle === 'ne') {\n\t\t\tnewWidth = Math.max(minWidth, Math.min(maxWidth, initialRect.width + deltaX));\n\t\t}\n\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t\tconst widthChange = Math.max(-initialRect.width + minWidth, Math.min(maxWidth - initialRect.width, -deltaX));\n\t\t\tnewWidth = initialRect.width + widthChange;\n\t\t\tnewLeft = initialRect.left - widthChange;\n\t\t}\n\t\tif (handle === 's' || handle === 'se' || handle === 'sw') {\n\t\t\tnewHeight = Math.max(minHeight, Math.min(maxHeight, initialRect.height + deltaY));\n\t\t}\n\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t\tconst heightChange = Math.max(-initialRect.height + minHeight, Math.min(maxHeight - initialRect.height, -deltaY));\n\t\t\tnewHeight = initialRect.height + heightChange;\n\t\t\tnewTop = initialRect.top - heightChange;\n\t\t}\n\n\t\t// Apply smooth visual size\n\t\titem.style.left = `${newLeft}px`;\n\t\titem.style.top = `${newTop}px`;\n\t\titem.style.width = `${newWidth}px`;\n\t\titem.style.height = `${newHeight}px`;\n\n\t\t// Calculate projected final grid size (what it will snap to)\n\t\tconst cellPlusGap = gridInfo.cellWidth + gridInfo.gap;\n\t\tconst rowPlusGap = gridInfo.cellHeight + gridInfo.gap;\n\t\tconst projectedColspan = Math.max(minSize.colspan, Math.min(maxSize.colspan, Math.round((newWidth + gridInfo.gap) / cellPlusGap)));\n\t\tconst projectedRowspan = Math.max(minSize.rowspan, Math.min(maxSize.rowspan, Math.round((newHeight + gridInfo.gap) / rowPlusGap)));\n\n\t\t// Calculate projected position for NW/NE/SW handles\n\t\tconst newSize = calculateNewSize(\n\t\t\tcoreInstance,\n\t\t\thandle,\n\t\t\tstartCell,\n\t\t\toriginalSize,\n\t\t\te.clientX,\n\t\t\te.clientY,\n\t\t\tminSize,\n\t\t\tmaxSize,\n\t\t);\n\n\t\t// Update tracking\n\t\tactiveResize.currentSize = { colspan: projectedColspan, rowspan: projectedRowspan };\n\t\tactiveResize.currentCell = { column: newSize.column, row: newSize.row };\n\n\t\t// Update size label with projected final size\n\t\tif (sizeLabel) {\n\t\t\tsizeLabel.textContent = `${projectedColspan}\u00D7${projectedRowspan}`;\n\t\t}\n\n\t\tlog('resize-move', { newSize: { colspan: projectedColspan, rowspan: projectedRowspan }, visual: { width: newWidth, height: newHeight } });\n\n\t\temit<ResizeMoveDetail>('resize-move', {\n\t\t\titem,\n\t\t\tcell: { column: newSize.column, row: newSize.row },\n\t\t\tcolspan: projectedColspan,\n\t\t\trowspan: projectedRowspan,\n\t\t\thandle,\n\t\t});\n\t}\n\n\tfunction finishResize() {\n\t\tif (!activeResize) return;\n\n\t\tconst { item, currentSize, currentCell, originalSize, sizeLabel } = activeResize;\n\n\t\t// FLIP: Capture current visual position (First)\n\t\tconst firstRect = item.getBoundingClientRect();\n\n\t\t// Update data attributes to reflect new size\n\t\titem.setAttribute('data-gridiot-colspan', String(currentSize.colspan));\n\t\titem.setAttribute('data-gridiot-rowspan', String(currentSize.rowspan));\n\n\t\t// Remove size label before clearing styles\n\t\tif (sizeLabel) {\n\t\t\tsizeLabel.remove();\n\t\t}\n\n\t\t// Exclude from View Transitions during FLIP\n\t\titem.style.viewTransitionName = 'none';\n\n\t\t// Clear fixed positioning, return to grid flow\n\t\titem.style.position = '';\n\t\titem.style.left = '';\n\t\titem.style.top = '';\n\t\titem.style.width = '';\n\t\titem.style.height = '';\n\t\titem.style.zIndex = '';\n\n\t\t// Set final grid position\n\t\titem.style.gridColumn = `${currentCell.column} / span ${currentSize.colspan}`;\n\t\titem.style.gridRow = `${currentCell.row} / span ${currentSize.rowspan}`;\n\n\t\titem.removeAttribute('data-gridiot-resizing');\n\n\t\tlog('resize-end', { originalSize, newSize: currentSize, currentCell });\n\n\t\temit<ResizeEndDetail>('resize-end', {\n\t\t\titem,\n\t\t\tcell: currentCell,\n\t\t\tcolspan: currentSize.colspan,\n\t\t\trowspan: currentSize.rowspan,\n\t\t});\n\n\t\t// FLIP: Animate from visual to final position (with scale for resize)\n\t\trequestAnimationFrame(() => {\n\t\t\tanimateFLIPWithTracking(item, firstRect, {\n\t\t\t\tincludeScale: true,\n\t\t\t\ttransformOrigin: 'top left',\n\t\t\t});\n\t\t});\n\n\t\tactiveResize = null;\n\t}\n\n\tfunction cancelResize() {\n\t\tif (!activeResize) return;\n\n\t\tconst { item, originalGridColumn, originalGridRow, sizeLabel } = activeResize;\n\n\t\t// Remove size label\n\t\tif (sizeLabel) {\n\t\t\tsizeLabel.remove();\n\t\t}\n\n\t\t// Clear fixed positioning\n\t\titem.style.position = '';\n\t\titem.style.left = '';\n\t\titem.style.top = '';\n\t\titem.style.width = '';\n\t\titem.style.height = '';\n\t\titem.style.zIndex = '';\n\n\t\t// Restore original grid position\n\t\titem.style.gridColumn = originalGridColumn;\n\t\titem.style.gridRow = originalGridRow;\n\n\t\t// Restore view transition name\n\t\tconst itemId = item.style.getPropertyValue('--item-id') || item.id || item.dataset.id;\n\t\tif (itemId) {\n\t\t\titem.style.viewTransitionName = itemId;\n\t\t} else {\n\t\t\titem.style.viewTransitionName = '';\n\t\t}\n\n\t\titem.removeAttribute('data-gridiot-resizing');\n\n\t\tlog('resize-cancel');\n\n\t\temit<ResizeCancelDetail>('resize-cancel', {\n\t\t\titem,\n\t\t});\n\n\t\tactiveResize = null;\n\t}\n\n\t// --- Event handlers ---\n\n\t// Use capture phase to intercept before pointer plugin\n\tconst onPointerDown = (e: PointerEvent) => {\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-gridiot-item]',\n\t\t) as HTMLElement | null;\n\t\tif (!item) return;\n\n\t\tconst handle = detectHandle(e, item, handleSize, handles);\n\t\tif (!handle) return; // Not on handle - let pointer plugin handle drag\n\n\t\t// Stop event from reaching pointer plugin\n\t\te.stopPropagation();\n\t\te.preventDefault();\n\n\t\tstartResize(item, handle, e);\n\t};\n\n\tconst onPointerMove = (e: PointerEvent) => {\n\t\t// Handle active resize\n\t\tif (activeResize) {\n\t\t\tif (e.pointerId === activeResize.pointerId) {\n\t\t\t\tupdateResize(e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Handle hover cursor changes\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-gridiot-item]',\n\t\t) as HTMLElement | null;\n\n\t\tif (item) {\n\t\t\tconst handle = detectHandle(e, item, handleSize, handles);\n\n\t\t\tif (handle !== hoveredHandle || item !== hoveredItem) {\n\t\t\t\t// Restore previous item's cursor\n\t\t\t\tif (hoveredItem && hoveredItem !== item) {\n\t\t\t\t\thoveredItem.style.cursor = '';\n\t\t\t\t}\n\n\t\t\t\thoveredItem = item;\n\t\t\t\thoveredHandle = handle;\n\n\t\t\t\t// Set cursor based on handle\n\t\t\t\titem.style.cursor = getCursor(handle) || '';\n\t\t\t}\n\t\t} else if (hoveredItem) {\n\t\t\thoveredItem.style.cursor = '';\n\t\t\thoveredItem = null;\n\t\t\thoveredHandle = null;\n\t\t}\n\t};\n\n\tconst onPointerUp = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tactiveResize.item.releasePointerCapture(e.pointerId);\n\t\t\tfinishResize();\n\t\t}\n\t};\n\n\tconst onPointerCancel = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tactiveResize.item.releasePointerCapture(e.pointerId);\n\t\t\tcancelResize();\n\t\t}\n\t};\n\n\tconst onKeyDown = (e: KeyboardEvent) => {\n\t\tif (e.key === 'Escape' && activeResize) {\n\t\t\tactiveResize.item.releasePointerCapture(activeResize.pointerId);\n\t\t\tcancelResize();\n\t\t}\n\t};\n\n\t// Register event listeners\n\tgridElement.addEventListener('pointerdown', onPointerDown, { capture: true });\n\tgridElement.addEventListener('pointermove', onPointerMove);\n\tgridElement.addEventListener('pointerup', onPointerUp);\n\tgridElement.addEventListener('pointercancel', onPointerCancel);\n\tdocument.addEventListener('keydown', onKeyDown);\n\n\t// Public API\n\tfunction setSize(\n\t\titem: HTMLElement,\n\t\tsize: { colspan: number; rowspan: number },\n\t) {\n\t\tconst clampedColspan = Math.max(\n\t\t\tminSize.colspan,\n\t\t\tMath.min(maxSize.colspan, size.colspan),\n\t\t);\n\t\tconst clampedRowspan = Math.max(\n\t\t\tminSize.rowspan,\n\t\t\tMath.min(maxSize.rowspan, size.rowspan),\n\t\t);\n\n\t\tconst style = getComputedStyle(item);\n\t\tconst column = parseInt(style.gridColumnStart, 10) || 1;\n\t\tconst row = parseInt(style.gridRowStart, 10) || 1;\n\n\t\titem.setAttribute('data-gridiot-colspan', String(clampedColspan));\n\t\titem.setAttribute('data-gridiot-rowspan', String(clampedRowspan));\n\t\titem.style.gridColumn = `${column} / span ${clampedColspan}`;\n\t\titem.style.gridRow = `${row} / span ${clampedRowspan}`;\n\n\t\temit<ResizeEndDetail>('resize-end', {\n\t\t\titem,\n\t\t\tcell: { column, row },\n\t\t\tcolspan: clampedColspan,\n\t\t\trowspan: clampedRowspan,\n\t\t});\n\t}\n\n\tfunction destroy() {\n\t\tgridElement.removeEventListener('pointerdown', onPointerDown, {\n\t\t\tcapture: true,\n\t\t});\n\t\tgridElement.removeEventListener('pointermove', onPointerMove);\n\t\tgridElement.removeEventListener('pointerup', onPointerUp);\n\t\tgridElement.removeEventListener('pointercancel', onPointerCancel);\n\t\tdocument.removeEventListener('keydown', onKeyDown);\n\n\t\tif (activeResize) {\n\t\t\tcancelResize();\n\t\t}\n\t}\n\n\treturn { setSize, destroy };\n}\n\n// Register as a plugin for auto-initialization via init()\nregisterPlugin({\n\tname: 'resize',\n\tinit(core, options?: ResizePluginOptions & { core?: GridiotCore }) {\n\t\tconst instance = attachResize(core.element, {\n\t\t\t...options,\n\t\t\tcore: options?.core ?? core,\n\t\t});\n\t\treturn () => instance.destroy();\n\t},\n});\n\nexport type { ResizeHandle };\n"],
  "mappings": ";AAGA,IAAM,UAAU,oBAAI,IAAoB;AAEjC,SAAS,eAAe,QAAsB;AACpD,UAAQ,IAAI,OAAO,MAAM,MAAM;AAChC;;;ACqCO,SAAS,YACf,SACA,WACA,UAAuB,CAAC,GACL;AACnB,QAAM;AAAA,IACL,WAAW;AAAA,IACX,SAAS;AAAA,IACT,eAAe;AAAA,IACf;AAAA,IACA;AAAA,IACA;AAAA,EACD,IAAI;AAGJ,QAAM,WAAW,QAAQ,sBAAsB;AAG/C,QAAM,SAAS,UAAU,OAAO,SAAS;AACzC,QAAM,SAAS,UAAU,MAAM,SAAS;AAExC,QAAM,iBAAiB,KAAK,IAAI,MAAM,IAAI,KAAK,KAAK,IAAI,MAAM,IAAI;AAGlE,MAAI,SAAS;AACb,MAAI,SAAS;AACb,MAAI,aAAa;AAEjB,MAAI,cAAc;AACjB,aAAS,UAAU,QAAQ,SAAS;AACpC,aAAS,UAAU,SAAS,SAAS;AACrC,iBAAa,KAAK,IAAI,SAAS,CAAC,IAAI,QAAQ,KAAK,IAAI,SAAS,CAAC,IAAI;AAAA,EACpE;AAGA,MAAI,CAAC,kBAAkB,CAAC,YAAY;AACnC,eAAW;AACX,WAAO;AAAA,EACR;AAEA,YAAU;AAGV,QAAM,YAAwB,eAC3B;AAAA,IACA;AAAA,MACC,WAAW,aAAa,MAAM,OAAO,MAAM,aAAa,MAAM,KAAK,MAAM;AAAA,MACzE,iBAAiB,mBAAmB;AAAA,IACrC;AAAA,IACA;AAAA,MACC,WAAW;AAAA,MACX,iBAAiB,mBAAmB;AAAA,IACrC;AAAA,EACD,IACC;AAAA,IACA,EAAE,WAAW,aAAa,MAAM,OAAO,MAAM,MAAM;AAAA,IACnD,EAAE,WAAW,kBAAkB;AAAA,EAChC;AAGF,QAAM,YAAY,QAAQ,QAAQ,WAAW;AAAA,IAC5C;AAAA,IACA;AAAA,EACD,CAAC;AAED,YAAU,WAAW,MAAM,WAAW;AAEtC,SAAO;AACR;AAMO,SAAS,0BAA0B,SAAqC;AAC9E,SACC,QAAQ,MAAM,iBAAiB,WAAW,KAC1C,QAAQ,MACR,QAAQ,QAAQ,MAChB;AAEF;AAgFO,SAAS,wBACf,SACA,WACA,UAAoD,CAAC,GAClC;AACnB,QAAM,EAAE,gBAAgB,yBAAyB,GAAG,YAAY,IAAI;AAGpE,UAAQ,MAAM,qBAAqB;AAEnC,QAAM,YAAY,YAAY,SAAS,WAAW;AAAA,IACjD,GAAG;AAAA,IACH,SAAS,MAAM;AACd,cAAQ,aAAa,eAAe,EAAE;AACtC,kBAAY,UAAU;AAAA,IACvB;AAAA,IACA,UAAU,MAAM;AACf,cAAQ,gBAAgB,aAAa;AAErC,YAAM,SAAS,0BAA0B,OAAO;AAChD,UAAI,QAAQ;AACX,gBAAQ,MAAM,qBAAqB;AAAA,MACpC;AACA,kBAAY,WAAW;AAAA,IACxB;AAAA,EACD,CAAC;AAGD,MAAI,CAAC,WAAW;AACf,UAAM,SAAS,0BAA0B,OAAO;AAChD,QAAI,QAAQ;AACX,cAAQ,MAAM,qBAAqB;AAAA,IACpC;AAAA,EACD;AAEA,SAAO;AACR;;;AClNA,IAAM,QAAQ;AACd,SAAS,OAAO,MAAiB;AAChC,MAAI,MAAO,SAAQ,IAAI,YAAY,GAAG,IAAI;AAC3C;AA0CA,SAAS,aACR,GACA,MACA,MACA,MACsB;AACtB,QAAM,OAAO,KAAK,sBAAsB;AACxC,QAAM,IAAI,EAAE,UAAU,KAAK;AAC3B,QAAM,IAAI,EAAE,UAAU,KAAK;AAE3B,QAAM,WAAW,IAAI;AACrB,QAAM,YAAY,IAAI,KAAK,QAAQ;AACnC,QAAM,UAAU,IAAI;AACpB,QAAM,aAAa,IAAI,KAAK,SAAS;AAGrC,MAAI,SAAS,aAAa,SAAS,OAAO;AACzC,QAAI,WAAW,SAAU,QAAO;AAChC,QAAI,WAAW,UAAW,QAAO;AACjC,QAAI,cAAc,SAAU,QAAO;AACnC,QAAI,cAAc,UAAW,QAAO;AAAA,EACrC;AAGA,MAAI,SAAS,WAAW,SAAS,OAAO;AACvC,QAAI,QAAS,QAAO;AACpB,QAAI,WAAY,QAAO;AACvB,QAAI,SAAU,QAAO;AACrB,QAAI,UAAW,QAAO;AAAA,EACvB;AAEA,SAAO;AACR;AAKA,SAAS,UAAU,QAAqC;AACvD,UAAQ,QAAQ;AAAA,IACf,KAAK;AAAA,IACL,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AAAA,IACL,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AAAA,IACL,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AAAA,IACL,KAAK;AACJ,aAAO;AAAA,IACR;AACC,aAAO;AAAA,EACT;AACD;AAKA,SAAS,iBACR,MACA,QACA,WACA,cACA,UACA,UACA,SACA,SACoE;AACpE,QAAM,WAAW,KAAK,YAAY;AAClC,QAAM,YAAY,SAAS,QAAQ;AACnC,QAAM,SAAS,SAAS,KAAK;AAI7B,MAAI,cAAc,KAAK,iBAAiB,UAAU,QAAQ;AAC1D,MAAI,CAAC,aAAa;AAEjB,UAAM,OAAO,SAAS;AACtB,UAAM,YAAY,SAAS,YAAY,SAAS;AAChD,UAAM,aAAa,SAAS,aAAa,SAAS;AAElD,QAAI;AACJ,QAAI;AAEJ,QAAI,WAAW,KAAK,MAAM;AACzB,eAAS;AAAA,IACV,WAAW,WAAW,KAAK,OAAO;AACjC,eAAS;AAAA,IACV,OAAO;AACN,eAAS,KAAK,IAAI,GAAG,KAAK,IAAI,WAAW,KAAK,OAAO,WAAW,KAAK,QAAQ,SAAS,IAAI,CAAC,CAAC;AAAA,IAC7F;AAEA,QAAI,WAAW,KAAK,KAAK;AACxB,YAAM;AAAA,IACP,WAAW,WAAW,KAAK,QAAQ;AAClC,YAAM;AAAA,IACP,OAAO;AACN,YAAM,KAAK,IAAI,GAAG,KAAK,IAAI,QAAQ,KAAK,OAAO,WAAW,KAAK,OAAO,UAAU,IAAI,CAAC,CAAC;AAAA,IACvF;AAEA,kBAAc,EAAE,QAAQ,IAAI;AAAA,EAC7B;AAEA,MAAI,aAAa,aAAa;AAC9B,MAAI,aAAa,aAAa;AAC9B,MAAI,YAAY,UAAU;AAC1B,MAAI,SAAS,UAAU;AAGvB,MAAI,WAAW,OAAO,WAAW,QAAQ,WAAW,MAAM;AAEzD,iBAAa,KAAK;AAAA,MACjB,QAAQ;AAAA,MACR,KAAK;AAAA,QACJ,QAAQ;AAAA,QACR,YAAY,SAAS,UAAU,SAAS;AAAA,QACxC,YAAY,UAAU,SAAS;AAAA,MAChC;AAAA,IACD;AAAA,EACD,WAAW,WAAW,OAAO,WAAW,QAAQ,WAAW,MAAM;AAEhE,UAAM,YAAY,UAAU,SAAS,aAAa,UAAU;AAC5D,UAAM,UAAU,KAAK,IAAI,GAAG,KAAK,IAAI,YAAY,QAAQ,SAAS,CAAC;AACnE,iBAAa,KAAK;AAAA,MACjB,QAAQ;AAAA,MACR,KAAK,IAAI,QAAQ,SAAS,YAAY,UAAU,CAAC;AAAA,IAClD;AACA,gBAAY,YAAY,aAAa;AAAA,EACtC;AAGA,MAAI,WAAW,OAAO,WAAW,QAAQ,WAAW,MAAM;AAEzD,iBAAa,KAAK;AAAA,MACjB,QAAQ;AAAA,MACR,KAAK;AAAA,QACJ,QAAQ;AAAA,QACR,YAAY,MAAM,UAAU,MAAM;AAAA,QAClC,SAAS,UAAU,MAAM;AAAA,MAC1B;AAAA,IACD;AAAA,EACD,WAAW,WAAW,OAAO,WAAW,QAAQ,WAAW,MAAM;AAEhE,UAAM,aAAa,UAAU,MAAM,aAAa,UAAU;AAC1D,UAAM,SAAS,KAAK,IAAI,GAAG,KAAK,IAAI,YAAY,KAAK,UAAU,CAAC;AAChE,iBAAa,KAAK;AAAA,MACjB,QAAQ;AAAA,MACR,KAAK,IAAI,QAAQ,SAAS,aAAa,SAAS,CAAC;AAAA,IAClD;AACA,aAAS,aAAa,aAAa;AAAA,EACpC;AAEA,SAAO;AAAA,IACN,SAAS;AAAA,IACT,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,KAAK;AAAA,EACN;AACD;AAKA,SAAS,kBAA+B;AACvC,QAAM,QAAQ,SAAS,cAAc,KAAK;AAC1C,QAAM,YAAY;AAClB,QAAM,MAAM,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBtB,SAAO;AACR;AASO,SAAS,aACf,aACA,UAAyB,CAAC,GAIzB;AACD,QAAM;AAAA,IACL,UAAU;AAAA,IACV,aAAa;AAAA,IACb,UAAU,EAAE,SAAS,GAAG,SAAS,EAAE;AAAA,IACnC,UAAU,EAAE,SAAS,GAAG,SAAS,EAAE;AAAA,IACnC,gBAAgB;AAAA,IAChB;AAAA,EACD,IAAI;AAEJ,MAAI,eAAoC;AACxC,MAAI,cAAkC;AACtC,MAAI,gBAAqC;AAGzC,MAAI,MAAM;AACT,SAAK,UAAU,SAA6B,UAAU,MAAM;AAC3D,UAAI,CAAC,aAAc,QAAO;AAC1B,aAAO;AAAA,QACN,MAAM,aAAa;AAAA,QACnB,cAAc,aAAa;AAAA,QAC3B,aAAa,aAAa;AAAA,QAC1B,QAAQ,aAAa;AAAA,MACtB;AAAA,IACD,CAAC;AAAA,EACF;AAEA,WAAS,KAAQ,OAAe,QAAiB;AAChD,gBAAY;AAAA,MACX,IAAI,YAAY,WAAW,KAAK,IAAI;AAAA,QACnC,SAAS;AAAA,QACT;AAAA,MACD,CAAC;AAAA,IACF;AAAA,EACD;AAEA,WAAS,UAAuB;AAC/B,QAAI,KAAM,QAAO;AAGjB,WAAO;AAAA,MACN,SAAS;AAAA,MACT,iBAAiB,GAAW,GAAW;AACtC,cAAM,OAAO,YAAY,sBAAsB;AAC/C,YAAI,IAAI,KAAK,QAAQ,IAAI,KAAK,SAAS,IAAI,KAAK,OAAO,IAAI,KAAK,QAAQ;AACvE,iBAAO;AAAA,QACR;AACA,cAAM,QAAQ,iBAAiB,WAAW;AAC1C,cAAM,UAAU,MAAM,oBAAoB,MAAM,GAAG,EAAE,OAAO,OAAO;AACnE,cAAM,OAAO,MAAM,iBAAiB,MAAM,GAAG,EAAE,OAAO,OAAO;AAC7D,cAAM,YAAY,WAAW,MAAM,SAAS,KAAK;AACjD,cAAM,SAAS,WAAW,MAAM,MAAM,KAAK;AAE3C,cAAM,OAAO,IAAI,KAAK;AACtB,cAAM,OAAO,IAAI,KAAK;AAEtB,cAAM,aACJ,WAAW,QAAQ,CAAC,KAAK,GAAG,KAAK,KAAK;AACxC,cAAM,cAAc,WAAW,KAAK,CAAC,KAAK,GAAG,KAAK,KAAK;AAEvD,cAAM,SAAS,YAAY,IAAI,KAAK,MAAM,OAAO,SAAS,IAAI,IAAI;AAClE,cAAM,MAAM,aAAa,IAAI,KAAK,MAAM,OAAO,UAAU,IAAI,IAAI;AAEjE,eAAO;AAAA,UACN,QAAQ,KAAK,IAAI,GAAG,KAAK,IAAI,QAAQ,QAAQ,MAAM,CAAC;AAAA,UACpD,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,KAAK,KAAK,MAAM,CAAC;AAAA,QAC5C;AAAA,MACD;AAAA,MACA,cAAc;AACb,cAAM,OAAO,YAAY,sBAAsB;AAC/C,cAAM,QAAQ,iBAAiB,WAAW;AAC1C,cAAM,UAAU,MAAM,oBACpB,MAAM,GAAG,EACT,OAAO,OAAO,EACd,IAAI,CAAC,MAAM,WAAW,CAAC,KAAK,CAAC;AAC/B,cAAM,OAAO,MAAM,iBACjB,MAAM,GAAG,EACT,OAAO,OAAO,EACd,IAAI,CAAC,MAAM,WAAW,CAAC,KAAK,CAAC;AAC/B,cAAM,YAAY,WAAW,MAAM,SAAS,KAAK;AAEjD,eAAO;AAAA,UACN;AAAA,UACA;AAAA,UACA;AAAA,UACA,KAAK;AAAA,UACL,WAAW,QAAQ,CAAC,KAAK;AAAA,UACzB,YAAY,KAAK,CAAC,KAAK;AAAA,QACxB;AAAA,MACD;AAAA,MACA;AAAA,MACA,UAAU;AAAA,MAAC;AAAA,MACX,cAAc;AAAA,MACd,SAAS;AAAA,MAAC;AAAA,MACV,WAAW;AAAA,MAAC;AAAA,MACZ,WAAW;AAAA,QACV,WAAW;AAAA,QAAC;AAAA,QACZ,MAAM;AACL,iBAAO;AAAA,QACR;AAAA,QACA,MAAM;AACL,iBAAO;AAAA,QACR;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAEA,WAAS,YAAY,MAAmB,QAAsB,GAAiB;AAC9E,UAAM,UACL,SAAS,KAAK,aAAa,sBAAsB,KAAK,KAAK,EAAE,KAAK;AACnE,UAAM,UACL,SAAS,KAAK,aAAa,sBAAsB,KAAK,KAAK,EAAE,KAAK;AAEnE,UAAM,QAAQ,iBAAiB,IAAI;AACnC,UAAM,SAAS,SAAS,MAAM,iBAAiB,EAAE,KAAK;AACtD,UAAM,MAAM,SAAS,MAAM,cAAc,EAAE,KAAK;AAEhD,UAAM,eAAe,EAAE,SAAS,QAAQ;AACxC,UAAM,YAAY,EAAE,QAAQ,IAAI;AAChC,UAAM,cAAc,KAAK,sBAAsB;AAG/C,QAAI,YAAgC;AACpC,QAAI,eAAe;AAClB,kBAAY,gBAAgB;AAC5B,gBAAU,cAAc,GAAG,OAAO,OAAI,OAAO;AAC7C,WAAK,YAAY,SAAS;AAAA,IAC3B;AAEA,mBAAe;AAAA,MACd;AAAA,MACA,WAAW,EAAE;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA,aAAa,EAAE,GAAG,UAAU;AAAA,MAC5B,aAAa,EAAE,GAAG,aAAa;AAAA,MAC/B,oBAAoB,KAAK,MAAM;AAAA,MAC/B,iBAAiB,KAAK,MAAM;AAAA,MAC5B;AAAA,MACA;AAAA,MACA,eAAe,EAAE;AAAA,MACjB,eAAe,EAAE;AAAA,IAClB;AAGA,SAAK,MAAM,WAAW;AACtB,SAAK,MAAM,OAAO,GAAG,YAAY,IAAI;AACrC,SAAK,MAAM,MAAM,GAAG,YAAY,GAAG;AACnC,SAAK,MAAM,QAAQ,GAAG,YAAY,KAAK;AACvC,SAAK,MAAM,SAAS,GAAG,YAAY,MAAM;AACzC,SAAK,MAAM,SAAS;AAEpB,SAAK,MAAM,aAAa;AACxB,SAAK,MAAM,UAAU;AAErB,SAAK,MAAM,qBAAqB;AAEhC,SAAK,aAAa,yBAAyB,EAAE;AAC7C,SAAK,kBAAkB,EAAE,SAAS;AAElC,QAAI,gBAAgB,EAAE,QAAQ,WAAW,aAAa,CAAC;AAEvD,SAAwB,gBAAgB;AAAA,MACvC;AAAA,MACA,MAAM;AAAA,MACN,SAAS,aAAa;AAAA,MACtB,SAAS,aAAa;AAAA,MACtB;AAAA,IACD,CAAC;AAAA,EACF;AAEA,WAAS,aAAa,GAAiB;AACtC,QAAI,CAAC,aAAc;AAEnB,UAAM,EAAE,MAAM,QAAQ,WAAW,cAAc,aAAa,aAAa,WAAW,aAAa,eAAe,cAAc,IAC7H;AAED,UAAM,eAAe,QAAQ;AAC7B,UAAM,WAAW,aAAa,YAAY;AAG1C,UAAM,SAAS,EAAE,UAAU;AAC3B,UAAM,SAAS,EAAE,UAAU;AAG3B,QAAI,WAAW,YAAY;AAC3B,QAAI,YAAY,YAAY;AAC5B,QAAI,UAAU,YAAY;AAC1B,QAAI,SAAS,YAAY;AAGzB,UAAM,WAAW,SAAS;AAC1B,UAAM,YAAY,SAAS;AAE3B,UAAM,WAAW,QAAQ,UAAU,SAAS,aAAa,QAAQ,UAAU,KAAK,SAAS;AACzF,UAAM,YAAY,QAAQ,UAAU,SAAS,cAAc,QAAQ,UAAU,KAAK,SAAS;AAG3F,QAAI,WAAW,OAAO,WAAW,QAAQ,WAAW,MAAM;AACzD,iBAAW,KAAK,IAAI,UAAU,KAAK,IAAI,UAAU,YAAY,QAAQ,MAAM,CAAC;AAAA,IAC7E;AACA,QAAI,WAAW,OAAO,WAAW,QAAQ,WAAW,MAAM;AACzD,YAAM,cAAc,KAAK,IAAI,CAAC,YAAY,QAAQ,UAAU,KAAK,IAAI,WAAW,YAAY,OAAO,CAAC,MAAM,CAAC;AAC3G,iBAAW,YAAY,QAAQ;AAC/B,gBAAU,YAAY,OAAO;AAAA,IAC9B;AACA,QAAI,WAAW,OAAO,WAAW,QAAQ,WAAW,MAAM;AACzD,kBAAY,KAAK,IAAI,WAAW,KAAK,IAAI,WAAW,YAAY,SAAS,MAAM,CAAC;AAAA,IACjF;AACA,QAAI,WAAW,OAAO,WAAW,QAAQ,WAAW,MAAM;AACzD,YAAM,eAAe,KAAK,IAAI,CAAC,YAAY,SAAS,WAAW,KAAK,IAAI,YAAY,YAAY,QAAQ,CAAC,MAAM,CAAC;AAChH,kBAAY,YAAY,SAAS;AACjC,eAAS,YAAY,MAAM;AAAA,IAC5B;AAGA,SAAK,MAAM,OAAO,GAAG,OAAO;AAC5B,SAAK,MAAM,MAAM,GAAG,MAAM;AAC1B,SAAK,MAAM,QAAQ,GAAG,QAAQ;AAC9B,SAAK,MAAM,SAAS,GAAG,SAAS;AAGhC,UAAM,cAAc,SAAS,YAAY,SAAS;AAClD,UAAM,aAAa,SAAS,aAAa,SAAS;AAClD,UAAM,mBAAmB,KAAK,IAAI,QAAQ,SAAS,KAAK,IAAI,QAAQ,SAAS,KAAK,OAAO,WAAW,SAAS,OAAO,WAAW,CAAC,CAAC;AACjI,UAAM,mBAAmB,KAAK,IAAI,QAAQ,SAAS,KAAK,IAAI,QAAQ,SAAS,KAAK,OAAO,YAAY,SAAS,OAAO,UAAU,CAAC,CAAC;AAGjI,UAAM,UAAU;AAAA,MACf;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,EAAE;AAAA,MACF,EAAE;AAAA,MACF;AAAA,MACA;AAAA,IACD;AAGA,iBAAa,cAAc,EAAE,SAAS,kBAAkB,SAAS,iBAAiB;AAClF,iBAAa,cAAc,EAAE,QAAQ,QAAQ,QAAQ,KAAK,QAAQ,IAAI;AAGtE,QAAI,WAAW;AACd,gBAAU,cAAc,GAAG,gBAAgB,OAAI,gBAAgB;AAAA,IAChE;AAEA,QAAI,eAAe,EAAE,SAAS,EAAE,SAAS,kBAAkB,SAAS,iBAAiB,GAAG,QAAQ,EAAE,OAAO,UAAU,QAAQ,UAAU,EAAE,CAAC;AAExI,SAAuB,eAAe;AAAA,MACrC;AAAA,MACA,MAAM,EAAE,QAAQ,QAAQ,QAAQ,KAAK,QAAQ,IAAI;AAAA,MACjD,SAAS;AAAA,MACT,SAAS;AAAA,MACT;AAAA,IACD,CAAC;AAAA,EACF;AAEA,WAAS,eAAe;AACvB,QAAI,CAAC,aAAc;AAEnB,UAAM,EAAE,MAAM,aAAa,aAAa,cAAc,UAAU,IAAI;AAGpE,UAAM,YAAY,KAAK,sBAAsB;AAG7C,SAAK,aAAa,wBAAwB,OAAO,YAAY,OAAO,CAAC;AACrE,SAAK,aAAa,wBAAwB,OAAO,YAAY,OAAO,CAAC;AAGrE,QAAI,WAAW;AACd,gBAAU,OAAO;AAAA,IAClB;AAGA,SAAK,MAAM,qBAAqB;AAGhC,SAAK,MAAM,WAAW;AACtB,SAAK,MAAM,OAAO;AAClB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,QAAQ;AACnB,SAAK,MAAM,SAAS;AACpB,SAAK,MAAM,SAAS;AAGpB,SAAK,MAAM,aAAa,GAAG,YAAY,MAAM,WAAW,YAAY,OAAO;AAC3E,SAAK,MAAM,UAAU,GAAG,YAAY,GAAG,WAAW,YAAY,OAAO;AAErE,SAAK,gBAAgB,uBAAuB;AAE5C,QAAI,cAAc,EAAE,cAAc,SAAS,aAAa,YAAY,CAAC;AAErE,SAAsB,cAAc;AAAA,MACnC;AAAA,MACA,MAAM;AAAA,MACN,SAAS,YAAY;AAAA,MACrB,SAAS,YAAY;AAAA,IACtB,CAAC;AAGD,0BAAsB,MAAM;AAC3B,8BAAwB,MAAM,WAAW;AAAA,QACxC,cAAc;AAAA,QACd,iBAAiB;AAAA,MAClB,CAAC;AAAA,IACF,CAAC;AAED,mBAAe;AAAA,EAChB;AAEA,WAAS,eAAe;AACvB,QAAI,CAAC,aAAc;AAEnB,UAAM,EAAE,MAAM,oBAAoB,iBAAiB,UAAU,IAAI;AAGjE,QAAI,WAAW;AACd,gBAAU,OAAO;AAAA,IAClB;AAGA,SAAK,MAAM,WAAW;AACtB,SAAK,MAAM,OAAO;AAClB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,QAAQ;AACnB,SAAK,MAAM,SAAS;AACpB,SAAK,MAAM,SAAS;AAGpB,SAAK,MAAM,aAAa;AACxB,SAAK,MAAM,UAAU;AAGrB,UAAM,SAAS,KAAK,MAAM,iBAAiB,WAAW,KAAK,KAAK,MAAM,KAAK,QAAQ;AACnF,QAAI,QAAQ;AACX,WAAK,MAAM,qBAAqB;AAAA,IACjC,OAAO;AACN,WAAK,MAAM,qBAAqB;AAAA,IACjC;AAEA,SAAK,gBAAgB,uBAAuB;AAE5C,QAAI,eAAe;AAEnB,SAAyB,iBAAiB;AAAA,MACzC;AAAA,IACD,CAAC;AAED,mBAAe;AAAA,EAChB;AAKA,QAAM,gBAAgB,CAAC,MAAoB;AAC1C,UAAM,OAAQ,EAAE,OAAuB;AAAA,MACtC;AAAA,IACD;AACA,QAAI,CAAC,KAAM;AAEX,UAAM,SAAS,aAAa,GAAG,MAAM,YAAY,OAAO;AACxD,QAAI,CAAC,OAAQ;AAGb,MAAE,gBAAgB;AAClB,MAAE,eAAe;AAEjB,gBAAY,MAAM,QAAQ,CAAC;AAAA,EAC5B;AAEA,QAAM,gBAAgB,CAAC,MAAoB;AAE1C,QAAI,cAAc;AACjB,UAAI,EAAE,cAAc,aAAa,WAAW;AAC3C,qBAAa,CAAC;AAAA,MACf;AACA;AAAA,IACD;AAGA,UAAM,OAAQ,EAAE,OAAuB;AAAA,MACtC;AAAA,IACD;AAEA,QAAI,MAAM;AACT,YAAM,SAAS,aAAa,GAAG,MAAM,YAAY,OAAO;AAExD,UAAI,WAAW,iBAAiB,SAAS,aAAa;AAErD,YAAI,eAAe,gBAAgB,MAAM;AACxC,sBAAY,MAAM,SAAS;AAAA,QAC5B;AAEA,sBAAc;AACd,wBAAgB;AAGhB,aAAK,MAAM,SAAS,UAAU,MAAM,KAAK;AAAA,MAC1C;AAAA,IACD,WAAW,aAAa;AACvB,kBAAY,MAAM,SAAS;AAC3B,oBAAc;AACd,sBAAgB;AAAA,IACjB;AAAA,EACD;AAEA,QAAM,cAAc,CAAC,MAAoB;AACxC,QAAI,gBAAgB,EAAE,cAAc,aAAa,WAAW;AAC3D,mBAAa,KAAK,sBAAsB,EAAE,SAAS;AACnD,mBAAa;AAAA,IACd;AAAA,EACD;AAEA,QAAM,kBAAkB,CAAC,MAAoB;AAC5C,QAAI,gBAAgB,EAAE,cAAc,aAAa,WAAW;AAC3D,mBAAa,KAAK,sBAAsB,EAAE,SAAS;AACnD,mBAAa;AAAA,IACd;AAAA,EACD;AAEA,QAAM,YAAY,CAAC,MAAqB;AACvC,QAAI,EAAE,QAAQ,YAAY,cAAc;AACvC,mBAAa,KAAK,sBAAsB,aAAa,SAAS;AAC9D,mBAAa;AAAA,IACd;AAAA,EACD;AAGA,cAAY,iBAAiB,eAAe,eAAe,EAAE,SAAS,KAAK,CAAC;AAC5E,cAAY,iBAAiB,eAAe,aAAa;AACzD,cAAY,iBAAiB,aAAa,WAAW;AACrD,cAAY,iBAAiB,iBAAiB,eAAe;AAC7D,WAAS,iBAAiB,WAAW,SAAS;AAG9C,WAAS,QACR,MACA,MACC;AACD,UAAM,iBAAiB,KAAK;AAAA,MAC3B,QAAQ;AAAA,MACR,KAAK,IAAI,QAAQ,SAAS,KAAK,OAAO;AAAA,IACvC;AACA,UAAM,iBAAiB,KAAK;AAAA,MAC3B,QAAQ;AAAA,MACR,KAAK,IAAI,QAAQ,SAAS,KAAK,OAAO;AAAA,IACvC;AAEA,UAAM,QAAQ,iBAAiB,IAAI;AACnC,UAAM,SAAS,SAAS,MAAM,iBAAiB,EAAE,KAAK;AACtD,UAAM,MAAM,SAAS,MAAM,cAAc,EAAE,KAAK;AAEhD,SAAK,aAAa,wBAAwB,OAAO,cAAc,CAAC;AAChE,SAAK,aAAa,wBAAwB,OAAO,cAAc,CAAC;AAChE,SAAK,MAAM,aAAa,GAAG,MAAM,WAAW,cAAc;AAC1D,SAAK,MAAM,UAAU,GAAG,GAAG,WAAW,cAAc;AAEpD,SAAsB,cAAc;AAAA,MACnC;AAAA,MACA,MAAM,EAAE,QAAQ,IAAI;AAAA,MACpB,SAAS;AAAA,MACT,SAAS;AAAA,IACV,CAAC;AAAA,EACF;AAEA,WAAS,UAAU;AAClB,gBAAY,oBAAoB,eAAe,eAAe;AAAA,MAC7D,SAAS;AAAA,IACV,CAAC;AACD,gBAAY,oBAAoB,eAAe,aAAa;AAC5D,gBAAY,oBAAoB,aAAa,WAAW;AACxD,gBAAY,oBAAoB,iBAAiB,eAAe;AAChE,aAAS,oBAAoB,WAAW,SAAS;AAEjD,QAAI,cAAc;AACjB,mBAAa;AAAA,IACd;AAAA,EACD;AAEA,SAAO,EAAE,SAAS,QAAQ;AAC3B;AAGA,eAAe;AAAA,EACd,MAAM;AAAA,EACN,KAAK,MAAM,SAAwD;AAClE,UAAM,WAAW,aAAa,KAAK,SAAS;AAAA,MAC3C,GAAG;AAAA,MACH,MAAM,SAAS,QAAQ;AAAA,IACxB,CAAC;AACD,WAAO,MAAM,SAAS,QAAQ;AAAA,EAC/B;AACD,CAAC;",
  "names": []
}
