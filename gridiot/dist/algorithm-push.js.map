{
  "version": 3,
  "sources": ["../../engine.ts", "../../plugins/algorithm-push-core.ts", "../../plugins/algorithm-push.ts"],
  "sourcesContent": ["import type { GridCell, GridiotCore, InitOptions, Plugin, PluginOptions, ProviderRegistry } from './types';\n\n// Global plugin registry\nconst plugins = new Map<string, Plugin>();\n\nexport function registerPlugin(plugin: Plugin): void {\n\tplugins.set(plugin.name, plugin);\n}\n\nexport function getPlugin(name: string): Plugin | undefined {\n\treturn plugins.get(name);\n}\n\n/**\n * Initialize Gridiot on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options including layoutModel, styleElement, and plugin options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): GridiotCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t\tplugins: pluginOptions = {},\n\t\tdisablePlugins = [],\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\tlet selectedItem: HTMLElement | null = null;\n\n\t// Provider registry for inter-plugin communication\n\tconst providerMap = new Map<string, () => unknown>();\n\tconst providers: ProviderRegistry = {\n\t\tregister<T>(capability: string, provider: () => T): void {\n\t\t\tif (providerMap.has(capability)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Gridiot: Provider for \"${capability}\" already registered, overwriting`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tproviderMap.set(capability, provider);\n\t\t},\n\n\t\tget<T>(capability: string): T | undefined {\n\t\t\tconst provider = providerMap.get(capability);\n\t\t\treturn provider ? (provider() as T) : undefined;\n\t\t},\n\n\t\thas(capability: string): boolean {\n\t\t\treturn providerMap.has(capability);\n\t\t},\n\t};\n\n\tconst core: GridiotCore = {\n\t\telement,\n\t\tproviders,\n\n\t\t// Selection state\n\t\tget selectedItem() {\n\t\t\treturn selectedItem;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedItem) return;\n\n\t\t\tconst previousItem = selectedItem;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-gridiot-selected');\n\t\t\t}\n\n\t\t\t// Set new selection\n\t\t\tselectedItem = item;\n\n\t\t\tif (item) {\n\t\t\t\titem.setAttribute('data-gridiot-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else if (previousItem) {\n\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`gridiot:${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tobserver.disconnect();\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Observe position changes and animate with View Transitions\n\tconst observer = new MutationObserver((mutations) => {\n\t\t// Collect items that changed position\n\t\tconst changedItems = new Set<HTMLElement>();\n\n\t\tfor (const mutation of mutations) {\n\t\t\tif (\n\t\t\t\tmutation.type === 'attributes' &&\n\t\t\t\tmutation.target instanceof HTMLElement\n\t\t\t) {\n\t\t\t\tconst item = mutation.target.closest(\n\t\t\t\t\t'[data-gridiot-item]',\n\t\t\t\t) as HTMLElement | null;\n\t\t\t\tif (item && element.contains(item)) {\n\t\t\t\t\tchangedItems.add(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Animate changes with View Transitions if available\n\t\tif (changedItems.size > 0 && 'startViewTransition' in document) {\n\t\t\t// Items already moved - View Transitions will handle animation\n\t\t\t// The browser captures before/after states automatically\n\t\t}\n\t});\n\n\tobserver.observe(element, {\n\t\tsubtree: true,\n\t\tattributes: true,\n\t\tattributeFilter: ['style', 'class'],\n\t});\n\n\t// Initialize all registered plugins with options\n\tfor (const plugin of plugins.values()) {\n\t\t// Skip disabled plugins\n\t\tif (disablePlugins.includes(plugin.name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Build options for this plugin\n\t\tconst pluginSpecificOptions = pluginOptions[plugin.name as keyof PluginOptions] ?? {};\n\t\tconst opts = {\n\t\t\t...pluginSpecificOptions,\n\t\t\t// Pass shared resources to all plugins that might need them\n\t\t\tlayoutModel,\n\t\t\tstyleElement,\n\t\t\tcore,\n\t\t};\n\n\t\tconst cleanup = plugin.init(core, opts);\n\t\tif (cleanup) {\n\t\t\tcleanups.push(cleanup);\n\t\t}\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Set an item's grid position\n */\nexport function setItemCell(item: HTMLElement, cell: GridCell): void {\n\titem.style.gridColumn = String(cell.column);\n\titem.style.gridRow = String(cell.row);\n}\n\n/**\n * Get grid info for a grid element\n */\nexport function getGridInfo(element: HTMLElement) {\n\tconst rect = element.getBoundingClientRect();\n\tconst style = getComputedStyle(element);\n\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\tconst columnGap = parseFloat(style.columnGap) || 0;\n\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\treturn {\n\t\trect,\n\t\tcolumns,\n\t\trows,\n\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\tcellWidth: columns[0] || 0,\n\t\tcellHeight: rows[0] || 0,\n\t};\n}\n", "/**\n * Pure push-down layout algorithm - no DOM dependencies\n * This module contains the core layout logic that can be tested independently.\n */\n\nexport interface GridCell {\n\tcolumn: number;\n\trow: number;\n}\n\nexport interface ItemRect {\n\tid: string;\n\tcolumn: number;\n\trow: number;\n\twidth: number;\n\theight: number;\n}\n\n/**\n * Check if two items overlap\n */\nexport function itemsOverlap(a: ItemRect, b: ItemRect): boolean {\n\treturn !(\n\t\ta.column + a.width <= b.column ||\n\t\tb.column + b.width <= a.column ||\n\t\ta.row + a.height <= b.row ||\n\t\tb.row + b.height <= a.row\n\t);\n}\n\n/**\n * Check if any items in the layout overlap\n * @returns Array of overlapping pairs, empty if no overlaps\n */\nexport function findOverlaps(items: ItemRect[]): Array<[ItemRect, ItemRect]> {\n\tconst overlaps: Array<[ItemRect, ItemRect]> = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tfor (let j = i + 1; j < items.length; j++) {\n\t\t\tif (itemsOverlap(items[i], items[j])) {\n\t\t\t\toverlaps.push([items[i], items[j]]);\n\t\t\t}\n\t\t}\n\t}\n\treturn overlaps;\n}\n\n/**\n * Push items down recursively to resolve collisions\n * Mutates the items array in place\n */\nexport function pushDown(\n\titems: ItemRect[],\n\tmoved: ItemRect,\n\tmovedId: string,\n\tdepth = 0,\n): void {\n\tif (depth > 50) {\n\t\treturn;\n\t}\n\n\t// Sort by row descending - push bottom items first so upper items settle on top\n\t// This preserves the original relative ordering of items\n\tconst colliders = items\n\t\t.filter((it) => it.id !== movedId && it.id !== moved.id && itemsOverlap(moved, it))\n\t\t.sort((a, b) => b.row - a.row || a.column - b.column);\n\n\tfor (const collider of colliders) {\n\t\tconst newRow = moved.row + moved.height;\n\t\tif (collider.row < newRow) {\n\t\t\tcollider.row = newRow;\n\t\t\tpushDown(items, collider, movedId, depth + 1);\n\t\t}\n\t}\n}\n\n/**\n * Compact items upward to fill gaps\n * Mutates the items array in place\n */\nexport function compactUp(items: ItemRect[], excludeId: string): void {\n\tconst sorted = [...items]\n\t\t.filter((it) => it.id !== excludeId)\n\t\t.sort((a, b) => a.row - b.row || a.column - b.column);\n\n\tfor (const item of sorted) {\n\t\tlet iterations = 0;\n\t\twhile (item.row > 1 && iterations < 100) {\n\t\t\titerations++;\n\t\t\titem.row -= 1;\n\t\t\tconst hasCollision = items.some(\n\t\t\t\t(other) => other.id !== item.id && itemsOverlap(item, other),\n\t\t\t);\n\t\t\tif (hasCollision) {\n\t\t\t\titem.row += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Options for calculateLayout\n */\nexport interface CalculateLayoutOptions {\n\t/**\n\t * Whether to compact items upward after resolving collisions (default: true)\n\t */\n\tcompact?: boolean;\n}\n\n/**\n * Calculate new layout after moving an item\n * Returns a new array with updated positions\n */\nexport function calculateLayout(\n\titems: ItemRect[],\n\tmovedId: string,\n\ttargetCell: GridCell,\n\toptions: CalculateLayoutOptions = {},\n): ItemRect[] {\n\tconst { compact = true } = options;\n\n\t// Deep copy items\n\tconst result = items.map((item) => ({ ...item }));\n\n\tconst movedItem = result.find((it) => it.id === movedId);\n\tif (!movedItem) return result;\n\n\tmovedItem.column = targetCell.column;\n\tmovedItem.row = targetCell.row;\n\n\tpushDown(result, movedItem, movedId);\n\tif (compact) {\n\t\tcompactUp(result, movedId);\n\t}\n\n\treturn result;\n}\n\n/**\n * Options for CSS generation\n */\nexport interface LayoutToCSSOptions {\n\t/**\n\t * CSS selector prefix for items (default: '#')\n\t * Use '#' for id selectors, '.' for class selectors, or '[data-id=\"' for attribute selectors\n\t */\n\tselectorPrefix?: string;\n\t/**\n\t * CSS selector suffix for items (default: '')\n\t * Use ']' to close attribute selectors\n\t */\n\tselectorSuffix?: string;\n\t/**\n\t * Additional selector to exclude (e.g., ':not(.dragging)')\n\t */\n\texcludeSelector?: string;\n\t/**\n\t * Maximum column count for width clamping (optional)\n\t */\n\tmaxColumns?: number;\n}\n\n/**\n * Convert layout to CSS rules for injection into a <style> tag.\n * This enables the \"CSS-driven layout\" pattern where:\n * 1. Algorithm returns pure ItemRect[] data\n * 2. Caller converts to CSS string\n * 3. CSS injected into <style> tag\n * 4. View Transitions animate the change\n *\n * @param items - The layout items with positions\n * @param options - CSS generation options\n * @returns CSS rules string ready for injection\n *\n * @example\n * // Basic usage with id selectors\n * const css = layoutToCSS(items);\n * styleElement.textContent = css;\n *\n * @example\n * // During drag, exclude the dragging item\n * const css = layoutToCSS(items, { excludeSelector: ':not(.dragging)' });\n *\n * @example\n * // With data-id attribute selectors\n * const css = layoutToCSS(items, {\n *   selectorPrefix: '[data-id=\"',\n *   selectorSuffix: '\"]'\n * });\n */\nexport function layoutToCSS(\n\titems: ItemRect[],\n\toptions: LayoutToCSSOptions = {},\n): string {\n\tconst {\n\t\tselectorPrefix = '#',\n\t\tselectorSuffix = '',\n\t\texcludeSelector = '',\n\t\tmaxColumns,\n\t} = options;\n\n\tconst rules: string[] = [];\n\n\tfor (const item of items) {\n\t\tconst width = maxColumns ? Math.min(item.width, maxColumns) : item.width;\n\t\tconst selector = `${selectorPrefix}${item.id}${selectorSuffix}${excludeSelector}`;\n\t\tconst gridColumn = `${item.column} / span ${width}`;\n\t\tconst gridRow = `${item.row} / span ${item.height}`;\n\n\t\trules.push(`${selector} { grid-column: ${gridColumn}; grid-row: ${gridRow}; }`);\n\t}\n\n\treturn rules.join('\\n');\n}\n", "/**\n * Push-down layout algorithm for Gridiot\n *\n * This module provides both:\n * 1. Pure algorithm functions (re-exported from algorithm-push-core)\n * 2. DOM integration helper for attaching the algorithm to a grid element\n *\n * Usage (pure functions):\n *   import { calculateLayout, layoutToCSS } from 'gridiot/algorithm-push';\n *   const newLayout = calculateLayout(items, movedId, targetCell);\n *   styleElement.textContent = layoutToCSS(newLayout);\n *\n * Usage (DOM integration):\n *   import { init } from 'gridiot';\n *   import { attachPushAlgorithm } from 'gridiot/algorithm-push';\n *\n *   const grid = init(element);\n *   const detach = attachPushAlgorithm(grid.element);\n */\n\nimport { registerPlugin } from '../engine';\n\n// Re-export pure algorithm functions\nexport {\n\tcalculateLayout,\n\tcompactUp,\n\tfindOverlaps,\n\titemsOverlap,\n\tlayoutToCSS,\n\tpushDown,\n\ttype CalculateLayoutOptions,\n\ttype GridCell,\n\ttype ItemRect,\n\ttype LayoutToCSSOptions,\n} from './algorithm-push-core';\n\nimport type {\n\tAlgorithmPushPluginOptions,\n\tDragCancelDetail,\n\tDragEndDetail,\n\tDragMoveDetail,\n\tDragStartDetail,\n\tGridCell,\n\tGridiotCore,\n\tItemPosition,\n\tLayoutState,\n\tResizeCancelDetail,\n\tResizeEndDetail,\n\tResizeMoveDetail,\n\tResizeStartDetail,\n\tResponsiveLayoutModel,\n} from '../types';\n\nimport type { CameraState } from './camera';\n\nimport {\n\tcalculateLayout,\n\tlayoutToCSS,\n\ttype ItemRect,\n} from './algorithm-push-core';\n\nconst DEBUG = false;\nfunction log(...args: unknown[]) {\n\tif (DEBUG) console.log('[algorithm-push]', ...args);\n}\n\n/**\n * Read item positions from DOM elements\n */\nexport function readItemsFromDOM(container: HTMLElement): ItemRect[] {\n\tconst elements = container.querySelectorAll('[data-gridiot-item]');\n\treturn Array.from(elements).map((el) => {\n\t\tconst element = el as HTMLElement;\n\t\tconst style = getComputedStyle(element);\n\t\tconst column = parseInt(style.gridColumnStart, 10) || 1;\n\t\tconst row = parseInt(style.gridRowStart, 10) || 1;\n\t\tconst width =\n\t\t\tparseInt(element.getAttribute('data-gridiot-colspan') || '1', 10) || 1;\n\t\tconst height =\n\t\t\tparseInt(element.getAttribute('data-gridiot-rowspan') || '1', 10) || 1;\n\t\tconst id = element.dataset.id || element.dataset.gridiotItem || '';\n\n\t\treturn { id, column, row, width, height };\n\t});\n}\n\n/**\n * Options for attachPushAlgorithm\n */\nexport interface AttachPushAlgorithmOptions {\n\t/**\n\t * Style element to inject layout CSS into.\n\t * If not provided, positions are applied directly to element.style.\n\t *\n\t * When using with a layoutModel, this becomes the \"preview\" style element\n\t * used during drag. The responsive plugin manages the main layout CSS.\n\t */\n\tstyleElement?: HTMLStyleElement;\n\t/**\n\t * CSS selector options for layoutToCSS\n\t */\n\tselectorPrefix?: string;\n\tselectorSuffix?: string;\n\t/**\n\t * Whether to compact items upward after resolving collisions (default: true)\n\t * When false, items only get pushed down but won't float back up to fill gaps.\n\t */\n\tcompaction?: boolean;\n\t/**\n\t * GridiotCore instance for provider registration.\n\t * If provided, registers a 'layout' provider that exposes current layout state.\n\t */\n\tcore?: GridiotCore;\n\t/**\n\t * Responsive layout model for multi-breakpoint support.\n\t * When provided, final positions are saved to the layout model on drag-end,\n\t * which triggers CSS regeneration via the responsive plugin.\n\t */\n\tlayoutModel?: ResponsiveLayoutModel;\n}\n\n/**\n * Attach push-down algorithm to a grid element.\n *\n * This creates event listeners for gridiot drag events and updates\n * the layout when items are moved. Layout changes are animated\n * via View Transitions.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach the algorithm\n */\nexport function attachPushAlgorithm(\n\tgridElement: HTMLElement,\n\toptions: AttachPushAlgorithmOptions = {},\n): () => void {\n\tconst { styleElement, selectorPrefix = '#', selectorSuffix = '', compaction = true, core, layoutModel } = options;\n\n\t/**\n\t * Get current column count from computed grid style\n\t */\n\tfunction getCurrentColumnCount(): number {\n\t\tconst style = getComputedStyle(gridElement);\n\t\tconst columns = style.gridTemplateColumns.split(' ').filter(Boolean);\n\t\treturn Math.max(1, columns.length);\n\t}\n\n\tlet originalPositions: Map<string, { column: number; row: number }> | null =\n\t\tnull;\n\tlet draggedItemId: string | null = null;\n\tlet draggedElement: HTMLElement | null = null;\n\tlet layoutVersion = 0; // Prevent stale async view transitions from overwriting newer layouts\n\tlet currentLayout: ItemRect[] | null = null;\n\n\t// Register layout provider if core is provided\n\tif (core) {\n\t\tcore.providers.register<LayoutState | null>('layout', () => {\n\t\t\tif (!currentLayout) return null;\n\t\t\tconst gridStyle = getComputedStyle(gridElement);\n\t\t\tconst columns = gridStyle.gridTemplateColumns.split(' ').length;\n\t\t\treturn {\n\t\t\t\titems: currentLayout.map((item) => ({\n\t\t\t\t\tid: item.id,\n\t\t\t\t\tcolumn: item.column,\n\t\t\t\t\trow: item.row,\n\t\t\t\t\tcolspan: item.width,\n\t\t\t\t\trowspan: item.height,\n\t\t\t\t})),\n\t\t\t\tcolumns,\n\t\t\t};\n\t\t});\n\t}\n\n\tfunction getItemId(element: HTMLElement): string {\n\t\treturn element.dataset.id || element.dataset.gridiotItem || '';\n\t}\n\n\tfunction setItemCell(item: HTMLElement, cell: GridCell): void {\n\t\tconst colspan =\n\t\t\tparseInt(item.getAttribute('data-gridiot-colspan') || '1', 10) || 1;\n\t\tconst rowspan =\n\t\t\tparseInt(item.getAttribute('data-gridiot-rowspan') || '1', 10) || 1;\n\t\tconst colValue = `${cell.column} / span ${colspan}`;\n\t\tconst rowValue = `${cell.row} / span ${rowspan}`;\n\t\tlog('setItemCell', { id: getItemId(item), colValue, rowValue });\n\t\titem.style.gridColumn = colValue;\n\t\titem.style.gridRow = rowValue;\n\t}\n\n\tfunction applyLayout(\n\t\tlayout: ItemRect[],\n\t\texcludeId: string | null,\n\t\tuseViewTransition: boolean,\n\t): void {\n\t\t// Increment version to invalidate any pending async transitions\n\t\tconst thisVersion = ++layoutVersion;\n\n\t\t// Update current layout for provider access\n\t\tcurrentLayout = layout;\n\n\t\tconst applyChanges = () => {\n\t\t\t// Skip if a newer layout has been applied (stale async view transition)\n\t\t\tif (thisVersion !== layoutVersion) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (styleElement) {\n\t\t\t\t// CSS injection mode - preferred\n\t\t\t\t// Filter out the excluded item (being dragged) from CSS generation\n\t\t\t\tconst itemsToStyle = excludeId\n\t\t\t\t\t? layout.filter((item) => item.id !== excludeId)\n\t\t\t\t\t: layout;\n\t\t\t\tconst css = layoutToCSS(itemsToStyle, {\n\t\t\t\t\tselectorPrefix,\n\t\t\t\t\tselectorSuffix,\n\t\t\t\t});\n\t\t\t\tstyleElement.textContent = css;\n\n\t\t\t\t// Clear inline grid styles so CSS rules take effect\n\t\t\t\t// (inline styles have higher specificity than stylesheet rules)\n\t\t\t\tconst elements = gridElement.querySelectorAll('[data-gridiot-item]');\n\t\t\t\tfor (const el of elements) {\n\t\t\t\t\tconst element = el as HTMLElement;\n\t\t\t\t\tconst id = getItemId(element);\n\t\t\t\t\tif (id !== excludeId) {\n\t\t\t\t\t\telement.style.gridColumn = '';\n\t\t\t\t\t\telement.style.gridRow = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Direct style mutation mode - fallback\n\t\t\t\tconst elements = gridElement.querySelectorAll('[data-gridiot-item]');\n\t\t\t\tfor (const el of elements) {\n\t\t\t\t\tconst element = el as HTMLElement;\n\t\t\t\t\tconst id = getItemId(element);\n\t\t\t\t\tif (id === excludeId) continue;\n\n\t\t\t\t\tconst item = layout.find((it) => it.id === id);\n\t\t\t\t\tif (item) {\n\t\t\t\t\t\tsetItemCell(element, { column: item.column, row: item.row });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif (useViewTransition && 'startViewTransition' in document) {\n\t\t\tlog('starting view transition, excludeId:', excludeId);\n\t\t\t// Only suppress animation for item being pointer-dragged (not keyboard nudges)\n\t\t\t// During pointer drag, excludeId is set; during keyboard nudge or final drop, it's null\n\t\t\tif (draggedElement && excludeId) {\n\t\t\t\tdraggedElement.style.viewTransitionName = 'dragging';\n\t\t\t}\n\t\t\t(document as any).startViewTransition(applyChanges);\n\t\t} else {\n\t\t\tlog('applying without view transition');\n\t\t\tapplyChanges();\n\t\t}\n\t}\n\n\tconst onDragStart = (e: Event) => {\n\t\tconst detail = (e as CustomEvent<DragStartDetail>).detail;\n\t\tdraggedElement = detail.item;\n\t\tdraggedItemId = getItemId(detail.item);\n\n\t\t// Store original positions to reset from during drag\n\t\tconst items = readItemsFromDOM(gridElement);\n\t\toriginalPositions = new Map();\n\t\tfor (const item of items) {\n\t\t\toriginalPositions.set(item.id, { column: item.column, row: item.row });\n\t\t}\n\n\t\t// In CSS injection mode, clear inline styles so CSS rules take effect\n\t\tif (styleElement) {\n\t\t\tconst elements = gridElement.querySelectorAll('[data-gridiot-item]');\n\t\t\tfor (const el of elements) {\n\t\t\t\tconst element = el as HTMLElement;\n\t\t\t\tif (element !== draggedElement) {\n\t\t\t\t\telement.style.gridColumn = '';\n\t\t\t\t\telement.style.gridRow = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Generate initial CSS for current positions\n\t\t\tconst css = layoutToCSS(items, { selectorPrefix, selectorSuffix });\n\t\t\tstyleElement.textContent = css;\n\t\t}\n\n\t\tlog('drag-start', {\n\t\t\titem: draggedItemId,\n\t\t\tpositions: Array.from(originalPositions.entries()),\n\t\t});\n\t};\n\n\t// Track pending cell during camera scroll for deferred update\n\tlet pendingCell: { column: number; row: number } | null = null;\n\n\tconst onDragMove = (e: Event) => {\n\t\tif (!draggedItemId || !originalPositions) return;\n\n\t\tconst detail = (e as CustomEvent<DragMoveDetail>).detail;\n\n\t\t// Skip layout updates while camera is auto-scrolling, but track pending cell\n\t\tif (core) {\n\t\t\tconst cameraState = core.providers.get<CameraState>('camera');\n\t\t\tif (cameraState?.isScrolling) {\n\t\t\t\tpendingCell = detail.cell;\n\t\t\t\tlog('drag-move deferred (camera scrolling)', pendingCell);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Clear pendingCell since we're processing normally now\n\t\tpendingCell = null;\n\n\t\t// Build items array from original positions\n\t\tconst items: ItemRect[] = readItemsFromDOM(gridElement).map((item) => {\n\t\t\tconst original = originalPositions!.get(item.id);\n\t\t\tif (original && item.id !== draggedItemId) {\n\t\t\t\treturn { ...item, column: original.column, row: original.row };\n\t\t\t}\n\t\t\treturn item;\n\t\t});\n\n\t\tlog('drag-move', { targetCell: detail.cell });\n\t\tconst newLayout = calculateLayout(items, draggedItemId, detail.cell, { compact: compaction });\n\t\tlog(\n\t\t\t'calculated layout',\n\t\t\tnewLayout.map((it) => ({ id: it.id, col: it.column, row: it.row })),\n\t\t);\n\t\tapplyLayout(newLayout, draggedItemId, true);\n\t};\n\n\tconst onDragEnd = (e: Event) => {\n\t\tif (!draggedItemId || !originalPositions) return;\n\t\tconst detail = (e as CustomEvent<DragEndDetail>).detail;\n\n\t\tlog('drag-end', { finalCell: detail.cell });\n\n\t\t// Build items array from original positions\n\t\tconst items: ItemRect[] = readItemsFromDOM(gridElement).map((item) => {\n\t\t\tconst original = originalPositions!.get(item.id);\n\t\t\tif (original && item.id !== draggedItemId) {\n\t\t\t\treturn { ...item, column: original.column, row: original.row };\n\t\t\t}\n\t\t\treturn item;\n\t\t});\n\n\t\tconst finalLayout = calculateLayout(items, draggedItemId, detail.cell, { compact: compaction });\n\t\tlog(\n\t\t\t'final layout',\n\t\t\tfinalLayout.map((it) => ({ id: it.id, col: it.column, row: it.row })),\n\t\t);\n\n\t\t// Check if this is a pointer drag (item is in fixed position) or keyboard nudge\n\t\tconst isPointerDrag = draggedElement?.style.position === 'fixed';\n\t\tlog('drag-end isPointerDrag:', isPointerDrag, 'position:', draggedElement?.style.position);\n\n\t\t// Clear the 'dragging' viewTransitionName only if it was set (during pointer drag)\n\t\t// Don't clear for keyboard nudges - they need the CSS view-transition-name to animate\n\t\tif (draggedElement && draggedElement.style.viewTransitionName === 'dragging') {\n\t\t\tdraggedElement.style.viewTransitionName = '';\n\t\t}\n\n\t\t// For pointer drags, apply synchronously (pointer's FLIP animates the dropped item)\n\t\t// For keyboard nudges, use view transitions to animate\n\t\tconst useViewTransition = !isPointerDrag;\n\t\tlog('drag-end useViewTransition:', useViewTransition);\n\t\tapplyLayout(finalLayout, null, useViewTransition);\n\n\t\t// Save to layout model if provided (triggers CSS regeneration via responsive plugin)\n\t\tif (layoutModel) {\n\t\t\tconst columnCount = getCurrentColumnCount();\n\t\t\tconst positions = new Map<string, ItemPosition>();\n\t\t\tfor (const item of finalLayout) {\n\t\t\t\tpositions.set(item.id, { column: item.column, row: item.row });\n\t\t\t}\n\t\t\tlayoutModel.saveLayout(columnCount, positions);\n\t\t\tlog('saved layout to model for', columnCount, 'columns');\n\n\t\t\t// Clear preview styles so container query CSS takes over\n\t\t\tif (styleElement) {\n\t\t\t\tstyleElement.textContent = '';\n\t\t\t\tlog('cleared preview styles');\n\t\t\t}\n\t\t}\n\n\t\tdraggedItemId = null;\n\t\tdraggedElement = null;\n\t\toriginalPositions = null;\n\t\tpendingCell = null;\n\t};\n\n\tconst onDragCancel = () => {\n\t\tif (!draggedItemId || !originalPositions) return;\n\n\t\t// Clear the 'dragging' viewTransitionName only if it was set (during pointer drag)\n\t\tif (draggedElement && draggedElement.style.viewTransitionName === 'dragging') {\n\t\t\tdraggedElement.style.viewTransitionName = '';\n\t\t}\n\n\t\t// Restore original positions\n\t\tconst restoreLayout: ItemRect[] = readItemsFromDOM(gridElement).map(\n\t\t\t(item) => {\n\t\t\t\tconst original = originalPositions!.get(item.id);\n\t\t\t\tif (original) {\n\t\t\t\t\treturn { ...item, column: original.column, row: original.row };\n\t\t\t\t}\n\t\t\t\treturn item;\n\t\t\t},\n\t\t);\n\n\t\tconst restore = () => {\n\t\t\tapplyLayout(restoreLayout, null, false);\n\t\t};\n\n\t\tif ('startViewTransition' in document) {\n\t\t\t(document as any).startViewTransition(restore);\n\t\t} else {\n\t\t\trestore();\n\t\t}\n\n\t\tdraggedItemId = null;\n\t\tdraggedElement = null;\n\t\toriginalPositions = null;\n\t\tpendingCell = null;\n\t};\n\n\t// Recalculate layout when camera settles after auto-scrolling\n\tconst onCameraSettled = () => {\n\t\tif (!draggedItemId || !originalPositions) return;\n\n\t\t// Use pending cell if available, otherwise get from element position\n\t\tlet cell = pendingCell;\n\t\tif (!cell && draggedElement) {\n\t\t\tconst rect = draggedElement.getBoundingClientRect();\n\t\t\tconst centerX = rect.left + rect.width / 2;\n\t\t\tconst centerY = rect.top + rect.height / 2;\n\t\t\tcell = core?.getCellFromPoint(centerX, centerY) ?? null;\n\t\t}\n\n\t\tif (!cell) {\n\t\t\tlog('camera-settled, no cell to update to');\n\t\t\treturn;\n\t\t}\n\n\t\tlog('camera-settled, updating to cell', cell);\n\t\tpendingCell = null;\n\n\t\t// Rebuild items from original positions\n\t\tconst items: ItemRect[] = readItemsFromDOM(gridElement).map((item) => {\n\t\t\tconst original = originalPositions!.get(item.id);\n\t\t\tif (original && item.id !== draggedItemId) {\n\t\t\t\treturn { ...item, column: original.column, row: original.row };\n\t\t\t}\n\t\t\treturn item;\n\t\t});\n\n\t\tconst newLayout = calculateLayout(items, draggedItemId!, cell, { compact: compaction });\n\t\tapplyLayout(newLayout, draggedItemId, true);\n\t};\n\n\t// =========================================================================\n\t// Resize event handlers\n\t// =========================================================================\n\n\tlet resizedItemId: string | null = null;\n\tlet resizedElement: HTMLElement | null = null;\n\tlet resizeOriginalPositions: Map<string, { column: number; row: number; width: number; height: number }> | null = null;\n\tlet lastResizeLayout: { cell: GridCell; colspan: number; rowspan: number } | null = null;\n\n\tconst onResizeStart = (e: Event) => {\n\t\tconst detail = (e as CustomEvent<ResizeStartDetail>).detail;\n\t\tresizedElement = detail.item;\n\t\tresizedItemId = getItemId(detail.item);\n\n\t\t// Store original positions AND sizes to reset from during resize\n\t\tconst items = readItemsFromDOM(gridElement);\n\t\tresizeOriginalPositions = new Map();\n\t\tfor (const item of items) {\n\t\t\tresizeOriginalPositions.set(item.id, {\n\t\t\t\tcolumn: item.column,\n\t\t\t\trow: item.row,\n\t\t\t\twidth: item.width,\n\t\t\t\theight: item.height,\n\t\t\t});\n\t\t}\n\n\t\t// In CSS injection mode, set up preview styles for animations during resize\n\t\tif (styleElement) {\n\t\t\tconst elements = gridElement.querySelectorAll('[data-gridiot-item]');\n\t\t\tfor (const el of elements) {\n\t\t\t\tconst element = el as HTMLElement;\n\t\t\t\tif (element !== resizedElement) {\n\t\t\t\t\telement.style.gridColumn = '';\n\t\t\t\t\telement.style.gridRow = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Generate initial CSS for current positions\n\t\t\tconst css = layoutToCSS(items, { selectorPrefix, selectorSuffix });\n\t\t\tstyleElement.textContent = css;\n\t\t}\n\n\t\t// Clear last resize layout to ensure first resize-move triggers an update\n\t\tlastResizeLayout = null;\n\n\t\tlog('resize-start', {\n\t\t\titem: resizedItemId,\n\t\t\tcell: detail.cell,\n\t\t\tsize: { colspan: detail.colspan, rowspan: detail.rowspan },\n\t\t});\n\t};\n\n\tconst onResizeMove = (e: Event) => {\n\t\tif (!resizedItemId || !resizeOriginalPositions) return;\n\n\t\tconst detail = (e as CustomEvent<ResizeMoveDetail>).detail;\n\n\t\t// Only update layout when projected size/position actually changes\n\t\t// This prevents rapid view transitions from cancelling each other\n\t\tif (lastResizeLayout &&\n\t\t\tlastResizeLayout.cell.column === detail.cell.column &&\n\t\t\tlastResizeLayout.cell.row === detail.cell.row &&\n\t\t\tlastResizeLayout.colspan === detail.colspan &&\n\t\t\tlastResizeLayout.rowspan === detail.rowspan) {\n\t\t\treturn;\n\t\t}\n\t\tlastResizeLayout = {\n\t\t\tcell: { ...detail.cell },\n\t\t\tcolspan: detail.colspan,\n\t\t\trowspan: detail.rowspan,\n\t\t};\n\n\t\t// Build items array from original positions, but with updated size for resized item\n\t\tconst items: ItemRect[] = [];\n\t\tfor (const [id, original] of resizeOriginalPositions) {\n\t\t\tif (id === resizedItemId) {\n\t\t\t\t// Use the projected position and size from resize event\n\t\t\t\titems.push({\n\t\t\t\t\tid,\n\t\t\t\t\tcolumn: detail.cell.column,\n\t\t\t\t\trow: detail.cell.row,\n\t\t\t\t\twidth: detail.colspan,\n\t\t\t\t\theight: detail.rowspan,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Use original position and size\n\t\t\t\titems.push({\n\t\t\t\t\tid,\n\t\t\t\t\tcolumn: original.column,\n\t\t\t\t\trow: original.row,\n\t\t\t\t\twidth: original.width,\n\t\t\t\t\theight: original.height,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tlog('resize-move', { targetCell: detail.cell, size: { colspan: detail.colspan, rowspan: detail.rowspan } });\n\t\tconst newLayout = calculateLayout(items, resizedItemId, detail.cell, { compact: compaction });\n\t\tlog(\n\t\t\t'calculated resize layout',\n\t\t\tnewLayout.map((it) => ({ id: it.id, col: it.column, row: it.row, w: it.width, h: it.height })),\n\t\t);\n\n\t\t// Apply layout WITHOUT view transitions during resize-move to avoid visual glitches\n\t\t// View transitions during rapid updates can cause items to appear to shrink/jitter\n\t\tapplyLayout(newLayout, resizedItemId, false);\n\t};\n\n\tconst onResizeEnd = (e: Event) => {\n\t\tif (!resizedItemId || !resizeOriginalPositions) return;\n\t\tconst detail = (e as CustomEvent<ResizeEndDetail>).detail;\n\n\t\tlog('resize-end', { finalCell: detail.cell, size: { colspan: detail.colspan, rowspan: detail.rowspan } });\n\n\t\t// Build final layout from original positions with final resize size\n\t\tconst items: ItemRect[] = [];\n\t\tfor (const [id, original] of resizeOriginalPositions) {\n\t\t\tif (id === resizedItemId) {\n\t\t\t\titems.push({\n\t\t\t\t\tid,\n\t\t\t\t\tcolumn: detail.cell.column,\n\t\t\t\t\trow: detail.cell.row,\n\t\t\t\t\twidth: detail.colspan,\n\t\t\t\t\theight: detail.rowspan,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\titems.push({\n\t\t\t\t\tid,\n\t\t\t\t\tcolumn: original.column,\n\t\t\t\t\trow: original.row,\n\t\t\t\t\twidth: original.width,\n\t\t\t\t\theight: original.height,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconst finalLayout = calculateLayout(items, resizedItemId, detail.cell, { compact: compaction });\n\t\tlog(\n\t\t\t'final resize layout',\n\t\t\tfinalLayout.map((it) => ({ id: it.id, col: it.column, row: it.row, w: it.width, h: it.height })),\n\t\t);\n\n\t\t// Items are already at their positions from resize-move animations.\n\t\t// Apply final layout without view transition (same as pointer drag-end)\n\t\tapplyLayout(finalLayout, null, false);\n\n\t\t// Save to layout model if provided\n\t\tif (layoutModel) {\n\t\t\tconst columnCount = getCurrentColumnCount();\n\t\t\tconst positions = new Map<string, ItemPosition>();\n\t\t\tfor (const item of finalLayout) {\n\t\t\t\tpositions.set(item.id, { column: item.column, row: item.row });\n\t\t\t}\n\t\t\tlayoutModel.updateItemSize(resizedItemId, { width: detail.colspan, height: detail.rowspan });\n\t\t\tlayoutModel.saveLayout(columnCount, positions);\n\t\t\tlog('saved resize layout to model for', columnCount, 'columns');\n\n\t\t\t// Clear preview styles so container query CSS takes over\n\t\t\tif (styleElement) {\n\t\t\t\tstyleElement.textContent = '';\n\t\t\t\tlog('cleared preview styles');\n\t\t\t}\n\t\t}\n\n\t\tresizedItemId = null;\n\t\tresizedElement = null;\n\t\tresizeOriginalPositions = null;\n\t\tlastResizeLayout = null;\n\t};\n\n\tconst onResizeCancel = () => {\n\t\tif (!resizedItemId || !resizeOriginalPositions) return;\n\n\t\t// Restore original positions\n\t\tconst restoreLayout: ItemRect[] = readItemsFromDOM(gridElement).map(\n\t\t\t(item) => {\n\t\t\t\tconst original = resizeOriginalPositions!.get(item.id);\n\t\t\t\tif (original) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...item,\n\t\t\t\t\t\tcolumn: original.column,\n\t\t\t\t\t\trow: original.row,\n\t\t\t\t\t\twidth: original.width,\n\t\t\t\t\t\theight: original.height,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn item;\n\t\t\t},\n\t\t);\n\n\t\tconst restore = () => {\n\t\t\tapplyLayout(restoreLayout, null, false);\n\t\t};\n\n\t\tif ('startViewTransition' in document) {\n\t\t\t(document as any).startViewTransition(restore);\n\t\t} else {\n\t\t\trestore();\n\t\t}\n\n\t\tresizedItemId = null;\n\t\tresizedElement = null;\n\t\tresizeOriginalPositions = null;\n\t\tlastResizeLayout = null;\n\t};\n\n\tgridElement.addEventListener('gridiot:drag-start', onDragStart);\n\tgridElement.addEventListener('gridiot:drag-move', onDragMove);\n\tgridElement.addEventListener('gridiot:drag-end', onDragEnd);\n\tgridElement.addEventListener('gridiot:drag-cancel', onDragCancel);\n\tgridElement.addEventListener('gridiot:camera-settled', onCameraSettled);\n\tgridElement.addEventListener('gridiot:resize-start', onResizeStart);\n\tgridElement.addEventListener('gridiot:resize-move', onResizeMove);\n\tgridElement.addEventListener('gridiot:resize-end', onResizeEnd);\n\tgridElement.addEventListener('gridiot:resize-cancel', onResizeCancel);\n\n\treturn () => {\n\t\tgridElement.removeEventListener('gridiot:drag-start', onDragStart);\n\t\tgridElement.removeEventListener('gridiot:drag-move', onDragMove);\n\t\tgridElement.removeEventListener('gridiot:drag-end', onDragEnd);\n\t\tgridElement.removeEventListener('gridiot:drag-cancel', onDragCancel);\n\t\tgridElement.removeEventListener('gridiot:camera-settled', onCameraSettled);\n\t\tgridElement.removeEventListener('gridiot:resize-start', onResizeStart);\n\t\tgridElement.removeEventListener('gridiot:resize-move', onResizeMove);\n\t\tgridElement.removeEventListener('gridiot:resize-end', onResizeEnd);\n\t\tgridElement.removeEventListener('gridiot:resize-cancel', onResizeCancel);\n\t};\n}\n\n// Register as a plugin for auto-initialization via init()\nregisterPlugin({\n\tname: 'algorithm-push',\n\tinit(\n\t\tcore,\n\t\toptions?: AlgorithmPushPluginOptions & {\n\t\t\tcore?: GridiotCore;\n\t\t\tlayoutModel?: ResponsiveLayoutModel;\n\t\t\tstyleElement?: HTMLStyleElement;\n\t\t},\n\t) {\n\t\treturn attachPushAlgorithm(core.element, {\n\t\t\t...options,\n\t\t\tcore: options?.core ?? core,\n\t\t});\n\t},\n});\n"],
  "mappings": "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",
  "names": []
}
