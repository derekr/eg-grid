{
  "version": 3,
  "sources": ["../../engine.ts", "../../utils/flip.ts", "../../plugins/pointer.ts"],
  "sourcesContent": ["import type { GridCell, GridiotCore, InitOptions, Plugin, PluginOptions, ProviderRegistry } from './types';\n\n// Global plugin registry\nconst plugins = new Map<string, Plugin>();\n\nexport function registerPlugin(plugin: Plugin): void {\n\tplugins.set(plugin.name, plugin);\n}\n\nexport function getPlugin(name: string): Plugin | undefined {\n\treturn plugins.get(name);\n}\n\n/**\n * Initialize Gridiot on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options including layoutModel, styleElement, and plugin options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): GridiotCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t\tplugins: pluginOptions = {},\n\t\tdisablePlugins = [],\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\tlet selectedItem: HTMLElement | null = null;\n\n\t// Provider registry for inter-plugin communication\n\tconst providerMap = new Map<string, () => unknown>();\n\tconst providers: ProviderRegistry = {\n\t\tregister<T>(capability: string, provider: () => T): void {\n\t\t\tif (providerMap.has(capability)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Gridiot: Provider for \"${capability}\" already registered, overwriting`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tproviderMap.set(capability, provider);\n\t\t},\n\n\t\tget<T>(capability: string): T | undefined {\n\t\t\tconst provider = providerMap.get(capability);\n\t\t\treturn provider ? (provider() as T) : undefined;\n\t\t},\n\n\t\thas(capability: string): boolean {\n\t\t\treturn providerMap.has(capability);\n\t\t},\n\t};\n\n\tconst core: GridiotCore = {\n\t\telement,\n\t\tproviders,\n\n\t\t// Selection state\n\t\tget selectedItem() {\n\t\t\treturn selectedItem;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedItem) return;\n\n\t\t\tconst previousItem = selectedItem;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-gridiot-selected');\n\t\t\t}\n\n\t\t\t// Set new selection\n\t\t\tselectedItem = item;\n\n\t\t\tif (item) {\n\t\t\t\titem.setAttribute('data-gridiot-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else if (previousItem) {\n\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`gridiot:${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tobserver.disconnect();\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Observe position changes and animate with View Transitions\n\tconst observer = new MutationObserver((mutations) => {\n\t\t// Collect items that changed position\n\t\tconst changedItems = new Set<HTMLElement>();\n\n\t\tfor (const mutation of mutations) {\n\t\t\tif (\n\t\t\t\tmutation.type === 'attributes' &&\n\t\t\t\tmutation.target instanceof HTMLElement\n\t\t\t) {\n\t\t\t\tconst item = mutation.target.closest(\n\t\t\t\t\t'[data-gridiot-item]',\n\t\t\t\t) as HTMLElement | null;\n\t\t\t\tif (item && element.contains(item)) {\n\t\t\t\t\tchangedItems.add(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Animate changes with View Transitions if available\n\t\tif (changedItems.size > 0 && 'startViewTransition' in document) {\n\t\t\t// Items already moved - View Transitions will handle animation\n\t\t\t// The browser captures before/after states automatically\n\t\t}\n\t});\n\n\tobserver.observe(element, {\n\t\tsubtree: true,\n\t\tattributes: true,\n\t\tattributeFilter: ['style', 'class'],\n\t});\n\n\t// Initialize all registered plugins with options\n\tfor (const plugin of plugins.values()) {\n\t\t// Skip disabled plugins\n\t\tif (disablePlugins.includes(plugin.name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Build options for this plugin\n\t\tconst pluginSpecificOptions = pluginOptions[plugin.name as keyof PluginOptions] ?? {};\n\t\tconst opts = {\n\t\t\t...pluginSpecificOptions,\n\t\t\t// Pass shared resources to all plugins that might need them\n\t\t\tlayoutModel,\n\t\t\tstyleElement,\n\t\t\tcore,\n\t\t};\n\n\t\tconst cleanup = plugin.init(core, opts);\n\t\tif (cleanup) {\n\t\t\tcleanups.push(cleanup);\n\t\t}\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Set an item's grid position\n */\nexport function setItemCell(item: HTMLElement, cell: GridCell): void {\n\titem.style.gridColumn = String(cell.column);\n\titem.style.gridRow = String(cell.row);\n}\n\n/**\n * Get grid info for a grid element\n */\nexport function getGridInfo(element: HTMLElement) {\n\tconst rect = element.getBoundingClientRect();\n\tconst style = getComputedStyle(element);\n\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\tconst columnGap = parseFloat(style.columnGap) || 0;\n\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\treturn {\n\t\trect,\n\t\tcolumns,\n\t\trows,\n\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\tcellWidth: columns[0] || 0,\n\t\tcellHeight: rows[0] || 0,\n\t};\n}\n", "/**\n * FLIP Animation Utility\n *\n * Provides shared FLIP (First, Last, Invert, Play) animation utilities\n * used by pointer and resize plugins for smooth position/scale transitions.\n */\n\nexport interface FLIPOptions {\n\t/** Animation duration in milliseconds. @default 200 */\n\tduration?: number;\n\t/** CSS easing function. @default 'cubic-bezier(0.2, 0, 0, 1)' */\n\teasing?: string;\n\t/** Include scale transform (for resize). @default false */\n\tincludeScale?: boolean;\n\t/** Transform origin for scale animations. @default undefined (uses center) */\n\ttransformOrigin?: string;\n\t/** Callback when animation starts */\n\tonStart?: () => void;\n\t/** Callback when animation finishes */\n\tonFinish?: () => void;\n}\n\n/**\n * Animate an element from its previous position/size to its new position/size using FLIP.\n *\n * @param element - The element to animate\n * @param firstRect - The element's bounding rect before the DOM change (the \"First\" in FLIP)\n * @param options - Animation options\n * @returns The Animation object, or null if no animation was needed\n *\n * @example\n * ```ts\n * // Capture position before DOM change\n * const firstRect = element.getBoundingClientRect();\n *\n * // Make DOM changes (e.g., update grid position)\n * element.style.gridColumn = '2 / span 2';\n *\n * // Animate from old position to new\n * requestAnimationFrame(() => {\n *   animateFLIP(element, firstRect);\n * });\n * ```\n */\nexport function animateFLIP(\n\telement: HTMLElement,\n\tfirstRect: DOMRect,\n\toptions: FLIPOptions = {},\n): Animation | null {\n\tconst {\n\t\tduration = 200,\n\t\teasing = 'cubic-bezier(0.2, 0, 0, 1)',\n\t\tincludeScale = false,\n\t\ttransformOrigin,\n\t\tonStart,\n\t\tonFinish,\n\t} = options;\n\n\t// Measure final position (the \"Last\" in FLIP)\n\tconst lastRect = element.getBoundingClientRect();\n\n\t// Calculate position deltas (the \"Invert\" in FLIP)\n\tconst deltaX = firstRect.left - lastRect.left;\n\tconst deltaY = firstRect.top - lastRect.top;\n\n\tconst needsTranslate = Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1;\n\n\t// Calculate scale deltas (for resize)\n\tlet scaleX = 1;\n\tlet scaleY = 1;\n\tlet needsScale = false;\n\n\tif (includeScale) {\n\t\tscaleX = firstRect.width / lastRect.width;\n\t\tscaleY = firstRect.height / lastRect.height;\n\t\tneedsScale = Math.abs(scaleX - 1) > 0.01 || Math.abs(scaleY - 1) > 0.01;\n\t}\n\n\t// Skip animation if no significant change\n\tif (!needsTranslate && !needsScale) {\n\t\tonFinish?.();\n\t\treturn null;\n\t}\n\n\tonStart?.();\n\n\t// Build keyframes based on what's needed\n\tconst keyframes: Keyframe[] = includeScale\n\t\t? [\n\t\t\t\t{\n\t\t\t\t\ttransform: `translate(${deltaX}px, ${deltaY}px) scale(${scaleX}, ${scaleY})`,\n\t\t\t\t\ttransformOrigin: transformOrigin ?? 'top left',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttransform: 'translate(0, 0) scale(1, 1)',\n\t\t\t\t\ttransformOrigin: transformOrigin ?? 'top left',\n\t\t\t\t},\n\t\t\t]\n\t\t: [\n\t\t\t\t{ transform: `translate(${deltaX}px, ${deltaY}px)` },\n\t\t\t\t{ transform: 'translate(0, 0)' },\n\t\t\t];\n\n\t// Play the animation\n\tconst animation = element.animate(keyframes, {\n\t\tduration,\n\t\teasing,\n\t});\n\n\tanimation.onfinish = () => onFinish?.();\n\n\treturn animation;\n}\n\n/**\n * Get the item's view transition name from various sources.\n * Checks --item-id CSS property, id attribute, and data-id attribute.\n */\nexport function getItemViewTransitionName(element: HTMLElement): string | null {\n\treturn (\n\t\telement.style.getPropertyValue('--item-id') ||\n\t\telement.id ||\n\t\telement.dataset.id ||\n\t\tnull\n\t);\n}\n\n/**\n * Execute a FLIP animation while temporarily excluding the element from View Transitions.\n *\n * This is useful when you want to use FLIP for an animation instead of View Transitions,\n * to prevent the two from conflicting.\n *\n * @param element - The element to animate\n * @param fn - Function that performs the animation (receives firstRect)\n * @returns The Animation object, or null if no animation was needed\n *\n * @example\n * ```ts\n * const firstRect = element.getBoundingClientRect();\n *\n * // Make DOM changes\n * element.style.gridColumn = '2 / span 2';\n *\n * // Animate with View Transition exclusion\n * requestAnimationFrame(() => {\n *   withViewTransitionExclusion(element, () =>\n *     animateFLIP(element, firstRect)\n *   );\n * });\n * ```\n */\nexport function withViewTransitionExclusion(\n\telement: HTMLElement,\n\tfn: () => Animation | null,\n): Animation | null {\n\t// Exclude from View Transitions during FLIP\n\telement.style.viewTransitionName = 'none';\n\n\tconst animation = fn();\n\n\tconst restoreViewTransitionName = () => {\n\t\tconst itemId = getItemViewTransitionName(element);\n\t\tif (itemId) {\n\t\t\telement.style.viewTransitionName = itemId;\n\t\t}\n\t};\n\n\tif (animation) {\n\t\tanimation.addEventListener('finish', restoreViewTransitionName, { once: true });\n\t} else {\n\t\t// No animation needed, restore immediately\n\t\trestoreViewTransitionName();\n\t}\n\n\treturn animation;\n}\n\n/**\n * Perform a complete FLIP animation with data attribute tracking.\n *\n * This is a higher-level helper that:\n * 1. Excludes the element from View Transitions\n * 2. Sets a tracking attribute during animation\n * 3. Animates using FLIP\n * 4. Restores View Transition name when done\n *\n * @param element - The element to animate\n * @param firstRect - The element's bounding rect before the DOM change\n * @param options - Animation options plus optional attribute name\n *\n * @example\n * ```ts\n * const firstRect = element.getBoundingClientRect();\n * element.style.gridColumn = '2 / span 2';\n *\n * requestAnimationFrame(() => {\n *   animateFLIPWithTracking(element, firstRect, {\n *     attributeName: 'data-gridiot-dropping',\n *     includeScale: true,\n *     transformOrigin: 'top left',\n *   });\n * });\n * ```\n */\nexport function animateFLIPWithTracking(\n\telement: HTMLElement,\n\tfirstRect: DOMRect,\n\toptions: FLIPOptions & { attributeName?: string } = {},\n): Animation | null {\n\tconst { attributeName = 'data-gridiot-dropping', ...flipOptions } = options;\n\n\t// Exclude from View Transitions\n\telement.style.viewTransitionName = 'none';\n\n\tconst animation = animateFLIP(element, firstRect, {\n\t\t...flipOptions,\n\t\tonStart: () => {\n\t\t\telement.setAttribute(attributeName, '');\n\t\t\tflipOptions.onStart?.();\n\t\t},\n\t\tonFinish: () => {\n\t\t\telement.removeAttribute(attributeName);\n\t\t\t// Restore view transition name\n\t\t\tconst itemId = getItemViewTransitionName(element);\n\t\t\tif (itemId) {\n\t\t\t\telement.style.viewTransitionName = itemId;\n\t\t\t}\n\t\t\tflipOptions.onFinish?.();\n\t\t},\n\t});\n\n\t// If no animation was needed, clean up immediately\n\tif (!animation) {\n\t\tconst itemId = getItemViewTransitionName(element);\n\t\tif (itemId) {\n\t\t\telement.style.viewTransitionName = itemId;\n\t\t}\n\t}\n\n\treturn animation;\n}\n", "import { getItemCell, registerPlugin } from '../engine';\nimport type { DragState as ExposedDragState, GridCell } from '../types';\nimport { animateFLIPWithTracking } from '../utils/flip';\n\n// Hysteresis: distance in grid units before changing target cell\nconst HYSTERESIS = 0.4;\n// Minimum time (ms) between target changes to prevent jitter\nconst TARGET_CHANGE_DEBOUNCE = 40;\n// Minimum pixels of movement before starting a drag\nconst DRAG_THRESHOLD = 5;\n// Minimum pixels of cumulative movement before applying predictive offset\nconst PREDICTION_THRESHOLD = 30;\n// Fraction of cell to lead ahead when prediction is active (0.5 = half a cell)\nconst PREDICTION_LEAD = 0.5;\n\nconst DEBUG = false;\nfunction log(...args: unknown[]) {\n\tif (DEBUG) console.log('[pointer]', ...args);\n}\n\ninterface PendingDrag {\n\titem: HTMLElement;\n\tpointerId: number;\n\tstartX: number;\n\tstartY: number;\n\trect: DOMRect;\n\tstartCell: GridCell;\n\tcolspan: number;\n\trowspan: number;\n}\n\ninterface DragState {\n\titem: HTMLElement;\n\tpointerId: number;\n\toffsetX: number;\n\toffsetY: number;\n\tinitialRect: DOMRect;\n\tstartCell: GridCell;\n\tlastCell: GridCell;\n\tlastTargetChangeTime: number;\n\tcolspan: number;\n\trowspan: number;\n\t// For predictive placeholder\n\tdragStartX: number;\n\tdragStartY: number;\n}\n\nregisterPlugin({\n\tname: 'pointer',\n\tinit(core) {\n\t\tlet pendingDrag: PendingDrag | null = null;\n\t\tlet dragState: DragState | null = null;\n\n\t\t// Register provider for drag state - allows other plugins to query current drag\n\t\tcore.providers.register<ExposedDragState | null>('drag', () => {\n\t\t\tif (!dragState) return null;\n\t\t\treturn {\n\t\t\t\titem: dragState.item,\n\t\t\t\tcell: dragState.lastCell,\n\t\t\t\tstartCell: dragState.startCell,\n\t\t\t\tcolspan: dragState.colspan,\n\t\t\t\trowspan: dragState.rowspan,\n\t\t\t};\n\t\t});\n\n\t\tconst startDrag = (pending: PendingDrag, e: PointerEvent) => {\n\t\t\tconst { item, pointerId, rect, startCell, colspan, rowspan } = pending;\n\n\t\t\tdragState = {\n\t\t\t\titem,\n\t\t\t\tpointerId,\n\t\t\t\toffsetX: e.clientX - rect.left,\n\t\t\t\toffsetY: e.clientY - rect.top,\n\t\t\t\tinitialRect: rect,\n\t\t\t\tstartCell,\n\t\t\t\tlastCell: startCell,\n\t\t\t\tlastTargetChangeTime: 0,\n\t\t\t\tcolspan,\n\t\t\t\trowspan,\n\t\t\t\tdragStartX: e.clientX,\n\t\t\t\tdragStartY: e.clientY,\n\t\t\t};\n\n\t\t\titem.setAttribute('data-gridiot-dragging', '');\n\t\t\tdocument.body.classList.add('is-dragging');\n\n\t\t\t// Switch to fixed positioning for visual drag\n\t\t\titem.style.position = 'fixed';\n\t\t\titem.style.left = `${rect.left}px`;\n\t\t\titem.style.top = `${rect.top}px`;\n\t\t\titem.style.width = `${rect.width}px`;\n\t\t\titem.style.height = `${rect.height}px`;\n\t\t\titem.style.zIndex = '100';\n\t\t\t// Set to 'auto' to override CSS stylesheet rules and remove from grid layout\n\t\t\titem.style.gridColumn = 'auto';\n\t\t\titem.style.gridRow = 'auto';\n\n\t\t\tlog('drag-start', { startCell, rect: { left: rect.left, top: rect.top } });\n\t\t\tcore.emit('drag-start', { item, cell: startCell, colspan, rowspan });\n\n\t\t\tpendingDrag = null;\n\t\t};\n\n\t\tconst onPointerDown = (e: PointerEvent) => {\n\t\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t\t'[data-gridiot-item]',\n\t\t\t) as HTMLElement | null;\n\t\t\tif (!item) return;\n\n\t\t\t// Select the item on click\n\t\t\tcore.select(item);\n\n\t\t\t// Prevent text selection during potential drag\n\t\t\te.preventDefault();\n\n\t\t\tconst rect = item.getBoundingClientRect();\n\t\t\tconst startCell = getItemCell(item);\n\t\t\tconst colspan =\n\t\t\t\tparseInt(item.getAttribute('data-gridiot-colspan') || '1', 10) || 1;\n\t\t\tconst rowspan =\n\t\t\t\tparseInt(item.getAttribute('data-gridiot-rowspan') || '1', 10) || 1;\n\n\t\t\t// Store pending drag state - don't start drag until movement\n\t\t\tpendingDrag = {\n\t\t\t\titem,\n\t\t\t\tpointerId: e.pointerId,\n\t\t\t\tstartX: e.clientX,\n\t\t\t\tstartY: e.clientY,\n\t\t\t\trect,\n\t\t\t\tstartCell,\n\t\t\t\tcolspan,\n\t\t\t\trowspan,\n\t\t\t};\n\n\t\t\titem.setPointerCapture(e.pointerId);\n\t\t\titem.addEventListener('pointermove', onPointerMove);\n\t\t\titem.addEventListener('pointerup', onPointerUp);\n\t\t\titem.addEventListener('pointercancel', onPointerCancel);\n\t\t};\n\n\t\tconst onPointerMove = (e: PointerEvent) => {\n\t\t\t// Check if we need to start dragging\n\t\t\tif (pendingDrag && !dragState) {\n\t\t\t\tconst dx = e.clientX - pendingDrag.startX;\n\t\t\t\tconst dy = e.clientY - pendingDrag.startY;\n\t\t\t\tconst distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\tif (distance >= DRAG_THRESHOLD) {\n\t\t\t\t\tstartDrag(pendingDrag, e);\n\t\t\t\t} else {\n\t\t\t\t\treturn; // Not enough movement yet\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dragState) return;\n\n\t\t\tconst { item, offsetX, offsetY, initialRect, colspan, rowspan } = dragState;\n\n\t\t\t// Move item with cursor\n\t\t\tconst newLeft = e.clientX - offsetX;\n\t\t\tconst newTop = e.clientY - offsetY;\n\t\t\titem.style.left = `${newLeft}px`;\n\t\t\titem.style.top = `${newTop}px`;\n\n\t\t\t// Calculate target based on card center (feels more natural for multi-cell items)\n\t\t\tlet cardCenterX = newLeft + initialRect.width / 2;\n\t\t\tlet cardCenterY = newTop + initialRect.height / 2;\n\n\t\t\t// Predictive offset: shift the effective center in the direction of movement\n\t\t\tconst gridInfo = core.getGridInfo();\n\t\t\tconst cumulativeDx = e.clientX - dragState.dragStartX;\n\t\t\tconst cumulativeDy = e.clientY - dragState.dragStartY;\n\n\t\t\t// Apply prediction offset when movement exceeds threshold\n\t\t\tif (Math.abs(cumulativeDx) > PREDICTION_THRESHOLD) {\n\t\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellWidth + gridInfo.gap);\n\t\t\t\tcardCenterX += Math.sign(cumulativeDx) * leadOffset;\n\t\t\t}\n\t\t\tif (Math.abs(cumulativeDy) > PREDICTION_THRESHOLD) {\n\t\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellHeight + gridInfo.gap);\n\t\t\t\tcardCenterY += Math.sign(cumulativeDy) * leadOffset;\n\t\t\t}\n\n\t\t\tconst rawCell = core.getCellFromPoint(cardCenterX, cardCenterY);\n\t\t\tif (rawCell) {\n\t\t\t\t// Clamp cell so item fits within grid bounds\n\t\t\t\tconst gridInfo = core.getGridInfo();\n\t\t\t\tconst maxColumn = Math.max(1, gridInfo.columns.length - colspan + 1);\n\t\t\t\tconst maxRow = Math.max(1, gridInfo.rows.length - rowspan + 1);\n\n\t\t\t\tconst cell: GridCell = {\n\t\t\t\t\tcolumn: Math.max(1, Math.min(maxColumn, rawCell.column)),\n\t\t\t\t\trow: Math.max(1, Math.min(maxRow, rawCell.row)),\n\t\t\t\t};\n\n\t\t\t\tconst now = performance.now();\n\t\t\t\tconst timeSinceLastChange = now - dragState.lastTargetChangeTime;\n\n\t\t\t\t// Check if cell actually changed\n\t\t\t\tconst cellChanged =\n\t\t\t\t\tcell.column !== dragState.lastCell.column ||\n\t\t\t\t\tcell.row !== dragState.lastCell.row;\n\n\t\t\t\tif (cellChanged && timeSinceLastChange >= TARGET_CHANGE_DEBOUNCE) {\n\t\t\t\t\tconst cellWidth = gridInfo.cellWidth + gridInfo.gap;\n\t\t\t\t\tconst cellHeight = gridInfo.cellHeight + gridInfo.gap;\n\n\t\t\t\t\t// Current cell center in pixels (CSS Grid is 1-indexed)\n\t\t\t\t\tconst currentCellCenterX =\n\t\t\t\t\t\tgridInfo.rect.left +\n\t\t\t\t\t\t(dragState.lastCell.column - 1) * cellWidth +\n\t\t\t\t\t\tgridInfo.cellWidth / 2;\n\t\t\t\t\tconst currentCellCenterY =\n\t\t\t\t\t\tgridInfo.rect.top +\n\t\t\t\t\t\t(dragState.lastCell.row - 1) * cellHeight +\n\t\t\t\t\t\tgridInfo.cellHeight / 2;\n\n\t\t\t\t\t// Signed distance from card center to current cell center (in grid units)\n\t\t\t\t\tconst offsetFromCellX = (cardCenterX - currentCellCenterX) / cellWidth;\n\t\t\t\t\tconst offsetFromCellY = (cardCenterY - currentCellCenterY) / cellHeight;\n\n\t\t\t\t\t// Direction-aware hysteresis\n\t\t\t\t\tconst newCellIsRight = cell.column > dragState.lastCell.column;\n\t\t\t\t\tconst newCellIsBelow = cell.row > dragState.lastCell.row;\n\t\t\t\t\tconst cardIsRight = offsetFromCellX > 0;\n\t\t\t\t\tconst cardIsBelow = offsetFromCellY > 0;\n\n\t\t\t\t\tconst alignedX = (newCellIsRight && cardIsRight) || (!newCellIsRight && !cardIsRight);\n\t\t\t\t\tconst alignedY = (newCellIsBelow && cardIsBelow) || (!newCellIsBelow && !cardIsBelow);\n\n\t\t\t\t\tconst thresholdX = alignedX ? 0.5 : 0.5 + HYSTERESIS;\n\t\t\t\t\tconst thresholdY = alignedY ? 0.5 : 0.5 + HYSTERESIS;\n\n\t\t\t\t\tconst distX = Math.abs(offsetFromCellX);\n\t\t\t\t\tconst distY = Math.abs(offsetFromCellY);\n\n\t\t\t\t\tif (distX < thresholdX && distY < thresholdY) {\n\t\t\t\t\t\treturn; // Stay in current cell\n\t\t\t\t\t}\n\n\t\t\t\t\tlog('drag-move', { cell, distX: distX.toFixed(2), distY: distY.toFixed(2) });\n\t\t\t\t\tdragState.lastCell = cell;\n\t\t\t\t\tdragState.lastTargetChangeTime = now;\n\t\t\t\t\tcore.emit('drag-move', { item, cell, x: e.clientX, y: e.clientY, colspan, rowspan });\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst onPointerUp = (e: PointerEvent) => {\n\t\t\tconst item = pendingDrag?.item || dragState?.item;\n\t\t\tif (!item) return;\n\n\t\t\t// If drag never started, this was just a click - nothing more to do\n\t\t\tif (pendingDrag && !dragState) {\n\t\t\t\tlog('click (no drag)');\n\t\t\t\tcleanupListeners(item, pendingDrag.pointerId);\n\t\t\t\tpendingDrag = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!dragState) return;\n\n\t\t\tconst { initialRect, colspan, rowspan, lastCell, offsetX, offsetY, dragStartX, dragStartY } = dragState;\n\n\t\t\t// Calculate drop position with same predictive offset as drag-move\n\t\t\tconst gridInfo = core.getGridInfo();\n\t\t\tconst cumulativeDx = e.clientX - dragStartX;\n\t\t\tconst cumulativeDy = e.clientY - dragStartY;\n\n\t\t\t// Apply prediction offset to get effective center for cell calculation\n\t\t\tconst newLeft = e.clientX - offsetX;\n\t\t\tconst newTop = e.clientY - offsetY;\n\t\t\tlet effectiveCenterX = newLeft + initialRect.width / 2;\n\t\t\tlet effectiveCenterY = newTop + initialRect.height / 2;\n\n\t\t\tif (Math.abs(cumulativeDx) > PREDICTION_THRESHOLD) {\n\t\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellWidth + gridInfo.gap);\n\t\t\t\teffectiveCenterX += Math.sign(cumulativeDx) * leadOffset;\n\t\t\t}\n\t\t\tif (Math.abs(cumulativeDy) > PREDICTION_THRESHOLD) {\n\t\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellHeight + gridInfo.gap);\n\t\t\t\teffectiveCenterY += Math.sign(cumulativeDy) * leadOffset;\n\t\t\t}\n\n\t\t\tconst rawCell = core.getCellFromPoint(effectiveCenterX, effectiveCenterY);\n\n\t\t\t// FLIP: Capture current visual position (First)\n\t\t\tconst firstRect = item.getBoundingClientRect();\n\n\t\t\t// Emit event BEFORE cleanup so algorithm can set final position\n\t\t\tif (rawCell) {\n\t\t\t\tconst maxColumn = Math.max(1, gridInfo.columns.length - colspan + 1);\n\t\t\t\tconst maxRow = Math.max(1, gridInfo.rows.length - rowspan + 1);\n\n\t\t\t\tconst cell: GridCell = {\n\t\t\t\t\tcolumn: Math.max(1, Math.min(maxColumn, rawCell.column)),\n\t\t\t\t\trow: Math.max(1, Math.min(maxRow, rawCell.row)),\n\t\t\t\t};\n\n\t\t\t\tlog('drag-end', { cell });\n\t\t\t\tcore.emit('drag-end', { item, cell, colspan, rowspan });\n\t\t\t} else {\n\t\t\t\tlog('drag-end', { cell: lastCell, note: 'using lastCell (pointer outside grid)' });\n\t\t\t\tcore.emit('drag-end', { item, cell: lastCell, colspan, rowspan });\n\t\t\t}\n\n\t\t\tcleanup();\n\n\t\t\t// FLIP: Animate from visual position to final grid position\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tlog('FLIP', { firstRect: { left: firstRect.left.toFixed(0), top: firstRect.top.toFixed(0) } });\n\t\t\t\tanimateFLIPWithTracking(item, firstRect);\n\t\t\t});\n\t\t};\n\n\t\tconst onPointerCancel = () => {\n\t\t\tconst item = pendingDrag?.item || dragState?.item;\n\t\t\tif (!item) return;\n\n\t\t\tif (dragState) {\n\t\t\t\tcore.emit('drag-cancel', { item });\n\t\t\t}\n\t\t\tcleanup();\n\t\t};\n\n\t\tconst cleanupListeners = (item: HTMLElement, pointerId: number) => {\n\t\t\titem.releasePointerCapture(pointerId);\n\t\t\titem.removeEventListener('pointermove', onPointerMove);\n\t\t\titem.removeEventListener('pointerup', onPointerUp);\n\t\t\titem.removeEventListener('pointercancel', onPointerCancel);\n\t\t};\n\n\t\tconst cleanup = () => {\n\t\t\tif (dragState) {\n\t\t\t\tconst { item, pointerId } = dragState;\n\n\t\t\t\titem.removeAttribute('data-gridiot-dragging');\n\t\t\t\tdocument.body.classList.remove('is-dragging');\n\t\t\t\titem.style.position = '';\n\t\t\t\titem.style.left = '';\n\t\t\t\titem.style.top = '';\n\t\t\t\titem.style.width = '';\n\t\t\t\titem.style.height = '';\n\t\t\t\titem.style.zIndex = '';\n\n\t\t\t\tcleanupListeners(item, pointerId);\n\t\t\t\tdragState = null;\n\t\t\t}\n\n\t\t\tif (pendingDrag) {\n\t\t\t\tcleanupListeners(pendingDrag.item, pendingDrag.pointerId);\n\t\t\t\tpendingDrag = null;\n\t\t\t}\n\t\t};\n\n\t\t// Deselect when clicking outside the grid\n\t\tconst onDocumentPointerDown = (e: PointerEvent) => {\n\t\t\tif (core.element.contains(e.target as Node)) return;\n\t\t\tif (dragState) return;\n\t\t\tcore.deselect();\n\t\t};\n\n\t\tcore.element.addEventListener('pointerdown', onPointerDown);\n\t\tdocument.addEventListener('pointerdown', onDocumentPointerDown);\n\n\t\treturn () => {\n\t\t\tcore.element.removeEventListener('pointerdown', onPointerDown);\n\t\t\tdocument.removeEventListener('pointerdown', onDocumentPointerDown);\n\t\t\tcleanup();\n\t\t};\n\t},\n});\n"],
  "mappings": "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",
  "names": ["gridInfo"]
}
