{
  "version": 3,
  "sources": ["../state-machine.ts", "../engine.ts"],
  "sourcesContent": ["/**\n * Centralized State Machine for Gridiot\n *\n * This module provides a single source of truth for interaction state,\n * replacing the distributed state management across plugins.\n *\n * Key invariants:\n * 1. Only ONE interaction can be active at a time (drag OR resize, not both)\n * 2. Column count is captured at interaction start and immutable during interaction\n * 3. CSS injection is coordinated through this state machine\n * 4. View Transitions are only used for keyboard interactions (not pointer/FLIP)\n */\n\nimport type { GridCell, ItemPosition } from './types';\n\n// ============================================================================\n// State Types\n// ============================================================================\n\nexport type InteractionMode = 'pointer' | 'keyboard';\n\nexport type InteractionType = 'drag' | 'resize';\n\nexport type GridiotPhase =\n\t| 'idle'\n\t| 'selected'\n\t| 'interacting'  // Active drag or resize\n\t| 'committing';  // Saving to layout model, clearing preview\n\nexport interface InteractionContext {\n\t/** The type of interaction (drag or resize) */\n\ttype: InteractionType;\n\t/** How the interaction was initiated */\n\tmode: InteractionMode;\n\t/** The item being interacted with */\n\titemId: string;\n\t/** The DOM element being interacted with */\n\telement: HTMLElement;\n\t/** Column count at interaction start (immutable during interaction) */\n\tcolumnCount: number;\n\t/** Original positions of all items at interaction start */\n\toriginalPositions: Map<string, ItemPosition>;\n\t/** Original sizes of all items at interaction start (for resize) */\n\toriginalSizes: Map<string, { width: number; height: number }>;\n\t/** Current target cell during interaction */\n\ttargetCell: GridCell;\n\t/** Current size during resize */\n\tcurrentSize: { colspan: number; rowspan: number };\n\t/** Whether FLIP animation should be used (pointer mode only) */\n\tuseFlip: boolean;\n\t/** Whether View Transitions should be used (keyboard mode only) */\n\tuseViewTransition: boolean;\n}\n\nexport interface GridiotState {\n\tphase: GridiotPhase;\n\tselectedItemId: string | null;\n\tinteraction: InteractionContext | null;\n\t/** Track if keyboard mode is active (Shift+G toggle) */\n\tkeyboardModeActive: boolean;\n}\n\n// ============================================================================\n// State Machine\n// ============================================================================\n\nexport type StateTransition =\n\t| { type: 'SELECT'; itemId: string; element: HTMLElement }\n\t| { type: 'DESELECT' }\n\t| { type: 'START_INTERACTION'; context: Omit<InteractionContext, 'useFlip' | 'useViewTransition'> }\n\t| { type: 'UPDATE_INTERACTION'; targetCell: GridCell; currentSize?: { colspan: number; rowspan: number } }\n\t| { type: 'COMMIT_INTERACTION' }\n\t| { type: 'CANCEL_INTERACTION' }\n\t| { type: 'FINISH_COMMIT' }\n\t| { type: 'TOGGLE_KEYBOARD_MODE' };\n\nexport type StateListener = (state: GridiotState, transition: StateTransition) => void;\n\nexport interface GridiotStateMachine {\n\tgetState(): GridiotState;\n\ttransition(action: StateTransition): GridiotState;\n\tsubscribe(listener: StateListener): () => void;\n\t/** Check if a transition is valid from current state */\n\tcanTransition(action: StateTransition): boolean;\n}\n\n/**\n * Create the initial state\n */\nexport function createInitialState(): GridiotState {\n\treturn {\n\t\tphase: 'idle',\n\t\tselectedItemId: null,\n\t\tinteraction: null,\n\t\tkeyboardModeActive: false,\n\t};\n}\n\n/**\n * Pure state reducer - computes next state from current state and action\n */\nexport function reducer(state: GridiotState, action: StateTransition): GridiotState {\n\tswitch (action.type) {\n\t\tcase 'SELECT': {\n\t\t\t// Can select from idle or selected (changes selection)\n\t\t\tif (state.phase !== 'idle' && state.phase !== 'selected') {\n\t\t\t\treturn state; // Can't select during interaction\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'selected',\n\t\t\t\tselectedItemId: action.itemId,\n\t\t\t};\n\t\t}\n\n\t\tcase 'DESELECT': {\n\t\t\t// Can deselect from selected only\n\t\t\tif (state.phase !== 'selected') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'idle',\n\t\t\t\tselectedItemId: null,\n\t\t\t};\n\t\t}\n\n\t\tcase 'START_INTERACTION': {\n\t\t\t// Can start interaction from selected only\n\t\t\tif (state.phase !== 'selected') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\tconst { context } = action;\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'interacting',\n\t\t\t\tinteraction: {\n\t\t\t\t\t...context,\n\t\t\t\t\t// Derive animation strategy from mode\n\t\t\t\t\tuseFlip: context.mode === 'pointer',\n\t\t\t\t\tuseViewTransition: context.mode === 'keyboard',\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tcase 'UPDATE_INTERACTION': {\n\t\t\t// Can only update during active interaction\n\t\t\tif (state.phase !== 'interacting' || !state.interaction) {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tinteraction: {\n\t\t\t\t\t...state.interaction,\n\t\t\t\t\ttargetCell: action.targetCell,\n\t\t\t\t\tcurrentSize: action.currentSize ?? state.interaction.currentSize,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tcase 'COMMIT_INTERACTION': {\n\t\t\t// Transition from interacting to committing\n\t\t\tif (state.phase !== 'interacting') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'committing',\n\t\t\t};\n\t\t}\n\n\t\tcase 'CANCEL_INTERACTION': {\n\t\t\t// Can cancel from interacting\n\t\t\tif (state.phase !== 'interacting') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'selected',\n\t\t\t\tinteraction: null,\n\t\t\t};\n\t\t}\n\n\t\tcase 'FINISH_COMMIT': {\n\t\t\t// Transition from committing back to selected\n\t\t\tif (state.phase !== 'committing') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'selected',\n\t\t\t\tinteraction: null,\n\t\t\t};\n\t\t}\n\n\t\tcase 'TOGGLE_KEYBOARD_MODE': {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tkeyboardModeActive: !state.keyboardModeActive,\n\t\t\t};\n\t\t}\n\n\t\tdefault:\n\t\t\treturn state;\n\t}\n}\n\n/**\n * Check if a transition is valid from the current state\n */\nexport function canTransition(state: GridiotState, action: StateTransition): boolean {\n\tswitch (action.type) {\n\t\tcase 'SELECT':\n\t\t\treturn state.phase === 'idle' || state.phase === 'selected';\n\t\tcase 'DESELECT':\n\t\t\treturn state.phase === 'selected';\n\t\tcase 'START_INTERACTION':\n\t\t\treturn state.phase === 'selected';\n\t\tcase 'UPDATE_INTERACTION':\n\t\t\treturn state.phase === 'interacting' && state.interaction !== null;\n\t\tcase 'COMMIT_INTERACTION':\n\t\t\treturn state.phase === 'interacting';\n\t\tcase 'CANCEL_INTERACTION':\n\t\t\treturn state.phase === 'interacting';\n\t\tcase 'FINISH_COMMIT':\n\t\t\treturn state.phase === 'committing';\n\t\tcase 'TOGGLE_KEYBOARD_MODE':\n\t\t\treturn true; // Always allowed\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n/**\n * Create a state machine instance\n */\nexport function createStateMachine(initialState?: GridiotState): GridiotStateMachine {\n\tlet state = initialState ?? createInitialState();\n\tconst listeners = new Set<StateListener>();\n\n\treturn {\n\t\tgetState() {\n\t\t\treturn state;\n\t\t},\n\n\t\ttransition(action: StateTransition) {\n\t\t\tconst nextState = reducer(state, action);\n\t\t\tif (nextState !== state) {\n\t\t\t\tstate = nextState;\n\t\t\t\tfor (const listener of listeners) {\n\t\t\t\t\tlistener(state, action);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn state;\n\t\t},\n\n\t\tsubscribe(listener: StateListener) {\n\t\t\tlisteners.add(listener);\n\t\t\treturn () => listeners.delete(listener);\n\t\t},\n\n\t\tcanTransition(action: StateTransition) {\n\t\t\treturn canTransition(state, action);\n\t\t},\n\t};\n}\n\n// ============================================================================\n// Derived State Helpers\n// ============================================================================\n\n/**\n * Check if currently in an active interaction\n */\nexport function isInteracting(state: GridiotState): boolean {\n\treturn state.phase === 'interacting' || state.phase === 'committing';\n}\n\n/**\n * Check if currently dragging (not resizing)\n */\nexport function isDragging(state: GridiotState): boolean {\n\treturn isInteracting(state) && state.interaction?.type === 'drag';\n}\n\n/**\n * Check if currently resizing (not dragging)\n */\nexport function isResizing(state: GridiotState): boolean {\n\treturn isInteracting(state) && state.interaction?.type === 'resize';\n}\n\n/**\n * Get the interaction mode if active\n */\nexport function getInteractionMode(state: GridiotState): InteractionMode | null {\n\treturn state.interaction?.mode ?? null;\n}\n\n/**\n * Check if View Transitions should be used for current interaction\n */\nexport function shouldUseViewTransition(state: GridiotState): boolean {\n\treturn state.interaction?.useViewTransition ?? false;\n}\n\n/**\n * Check if FLIP animation should be used for current interaction\n */\nexport function shouldUseFlip(state: GridiotState): boolean {\n\treturn state.interaction?.useFlip ?? false;\n}\n\n/**\n * Get the captured column count for current interaction\n */\nexport function getInteractionColumnCount(state: GridiotState): number | null {\n\treturn state.interaction?.columnCount ?? null;\n}\n", "import type { GridCell, GridiotCore, InitOptions, Plugin, PluginOptions, ProviderRegistry } from './types';\nimport { createStateMachine, type GridiotStateMachine } from './state-machine';\n\n// Global plugin registry\nconst plugins = new Map<string, Plugin>();\n\nexport function registerPlugin(plugin: Plugin): void {\n\tplugins.set(plugin.name, plugin);\n}\n\nexport function getPlugin(name: string): Plugin | undefined {\n\treturn plugins.get(name);\n}\n\n/**\n * Initialize Gridiot on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options including layoutModel, styleElement, and plugin options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): GridiotCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t\tplugins: pluginOptions = {},\n\t\tdisablePlugins = [],\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\t// Create centralized state machine\n\tconst stateMachine = createStateMachine();\n\n\t// Track selected element (state machine stores itemId, we need the element)\n\tlet selectedElement: HTMLElement | null = null;\n\n\t// Provider registry for inter-plugin communication\n\tconst providerMap = new Map<string, () => unknown>();\n\tconst providers: ProviderRegistry = {\n\t\tregister<T>(capability: string, provider: () => T): void {\n\t\t\tif (providerMap.has(capability)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Gridiot: Provider for \"${capability}\" already registered, overwriting`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tproviderMap.set(capability, provider);\n\t\t},\n\n\t\tget<T>(capability: string): T | undefined {\n\t\t\tconst provider = providerMap.get(capability);\n\t\t\treturn provider ? (provider() as T) : undefined;\n\t\t},\n\n\t\thas(capability: string): boolean {\n\t\t\treturn providerMap.has(capability);\n\t\t},\n\t};\n\n\tconst core: GridiotCore = {\n\t\telement,\n\t\tproviders,\n\t\tstateMachine,\n\n\t\t// Selection state (backed by state machine)\n\t\tget selectedItem() {\n\t\t\treturn selectedElement;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedElement) return;\n\n\t\t\tconst previousItem = selectedElement;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-gridiot-selected');\n\t\t\t}\n\n\t\t\t// Update state machine and local element reference\n\t\t\tif (item) {\n\t\t\t\tconst itemId = item.id || item.getAttribute('data-gridiot-item') || '';\n\t\t\t\tstateMachine.transition({ type: 'SELECT', itemId, element: item });\n\t\t\t\tselectedElement = item;\n\t\t\t\titem.setAttribute('data-gridiot-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else {\n\t\t\t\tstateMachine.transition({ type: 'DESELECT' });\n\t\t\t\tselectedElement = null;\n\t\t\t\tif (previousItem) {\n\t\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`gridiot:${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tobserver.disconnect();\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Observe position changes and animate with View Transitions\n\tconst observer = new MutationObserver((mutations) => {\n\t\t// Collect items that changed position\n\t\tconst changedItems = new Set<HTMLElement>();\n\n\t\tfor (const mutation of mutations) {\n\t\t\tif (\n\t\t\t\tmutation.type === 'attributes' &&\n\t\t\t\tmutation.target instanceof HTMLElement\n\t\t\t) {\n\t\t\t\tconst item = mutation.target.closest(\n\t\t\t\t\t'[data-gridiot-item]',\n\t\t\t\t) as HTMLElement | null;\n\t\t\t\tif (item && element.contains(item)) {\n\t\t\t\t\tchangedItems.add(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Animate changes with View Transitions if available\n\t\tif (changedItems.size > 0 && 'startViewTransition' in document) {\n\t\t\t// Items already moved - View Transitions will handle animation\n\t\t\t// The browser captures before/after states automatically\n\t\t}\n\t});\n\n\tobserver.observe(element, {\n\t\tsubtree: true,\n\t\tattributes: true,\n\t\tattributeFilter: ['style', 'class'],\n\t});\n\n\t// Register state machine provider for plugin access\n\tproviders.register('state', () => stateMachine.getState());\n\n\t// Initialize all registered plugins with options\n\tfor (const plugin of plugins.values()) {\n\t\t// Skip disabled plugins\n\t\tif (disablePlugins.includes(plugin.name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Build options for this plugin\n\t\tconst pluginSpecificOptions = pluginOptions[plugin.name as keyof PluginOptions] ?? {};\n\t\tconst opts = {\n\t\t\t...pluginSpecificOptions,\n\t\t\t// Pass shared resources to all plugins that might need them\n\t\t\tlayoutModel,\n\t\t\tstyleElement,\n\t\t\tcore,\n\t\t};\n\n\t\tconst cleanup = plugin.init(core, opts);\n\t\tif (cleanup) {\n\t\t\tcleanups.push(cleanup);\n\t\t}\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Set an item's grid position\n */\nexport function setItemCell(item: HTMLElement, cell: GridCell): void {\n\titem.style.gridColumn = String(cell.column);\n\titem.style.gridRow = String(cell.row);\n}\n\n/**\n * Get grid info for a grid element\n */\nexport function getGridInfo(element: HTMLElement) {\n\tconst rect = element.getBoundingClientRect();\n\tconst style = getComputedStyle(element);\n\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\tconst columnGap = parseFloat(style.columnGap) || 0;\n\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\treturn {\n\t\trect,\n\t\tcolumns,\n\t\trows,\n\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\tcellWidth: columns[0] || 0,\n\t\tcellHeight: rows[0] || 0,\n\t};\n}\n"],
  "mappings": "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",
  "names": []
}
