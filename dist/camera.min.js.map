{"version":3,"file":"camera.min.js","names":[],"sources":["../engine.ts","../plugins/camera.ts"],"sourcesContent":["import type { GridCell, EggCore, InitOptions, StyleManager } from './types';\nimport { createStateMachine } from './state-machine';\nimport { attachPointer } from './plugins/pointer';\nimport { attachKeyboard } from './plugins/keyboard';\nimport { attachAccessibility } from './plugins/accessibility';\nimport { attachResize } from './plugins/resize';\nimport { attachCamera } from './plugins/camera';\nimport { attachPlaceholder } from './plugins/placeholder';\nimport { attachPushAlgorithm } from './plugins/algorithm-push';\nimport { attachReorderAlgorithm } from './plugins/algorithm-reorder';\nimport { attachResponsive } from './plugins/responsive';\n\n/**\n * Initialize EG Grid on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): EggCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\t// Create centralized state machine\n\tconst stateMachine = createStateMachine();\n\n\t// Track selected element (state machine stores itemId, we need the element)\n\tlet selectedElement: HTMLElement | null = null;\n\n\t// StyleManager: single style element, multiple named layers\n\tconst styleLayers = new Map<string, string>(); // layer name → CSS\n\tconst layerOrder: string[] = []; // insertion order\n\tconst managedStyleElement = styleElement ?? document.createElement('style');\n\tif (!styleElement) {\n\t\tdocument.head.appendChild(managedStyleElement);\n\t\tcleanups.push(() => managedStyleElement.remove());\n\t}\n\n\t// Pre-populate 'base' layer with any existing content (e.g. server-rendered CSS)\n\tconst existingCSS = managedStyleElement.textContent?.trim();\n\tif (existingCSS) {\n\t\tstyleLayers.set('base', existingCSS);\n\t\tlayerOrder.push('base');\n\t}\n\n\tconst styles: StyleManager = {\n\t\tset(layer: string, css: string): void {\n\t\t\tif (!styleLayers.has(layer)) {\n\t\t\t\tlayerOrder.push(layer);\n\t\t\t}\n\t\t\tstyleLayers.set(layer, css);\n\t\t},\n\t\tget(layer: string): string {\n\t\t\treturn styleLayers.get(layer) ?? '';\n\t\t},\n\t\tclear(layer: string): void {\n\t\t\tif (styleLayers.has(layer)) {\n\t\t\t\tstyleLayers.set(layer, '');\n\t\t\t}\n\t\t},\n\t\tcommit(): void {\n\t\t\tconst parts: string[] = [];\n\t\t\tfor (const layer of layerOrder) {\n\t\t\t\tconst css = styleLayers.get(layer);\n\t\t\t\tif (css) parts.push(css);\n\t\t\t}\n\t\t\tmanagedStyleElement.textContent = parts.join('\\n\\n');\n\t\t},\n\t};\n\n\tconst core: EggCore = {\n\t\telement,\n\t\tstateMachine,\n\t\tstyles,\n\t\tcameraScrolling: false,\n\n\t\t// Selection state (backed by state machine)\n\t\tget selectedItem() {\n\t\t\treturn selectedElement;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedElement) return;\n\n\t\t\tconst previousItem = selectedElement;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-egg-selected');\n\t\t\t}\n\n\t\t\t// Update state machine and local element reference\n\t\t\tif (item) {\n\t\t\t\tconst itemId = item.id || item.getAttribute('data-egg-item') || '';\n\t\t\t\tstateMachine.transition({ type: 'SELECT', itemId, element: item });\n\t\t\t\tselectedElement = item;\n\t\t\t\titem.setAttribute('data-egg-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else {\n\t\t\t\tstateMachine.transition({ type: 'DESELECT' });\n\t\t\t\tselectedElement = null;\n\t\t\t\tif (previousItem) {\n\t\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`egg-${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Direct initialization — no registry, no loop\n\tif (options.pointer !== false) {\n\t\tcleanups.push(attachPointer(core));\n\t}\n\tif (options.keyboard !== false) {\n\t\tcleanups.push(attachKeyboard(core));\n\t}\n\tif (options.accessibility !== false) {\n\t\tcleanups.push(attachAccessibility(core));\n\t}\n\n\tif (options.resize !== false) {\n\t\tconst resizeOpts = typeof options.resize === 'object' ? options.resize : {};\n\t\tconst inst = attachResize(element, { ...resizeOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.camera !== false) {\n\t\tconst cameraOpts = typeof options.camera === 'object' ? options.camera : {};\n\t\tconst inst = attachCamera(element, { ...cameraOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.placeholder !== false) {\n\t\tconst placeholderOpts = typeof options.placeholder === 'object' ? options.placeholder : {};\n\t\tconst inst = attachPlaceholder(element, placeholderOpts);\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\t// Algorithm: push (default) or reorder\n\tif (options.algorithm !== false) {\n\t\tconst algoOpts = options.algorithmOptions ?? {};\n\t\tif (options.algorithm === 'reorder') {\n\t\t\tcleanups.push(attachReorderAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t} else {\n\t\t\tcleanups.push(attachPushAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t}\n\t}\n\n\tif (options.responsive) {\n\t\tcleanups.push(attachResponsive(element, options.responsive, core));\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Get the size of an item from its data attributes\n */\nexport function getItemSize(item: HTMLElement): { colspan: number; rowspan: number } {\n\treturn {\n\t\tcolspan: parseInt(item.getAttribute('data-egg-colspan') || '1', 10) || 1,\n\t\trowspan: parseInt(item.getAttribute('data-egg-rowspan') || '1', 10) || 1,\n\t};\n}\n\n/**\n * Attach multiple event listeners and return a cleanup function to remove them all\n */\nexport function listenEvents(\n\telement: EventTarget,\n\tevents: Record<string, EventListenerOrEventListenerObject>,\n): () => void {\n\tfor (const [name, handler] of Object.entries(events)) {\n\t\telement.addEventListener(name, handler);\n\t}\n\treturn () => {\n\t\tfor (const [name, handler] of Object.entries(events)) {\n\t\t\telement.removeEventListener(name, handler);\n\t\t}\n\t};\n}\n","/**\n * Camera plugin for EG Grid\n *\n * Handles viewport scrolling to keep the active item visible:\n * - Auto-scroll when dragging near viewport edges\n * - Scroll into view when selecting items via keyboard\n *\n * The \"active item\" is: the dragged item during drag, or the selected item otherwise.\n */\n\nimport { listenEvents } from '../engine';\nimport type {\n\tDragStartDetail,\n\tDragMoveDetail,\n\tDragEndDetail,\n\tDragCancelDetail,\n\tSelectDetail,\n\tEggCore,\n} from '../types';\n\nexport type CameraMode = 'contain' | 'center' | 'off';\n\nexport interface CameraOptions {\n\t/**\n\t * Scroll behavior mode:\n\t * - 'contain': Only scroll when item would leave viewport (default)\n\t * - 'center': Keep active item centered (can feel jarring)\n\t * - 'off': Disable camera scrolling\n\t */\n\tmode?: CameraMode;\n\n\t/**\n\t * The scrollable container. Defaults to the grid's scroll parent.\n\t * Pass `window` to scroll the document.\n\t */\n\tscrollContainer?: HTMLElement | Window;\n\n\t/**\n\t * Size of edge zones that trigger auto-scroll during drag (in pixels).\n\t * @default 60\n\t */\n\tedgeSize?: number;\n\n\t/**\n\t * Maximum scroll speed in pixels per frame.\n\t * @default 15\n\t */\n\tscrollSpeed?: number;\n\n\t/**\n\t * Scroll behavior for selection changes.\n\t * @default 'smooth'\n\t */\n\tscrollBehavior?: ScrollBehavior;\n\n\t/**\n\t * Margin around item when scrolling into view (in pixels).\n\t * @default 20\n\t */\n\tscrollMargin?: number;\n\n\t/**\n\t * Whether to scroll on selection changes (keyboard nav).\n\t * @default true\n\t */\n\tscrollOnSelect?: boolean;\n\n\t/**\n\t * Whether to auto-scroll during drag.\n\t * @default true\n\t */\n\tautoScrollOnDrag?: boolean;\n\n\t/**\n\t * Time in ms after scrolling stops before considered \"settled\".\n\t * Other plugins can check isScrolling() to defer updates.\n\t * @default 150\n\t */\n\tsettleDelay?: number;\n\n\t/**\n\t * EG Grid core instance for provider registration.\n\t * If provided, registers a 'camera' provider.\n\t */\n\tcore?: EggCore;\n}\n\n/**\n * Camera state exposed via provider registry.\n */\nexport interface CameraState {\n\t/** Whether the camera is actively auto-scrolling */\n\tisScrolling: boolean;\n\t/** Current camera mode */\n\tmode: CameraMode;\n}\n\nexport interface CameraInstance {\n\t/** Change the camera mode */\n\tsetMode(mode: CameraMode): void;\n\t/** Get current mode */\n\tgetMode(): CameraMode;\n\t/** Manually scroll an item into view */\n\tscrollTo(item: HTMLElement, behavior?: ScrollBehavior): void;\n\t/** Stop any active auto-scrolling */\n\tstop(): void;\n\t/** Clean up and remove event listeners */\n\tdestroy(): void;\n}\n\n/**\n * Find the nearest scrollable ancestor of an element.\n */\nfunction findScrollParent(element: HTMLElement): HTMLElement | Window {\n\tlet parent = element.parentElement;\n\n\twhile (parent) {\n\t\tconst style = getComputedStyle(parent);\n\t\tconst overflowY = style.overflowY;\n\t\tconst overflowX = style.overflowX;\n\n\t\tif (\n\t\t\toverflowY === 'auto' ||\n\t\t\toverflowY === 'scroll' ||\n\t\t\toverflowX === 'auto' ||\n\t\t\toverflowX === 'scroll'\n\t\t) {\n\t\t\treturn parent;\n\t\t}\n\n\t\tparent = parent.parentElement;\n\t}\n\n\treturn window;\n}\n\n/**\n * Get viewport rect for a scroll container.\n */\nfunction getViewportRect(\n\tcontainer: HTMLElement | Window\n): { top: number; left: number; width: number; height: number } {\n\tif (container === window) {\n\t\treturn {\n\t\t\ttop: 0,\n\t\t\tleft: 0,\n\t\t\twidth: window.innerWidth,\n\t\t\theight: window.innerHeight,\n\t\t};\n\t}\n\tconst rect = (container as HTMLElement).getBoundingClientRect();\n\treturn {\n\t\ttop: rect.top,\n\t\tleft: rect.left,\n\t\twidth: rect.width,\n\t\theight: rect.height,\n\t};\n}\n\n/**\n * Attach camera behavior to a EG Grid grid element.\n */\nexport function attachCamera(\n\tgridElement: HTMLElement,\n\toptions: CameraOptions = {}\n): CameraInstance {\n\tconst {\n\t\tmode: initialMode = 'contain',\n\t\tscrollContainer: customContainer,\n\t\tedgeSize = 60,\n\t\tscrollSpeed = 15,\n\t\tscrollBehavior = 'smooth',\n\t\tscrollMargin = 20,\n\t\tscrollOnSelect = true,\n\t\tautoScrollOnDrag = true,\n\t\tsettleDelay = 150,\n\t\tcore,\n\t} = options;\n\n\tlet mode = initialMode;\n\tlet scrollContainer = customContainer ?? findScrollParent(gridElement);\n\tlet animationFrameId: number | null = null;\n\tlet isDragging = false;\n\tlet dragSource: 'pointer' | 'keyboard' | null = null;\n\tlet lastPointerX = 0;\n\tlet lastPointerY = 0;\n\tlet isScrolling = false;\n\tlet settleTimeoutId: ReturnType<typeof setTimeout> | null = null;\n\n\t// Expose scrolling state on core\n\tif (core) {\n\t\tcore.cameraScrolling = false;\n\t}\n\n\t/**\n\t * Mark scrolling as active, with settle timeout.\n\t */\n\tfunction setScrolling(active: boolean): void {\n\t\tif (active) {\n\t\t\tisScrolling = true;\n\t\t\tif (core) core.cameraScrolling = true;\n\t\t\tif (settleTimeoutId) {\n\t\t\t\tclearTimeout(settleTimeoutId);\n\t\t\t\tsettleTimeoutId = null;\n\t\t\t}\n\t\t} else {\n\t\t\t// Start settle timer\n\t\t\tif (settleTimeoutId) clearTimeout(settleTimeoutId);\n\t\t\tsettleTimeoutId = setTimeout(() => {\n\t\t\t\tisScrolling = false;\n\t\t\t\tif (core) core.cameraScrolling = false;\n\t\t\t\tsettleTimeoutId = null;\n\t\t\t\t// Emit settle event so algorithm can recalculate\n\t\t\t\tgridElement.dispatchEvent(\n\t\t\t\t\tnew CustomEvent('egg-camera-settled', { bubbles: true })\n\t\t\t\t);\n\t\t\t}, settleDelay);\n\t\t}\n\t}\n\n\t/**\n\t * Scroll an item into view based on current mode.\n\t */\n\tfunction scrollTo(item: HTMLElement, behavior: ScrollBehavior = scrollBehavior): void {\n\t\tif (mode === 'off') return;\n\n\t\tconst itemRect = item.getBoundingClientRect();\n\t\tconst viewport = getViewportRect(scrollContainer);\n\n\t\tif (mode === 'center') {\n\t\t\t// Center the item in the viewport\n\t\t\tconst targetScrollTop =\n\t\t\t\tscrollContainer === window\n\t\t\t\t\t? window.scrollY + itemRect.top - viewport.height / 2 + itemRect.height / 2\n\t\t\t\t\t: (scrollContainer as HTMLElement).scrollTop +\n\t\t\t\t\t\titemRect.top -\n\t\t\t\t\t\tviewport.top -\n\t\t\t\t\t\tviewport.height / 2 +\n\t\t\t\t\t\titemRect.height / 2;\n\n\t\t\tconst targetScrollLeft =\n\t\t\t\tscrollContainer === window\n\t\t\t\t\t? window.scrollX + itemRect.left - viewport.width / 2 + itemRect.width / 2\n\t\t\t\t\t: (scrollContainer as HTMLElement).scrollLeft +\n\t\t\t\t\t\titemRect.left -\n\t\t\t\t\t\tviewport.left -\n\t\t\t\t\t\tviewport.width / 2 +\n\t\t\t\t\t\titemRect.width / 2;\n\n\t\t\tif (scrollContainer === window) {\n\t\t\t\twindow.scrollTo({ top: targetScrollTop, left: targetScrollLeft, behavior });\n\t\t\t} else {\n\t\t\t\t(scrollContainer as HTMLElement).scrollTo({\n\t\t\t\t\ttop: targetScrollTop,\n\t\t\t\t\tleft: targetScrollLeft,\n\t\t\t\t\tbehavior,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t// 'contain' mode - use CSS scroll-margin with scrollIntoView\n\t\t\t// The scroll-margin should be set in CSS on items (or we set it here)\n\t\t\t// This lets the browser handle all the positioning math\n\n\t\t\titem.scrollIntoView({\n\t\t\t\tbehavior,\n\t\t\t\tblock: 'nearest',\n\t\t\t\tinline: 'nearest',\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Calculate scroll velocity based on pointer position relative to edges.\n\t */\n\tfunction getEdgeScrollVelocity(\n\t\tpointerX: number,\n\t\tpointerY: number\n\t): { x: number; y: number } {\n\t\tconst viewport = getViewportRect(scrollContainer);\n\t\tlet velocityX = 0;\n\t\tlet velocityY = 0;\n\n\t\t// Pointer position relative to viewport\n\t\tconst relativeX = pointerX - viewport.left;\n\t\tconst relativeY = pointerY - viewport.top;\n\n\t\t// Check horizontal edges\n\t\tif (relativeX < edgeSize) {\n\t\t\t// Near left edge - scroll left (negative)\n\t\t\tvelocityX = -scrollSpeed * (1 - relativeX / edgeSize);\n\t\t} else if (relativeX > viewport.width - edgeSize) {\n\t\t\t// Near right edge - scroll right (positive)\n\t\t\tvelocityX = scrollSpeed * (1 - (viewport.width - relativeX) / edgeSize);\n\t\t}\n\n\t\t// Check vertical edges\n\t\tif (relativeY < edgeSize) {\n\t\t\t// Near top edge - scroll up (negative)\n\t\t\tvelocityY = -scrollSpeed * (1 - relativeY / edgeSize);\n\t\t} else if (relativeY > viewport.height - edgeSize) {\n\t\t\t// Near bottom edge - scroll down (positive)\n\t\t\tvelocityY = scrollSpeed * (1 - (viewport.height - relativeY) / edgeSize);\n\t\t}\n\n\t\treturn { x: velocityX, y: velocityY };\n\t}\n\n\t/**\n\t * Animation loop for edge scrolling during drag.\n\t */\n\tlet wasScrollingLastFrame = false;\n\n\tfunction scrollLoop(): void {\n\t\tif (!isDragging || !autoScrollOnDrag || mode === 'off') {\n\t\t\tanimationFrameId = null;\n\t\t\tif (wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(false);\n\t\t\t\twasScrollingLastFrame = false;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconst velocity = getEdgeScrollVelocity(lastPointerX, lastPointerY);\n\t\tconst isNearEdge = velocity.x !== 0 || velocity.y !== 0;\n\n\t\tif (isNearEdge) {\n\t\t\tif (!wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(true);\n\t\t\t}\n\t\t\twasScrollingLastFrame = true;\n\t\t\tif (scrollContainer === window) {\n\t\t\t\twindow.scrollBy(velocity.x, velocity.y);\n\t\t\t} else {\n\t\t\t\t(scrollContainer as HTMLElement).scrollLeft += velocity.x;\n\t\t\t\t(scrollContainer as HTMLElement).scrollTop += velocity.y;\n\t\t\t}\n\t\t} else {\n\t\t\t// Not near edge\n\t\t\tif (wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(false);\n\t\t\t\twasScrollingLastFrame = false;\n\t\t\t}\n\t\t}\n\n\t\tanimationFrameId = requestAnimationFrame(scrollLoop);\n\t}\n\n\t/**\n\t * Start the scroll loop.\n\t */\n\tfunction startScrollLoop(): void {\n\t\tif (animationFrameId === null) {\n\t\t\tanimationFrameId = requestAnimationFrame(scrollLoop);\n\t\t}\n\t}\n\n\t/**\n\t * Stop the scroll loop.\n\t */\n\tfunction stopScrollLoop(): void {\n\t\tif (animationFrameId !== null) {\n\t\t\tcancelAnimationFrame(animationFrameId);\n\t\t\tanimationFrameId = null;\n\t\t}\n\t\tsetScrolling(false);\n\t}\n\n\t// Track pointer position continuously during drag (not just on cell change)\n\tfunction onPointerMove(e: PointerEvent): void {\n\t\tif (!isDragging || !autoScrollOnDrag || mode === 'off') return;\n\n\t\tlastPointerX = e.clientX;\n\t\tlastPointerY = e.clientY;\n\t\tstartScrollLoop();\n\t}\n\n\t// Event handlers\n\tfunction onDragStart(e: CustomEvent<DragStartDetail>): void {\n\t\tisDragging = true;\n\t\tdragSource = e.detail.source;\n\t\t// Only listen for raw pointer moves during pointer drags (for edge-scroll detection)\n\t\tif (dragSource === 'pointer') {\n\t\t\twindow.addEventListener('pointermove', onPointerMove);\n\t\t}\n\t}\n\n\tfunction onDragMove(e: CustomEvent<DragMoveDetail>): void {\n\t\tif (mode === 'off') return;\n\n\t\tif (e.detail.source === 'pointer') {\n\t\t\t// Pointer drag: update position for edge detection\n\t\t\tlastPointerX = e.detail.x;\n\t\t\tlastPointerY = e.detail.y;\n\t\t} else {\n\t\t\t// Keyboard drag - scroll to keep item visible\n\t\t\t// Use requestAnimationFrame to let the DOM update first\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tscrollTo(e.detail.item, 'smooth');\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction onDragEnd(e: CustomEvent<DragEndDetail>): void {\n\t\tconst wasPointerDrag = dragSource === 'pointer';\n\t\tisDragging = false;\n\t\tdragSource = null;\n\t\tstopScrollLoop();\n\t\tif (wasPointerDrag) {\n\t\t\twindow.removeEventListener('pointermove', onPointerMove);\n\t\t}\n\n\t\t// For keyboard moves (nudge), scroll to keep item visible after it moves\n\t\t// Pointer drags handle their own scrolling via edge detection\n\t\tif (!wasPointerDrag && scrollOnSelect) {\n\t\t\t// Wait for layout to settle (view transitions may be animating)\n\t\t\t// Use setTimeout + rAF to ensure DOM has updated\n\t\t\tsetTimeout(() => {\n\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\tscrollTo(e.detail.item, 'smooth');\n\t\t\t\t});\n\t\t\t}, 100);\n\t\t}\n\t}\n\n\tfunction onDragCancel(e: CustomEvent<DragCancelDetail>): void {\n\t\tconst wasPointerDrag = dragSource === 'pointer';\n\t\tisDragging = false;\n\t\tdragSource = null;\n\t\tstopScrollLoop();\n\t\tif (wasPointerDrag) {\n\t\t\twindow.removeEventListener('pointermove', onPointerMove);\n\t\t}\n\t}\n\n\tfunction onSelect(e: CustomEvent<SelectDetail>): void {\n\t\tif (!scrollOnSelect || mode === 'off') return;\n\n\t\t// Don't scroll during drag - the drag handles its own scrolling\n\t\tif (isDragging) return;\n\n\t\tscrollTo(e.detail.item);\n\t}\n\n\tconst removeListeners = listenEvents(gridElement, {\n\t\t'egg-drag-start': onDragStart as EventListener,\n\t\t'egg-drag-move': onDragMove as EventListener,\n\t\t'egg-drag-end': onDragEnd as EventListener,\n\t\t'egg-drag-cancel': onDragCancel as EventListener,\n\t\t'egg-select': onSelect as EventListener,\n\t});\n\n\tfunction destroy(): void {\n\t\tstopScrollLoop();\n\t\tremoveListeners();\n\t}\n\n\treturn {\n\t\tsetMode(newMode: CameraMode): void {\n\t\t\tmode = newMode;\n\t\t\tif (mode === 'off') {\n\t\t\t\tstopScrollLoop();\n\t\t\t}\n\t\t},\n\t\tgetMode(): CameraMode {\n\t\t\treturn mode;\n\t\t},\n\t\tscrollTo,\n\t\tstop: stopScrollLoop,\n\t\tdestroy,\n\t};\n}\n\n"],"mappings":"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"}