{"version":3,"file":"placeholder.min.js","names":[],"sources":["../engine.ts","../plugins/placeholder.ts"],"sourcesContent":["import type { GridCell, EggCore, InitOptions, StyleManager } from './types';\nimport { createStateMachine } from './state-machine';\nimport { attachPointer } from './plugins/pointer';\nimport { attachKeyboard } from './plugins/keyboard';\nimport { attachAccessibility } from './plugins/accessibility';\nimport { attachResize } from './plugins/resize';\nimport { attachCamera } from './plugins/camera';\nimport { attachPlaceholder } from './plugins/placeholder';\nimport { attachPushAlgorithm } from './plugins/algorithm-push';\nimport { attachReorderAlgorithm } from './plugins/algorithm-reorder';\nimport { attachResponsive } from './plugins/responsive';\n\n/**\n * Initialize EG Grid on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): EggCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\t// Create centralized state machine\n\tconst stateMachine = createStateMachine();\n\n\t// Track selected element (state machine stores itemId, we need the element)\n\tlet selectedElement: HTMLElement | null = null;\n\n\t// StyleManager: single style element, multiple named layers\n\tconst styleLayers = new Map<string, string>(); // layer name → CSS\n\tconst layerOrder: string[] = []; // insertion order\n\tconst managedStyleElement = styleElement ?? document.createElement('style');\n\tif (!styleElement) {\n\t\tdocument.head.appendChild(managedStyleElement);\n\t\tcleanups.push(() => managedStyleElement.remove());\n\t}\n\n\t// Pre-populate 'base' layer with any existing content (e.g. server-rendered CSS)\n\tconst existingCSS = managedStyleElement.textContent?.trim();\n\tif (existingCSS) {\n\t\tstyleLayers.set('base', existingCSS);\n\t\tlayerOrder.push('base');\n\t}\n\n\tconst styles: StyleManager = {\n\t\tset(layer: string, css: string): void {\n\t\t\tif (!styleLayers.has(layer)) {\n\t\t\t\tlayerOrder.push(layer);\n\t\t\t}\n\t\t\tstyleLayers.set(layer, css);\n\t\t},\n\t\tget(layer: string): string {\n\t\t\treturn styleLayers.get(layer) ?? '';\n\t\t},\n\t\tclear(layer: string): void {\n\t\t\tif (styleLayers.has(layer)) {\n\t\t\t\tstyleLayers.set(layer, '');\n\t\t\t}\n\t\t},\n\t\tcommit(): void {\n\t\t\tconst parts: string[] = [];\n\t\t\tfor (const layer of layerOrder) {\n\t\t\t\tconst css = styleLayers.get(layer);\n\t\t\t\tif (css) parts.push(css);\n\t\t\t}\n\t\t\tmanagedStyleElement.textContent = parts.join('\\n\\n');\n\t\t},\n\t};\n\n\tconst core: EggCore = {\n\t\telement,\n\t\tstateMachine,\n\t\tstyles,\n\t\tcameraScrolling: false,\n\n\t\t// Selection state (backed by state machine)\n\t\tget selectedItem() {\n\t\t\treturn selectedElement;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedElement) return;\n\n\t\t\tconst previousItem = selectedElement;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-egg-selected');\n\t\t\t}\n\n\t\t\t// Update state machine and local element reference\n\t\t\tif (item) {\n\t\t\t\tconst itemId = item.id || item.getAttribute('data-egg-item') || '';\n\t\t\t\tstateMachine.transition({ type: 'SELECT', itemId, element: item });\n\t\t\t\tselectedElement = item;\n\t\t\t\titem.setAttribute('data-egg-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else {\n\t\t\t\tstateMachine.transition({ type: 'DESELECT' });\n\t\t\t\tselectedElement = null;\n\t\t\t\tif (previousItem) {\n\t\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`egg-${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Direct initialization — no registry, no loop\n\tif (options.pointer !== false) {\n\t\tcleanups.push(attachPointer(core));\n\t}\n\tif (options.keyboard !== false) {\n\t\tcleanups.push(attachKeyboard(core));\n\t}\n\tif (options.accessibility !== false) {\n\t\tcleanups.push(attachAccessibility(core));\n\t}\n\n\tif (options.resize !== false) {\n\t\tconst resizeOpts = typeof options.resize === 'object' ? options.resize : {};\n\t\tconst inst = attachResize(element, { ...resizeOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.camera !== false) {\n\t\tconst cameraOpts = typeof options.camera === 'object' ? options.camera : {};\n\t\tconst inst = attachCamera(element, { ...cameraOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.placeholder !== false) {\n\t\tconst placeholderOpts = typeof options.placeholder === 'object' ? options.placeholder : {};\n\t\tconst inst = attachPlaceholder(element, placeholderOpts);\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\t// Algorithm: push (default) or reorder\n\tif (options.algorithm !== false) {\n\t\tconst algoOpts = options.algorithmOptions ?? {};\n\t\tif (options.algorithm === 'reorder') {\n\t\t\tcleanups.push(attachReorderAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t} else {\n\t\t\tcleanups.push(attachPushAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t}\n\t}\n\n\tif (options.responsive) {\n\t\tcleanups.push(attachResponsive(element, options.responsive, core));\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Get the size of an item from its data attributes\n */\nexport function getItemSize(item: HTMLElement): { colspan: number; rowspan: number } {\n\treturn {\n\t\tcolspan: parseInt(item.getAttribute('data-egg-colspan') || '1', 10) || 1,\n\t\trowspan: parseInt(item.getAttribute('data-egg-rowspan') || '1', 10) || 1,\n\t};\n}\n\n/**\n * Attach multiple event listeners and return a cleanup function to remove them all\n */\nexport function listenEvents(\n\telement: EventTarget,\n\tevents: Record<string, EventListenerOrEventListenerObject>,\n): () => void {\n\tfor (const [name, handler] of Object.entries(events)) {\n\t\telement.addEventListener(name, handler);\n\t}\n\treturn () => {\n\t\tfor (const [name, handler] of Object.entries(events)) {\n\t\t\telement.removeEventListener(name, handler);\n\t\t}\n\t};\n}\n","/**\n * Placeholder plugin for EG Grid\n *\n * Shows a visual placeholder where the dragged item will land.\n * Handles creation, positioning, and cleanup automatically.\n */\n\nimport { listenEvents } from '../engine';\nimport type {\n\tDragStartDetail,\n\tDragMoveDetail,\n\tDragEndDetail,\n\tDragCancelDetail,\n\tDropPreviewDetail,\n\tResizeStartDetail,\n\tResizeMoveDetail,\n\tResizeEndDetail,\n\tResizeCancelDetail,\n} from '../types';\n\nexport interface PlaceholderOptions {\n\t/**\n\t * CSS class name for the placeholder element.\n\t * @default 'egg-placeholder'\n\t */\n\tclassName?: string;\n\n\t/**\n\t * Custom element to use as placeholder instead of creating one.\n\t * If provided, className is ignored.\n\t */\n\telement?: HTMLElement;\n\n\t/**\n\t * Whether to disable view-transition-name on the placeholder.\n\t * Set to true to prevent the placeholder from animating with View Transitions.\n\t * @default true\n\t */\n\tdisableViewTransition?: boolean;\n}\n\nexport interface PlaceholderInstance {\n\t/** Manually show the placeholder at a position */\n\tshow(column: number, row: number, colspan?: number, rowspan?: number): void;\n\t/** Manually hide the placeholder */\n\thide(): void;\n\t/** Remove event listeners and clean up */\n\tdestroy(): void;\n}\n\n/**\n * Attach a placeholder to a EG Grid grid element.\n *\n * @example\n * ```js\n * import { init } from './eg-grid.js';\n * import { attachPlaceholder } from './placeholder.js';\n *\n * const grid = init(document.getElementById('grid'));\n * const placeholder = attachPlaceholder(grid.element);\n *\n * // Later, to clean up:\n * placeholder.destroy();\n * ```\n */\nexport function attachPlaceholder(\n\tgridElement: HTMLElement,\n\toptions: PlaceholderOptions = {}\n): PlaceholderInstance {\n\tconst {\n\t\tclassName = 'egg-placeholder',\n\t\telement: customElement,\n\t\tdisableViewTransition = true,\n\t} = options;\n\n\tlet placeholder: HTMLElement | null = null;\n\tlet isCustomElement = false;\n\n\tfunction create(): void {\n\t\tif (placeholder) return;\n\n\t\tif (customElement) {\n\t\t\tplaceholder = customElement;\n\t\t\tisCustomElement = true;\n\t\t} else {\n\t\t\tplaceholder = document.createElement('div');\n\t\t\tplaceholder.className = className;\n\t\t}\n\n\t\t// Prevent placeholder from interfering with pointer events\n\t\tplaceholder.style.pointerEvents = 'none';\n\n\t\t// Disable view transitions on placeholder to prevent animation artifacts\n\t\tif (disableViewTransition) {\n\t\t\tplaceholder.style.viewTransitionName = 'none';\n\t\t}\n\n\t\tgridElement.appendChild(placeholder);\n\t}\n\n\tfunction update(\n\t\tcolumn: number,\n\t\trow: number,\n\t\tcolspan: number = 1,\n\t\trowspan: number = 1\n\t): void {\n\t\tif (!placeholder) return;\n\t\tplaceholder.style.gridColumn = `${column} / span ${colspan}`;\n\t\tplaceholder.style.gridRow = `${row} / span ${rowspan}`;\n\t}\n\n\tfunction remove(): void {\n\t\tif (placeholder) {\n\t\t\tplaceholder.remove();\n\t\t\t// Only null out if we created it; keep reference if custom\n\t\t\tif (!isCustomElement) {\n\t\t\t\tplaceholder = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Event handlers\n\tfunction handleDragStart(e: CustomEvent<DragStartDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tcreate();\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleDragMove(e: CustomEvent<DragMoveDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\t// Algorithm plugins (e.g. reorder) emit drop-preview when the actual\n\t// landing position differs from the raw pointer cell. Override the\n\t// placeholder position so it shows where the item will really land.\n\tfunction handleDropPreview(e: CustomEvent<DropPreviewDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleDragEnd(_e: CustomEvent<DragEndDetail>): void {\n\t\tremove();\n\t}\n\n\tfunction handleDragCancel(_e: CustomEvent<DragCancelDetail>): void {\n\t\tremove();\n\t}\n\n\t// Resize event handlers\n\t// The placeholder shows where the item will land after resize. For handles that\n\t// change position (NW, NE, SW, N, W), the cell position changes but the anchor\n\t// corner stays fixed. This is correct - the placeholder shows the final landing spot.\n\tfunction handleResizeStart(e: CustomEvent<ResizeStartDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tcreate();\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleResizeMove(e: CustomEvent<ResizeMoveDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleResizeEnd(_e: CustomEvent<ResizeEndDetail>): void {\n\t\tremove();\n\t}\n\n\tfunction handleResizeCancel(_e: CustomEvent<ResizeCancelDetail>): void {\n\t\tremove();\n\t}\n\n\t// Fallback cleanup for edge cases (pointer released outside window, etc.)\n\tfunction handlePointerUp(): void {\n\t\trequestAnimationFrame(() => {\n\t\t\tif (\n\t\t\t\tplaceholder &&\n\t\t\t\t!document.querySelector('[data-egg-dragging]') &&\n\t\t\t\t!document.querySelector('[data-egg-resizing]')\n\t\t\t) {\n\t\t\t\tremove();\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction handlePointerCancel(): void {\n\t\tremove();\n\t}\n\n\t// Attach listeners\n\tconst removeGridListeners = listenEvents(gridElement, {\n\t\t'egg-drag-start': handleDragStart as EventListener,\n\t\t'egg-drag-move': handleDragMove as EventListener,\n\t\t'egg-drag-end': handleDragEnd as EventListener,\n\t\t'egg-drag-cancel': handleDragCancel as EventListener,\n\t\t'egg-drop-preview': handleDropPreview as EventListener,\n\t\t'egg-resize-start': handleResizeStart as EventListener,\n\t\t'egg-resize-move': handleResizeMove as EventListener,\n\t\t'egg-resize-end': handleResizeEnd as EventListener,\n\t\t'egg-resize-cancel': handleResizeCancel as EventListener,\n\t});\n\tconst removeDocListeners = listenEvents(document, {\n\t\tpointerup: handlePointerUp,\n\t\tpointercancel: handlePointerCancel,\n\t});\n\n\t// Public API\n\treturn {\n\t\tshow(\n\t\t\tcolumn: number,\n\t\t\trow: number,\n\t\t\tcolspan: number = 1,\n\t\t\trowspan: number = 1\n\t\t): void {\n\t\t\tcreate();\n\t\t\tupdate(column, row, colspan, rowspan);\n\t\t},\n\n\t\thide(): void {\n\t\t\tremove();\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tremove();\n\t\t\tremoveGridListeners();\n\t\t\tremoveDocListeners();\n\t\t},\n\t};\n}\n\n"],"mappings":"AAiRA,SAAgB,EACf,EACA,EACa,CACb,IAAK,GAAM,CAAC,EAAM,KAAY,OAAO,QAAQ,EAAO,CACnD,EAAQ,iBAAiB,EAAM,EAAQ,CAExC,UAAa,CACZ,IAAK,GAAM,CAAC,EAAM,KAAY,OAAO,QAAQ,EAAO,CACnD,EAAQ,oBAAoB,EAAM,EAAQ,ECzN7C,SAAgB,EACf,EACA,EAA8B,EAAE,CACV,CACtB,GAAM,CACL,YAAY,kBACZ,QAAS,EACT,wBAAwB,IACrB,EAEA,EAAkC,KAClC,EAAkB,GAEtB,SAAS,GAAe,CACnB,IAEA,GACH,EAAc,EACd,EAAkB,KAElB,EAAc,SAAS,cAAc,MAAM,CAC3C,EAAY,UAAY,GAIzB,EAAY,MAAM,cAAgB,OAG9B,IACH,EAAY,MAAM,mBAAqB,QAGxC,EAAY,YAAY,EAAY,EAGrC,SAAS,EACR,EACA,EACA,EAAkB,EAClB,EAAkB,EACX,CACF,IACL,EAAY,MAAM,WAAa,GAAG,EAAO,UAAU,IACnD,EAAY,MAAM,QAAU,GAAG,EAAI,UAAU,KAG9C,SAAS,GAAe,CACnB,IACH,EAAY,QAAQ,CAEf,IACJ,EAAc,OAMjB,SAAS,EAAgB,EAAuC,CAC/D,GAAM,CAAE,OAAM,UAAS,WAAY,EAAE,OACrC,GAAQ,CACR,EAAO,EAAK,OAAQ,EAAK,IAAK,EAAS,EAAQ,CAGhD,SAAS,EAAe,EAAsC,CAC7D,GAAM,CAAE,OAAM,UAAS,WAAY,EAAE,OACrC,EAAO,EAAK,OAAQ,EAAK,IAAK,EAAS,EAAQ,CAMhD,SAAS,EAAkB,EAAyC,CACnE,GAAM,CAAE,OAAM,UAAS,WAAY,EAAE,OACrC,EAAO,EAAK,OAAQ,EAAK,IAAK,EAAS,EAAQ,CAGhD,SAAS,EAAc,EAAsC,CAC5D,GAAQ,CAGT,SAAS,EAAiB,EAAyC,CAClE,GAAQ,CAOT,SAAS,EAAkB,EAAyC,CACnE,GAAM,CAAE,OAAM,UAAS,WAAY,EAAE,OACrC,GAAQ,CACR,EAAO,EAAK,OAAQ,EAAK,IAAK,EAAS,EAAQ,CAGhD,SAAS,EAAiB,EAAwC,CACjE,GAAM,CAAE,OAAM,UAAS,WAAY,EAAE,OACrC,EAAO,EAAK,OAAQ,EAAK,IAAK,EAAS,EAAQ,CAGhD,SAAS,EAAgB,EAAwC,CAChE,GAAQ,CAGT,SAAS,EAAmB,EAA2C,CACtE,GAAQ,CAIT,SAAS,GAAwB,CAChC,0BAA4B,CAE1B,GACA,CAAC,SAAS,cAAc,sBAAsB,EAC9C,CAAC,SAAS,cAAc,sBAAsB,EAE9C,GAAQ,EAER,CAGH,SAAS,GAA4B,CACpC,GAAQ,CAIT,IAAM,EAAsB,EAAa,EAAa,CACrD,iBAAkB,EAClB,gBAAiB,EACjB,eAAgB,EAChB,kBAAmB,EACnB,mBAAoB,EACpB,mBAAoB,EACpB,kBAAmB,EACnB,iBAAkB,EAClB,oBAAqB,EACrB,CAAC,CACI,EAAqB,EAAa,SAAU,CACjD,UAAW,EACX,cAAe,EACf,CAAC,CAGF,MAAO,CACN,KACC,EACA,EACA,EAAkB,EAClB,EAAkB,EACX,CACP,GAAQ,CACR,EAAO,EAAQ,EAAK,EAAS,EAAQ,EAGtC,MAAa,CACZ,GAAQ,EAGT,SAAgB,CACf,GAAQ,CACR,GAAqB,CACrB,GAAoB,EAErB"}