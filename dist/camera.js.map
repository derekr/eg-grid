{
  "version": 3,
  "sources": ["../engine.ts", "../plugins/camera.ts"],
  "sourcesContent": ["import type { GridCell, GridiotCore, InitOptions, Plugin, PluginOptions, ProviderRegistry } from './types';\n\n// Global plugin registry\nconst plugins = new Map<string, Plugin>();\n\nexport function registerPlugin(plugin: Plugin): void {\n\tplugins.set(plugin.name, plugin);\n}\n\nexport function getPlugin(name: string): Plugin | undefined {\n\treturn plugins.get(name);\n}\n\n/**\n * Initialize Gridiot on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options including layoutModel, styleElement, and plugin options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): GridiotCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t\tplugins: pluginOptions = {},\n\t\tdisablePlugins = [],\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\tlet selectedItem: HTMLElement | null = null;\n\n\t// Provider registry for inter-plugin communication\n\tconst providerMap = new Map<string, () => unknown>();\n\tconst providers: ProviderRegistry = {\n\t\tregister<T>(capability: string, provider: () => T): void {\n\t\t\tif (providerMap.has(capability)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Gridiot: Provider for \"${capability}\" already registered, overwriting`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tproviderMap.set(capability, provider);\n\t\t},\n\n\t\tget<T>(capability: string): T | undefined {\n\t\t\tconst provider = providerMap.get(capability);\n\t\t\treturn provider ? (provider() as T) : undefined;\n\t\t},\n\n\t\thas(capability: string): boolean {\n\t\t\treturn providerMap.has(capability);\n\t\t},\n\t};\n\n\tconst core: GridiotCore = {\n\t\telement,\n\t\tproviders,\n\n\t\t// Selection state\n\t\tget selectedItem() {\n\t\t\treturn selectedItem;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedItem) return;\n\n\t\t\tconst previousItem = selectedItem;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-gridiot-selected');\n\t\t\t}\n\n\t\t\t// Set new selection\n\t\t\tselectedItem = item;\n\n\t\t\tif (item) {\n\t\t\t\titem.setAttribute('data-gridiot-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else if (previousItem) {\n\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`gridiot:${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tobserver.disconnect();\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Observe position changes and animate with View Transitions\n\tconst observer = new MutationObserver((mutations) => {\n\t\t// Collect items that changed position\n\t\tconst changedItems = new Set<HTMLElement>();\n\n\t\tfor (const mutation of mutations) {\n\t\t\tif (\n\t\t\t\tmutation.type === 'attributes' &&\n\t\t\t\tmutation.target instanceof HTMLElement\n\t\t\t) {\n\t\t\t\tconst item = mutation.target.closest(\n\t\t\t\t\t'[data-gridiot-item]',\n\t\t\t\t) as HTMLElement | null;\n\t\t\t\tif (item && element.contains(item)) {\n\t\t\t\t\tchangedItems.add(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Animate changes with View Transitions if available\n\t\tif (changedItems.size > 0 && 'startViewTransition' in document) {\n\t\t\t// Items already moved - View Transitions will handle animation\n\t\t\t// The browser captures before/after states automatically\n\t\t}\n\t});\n\n\tobserver.observe(element, {\n\t\tsubtree: true,\n\t\tattributes: true,\n\t\tattributeFilter: ['style', 'class'],\n\t});\n\n\t// Initialize all registered plugins with options\n\tfor (const plugin of plugins.values()) {\n\t\t// Skip disabled plugins\n\t\tif (disablePlugins.includes(plugin.name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Build options for this plugin\n\t\tconst pluginSpecificOptions = pluginOptions[plugin.name as keyof PluginOptions] ?? {};\n\t\tconst opts = {\n\t\t\t...pluginSpecificOptions,\n\t\t\t// Pass shared resources to all plugins that might need them\n\t\t\tlayoutModel,\n\t\t\tstyleElement,\n\t\t\tcore,\n\t\t};\n\n\t\tconst cleanup = plugin.init(core, opts);\n\t\tif (cleanup) {\n\t\t\tcleanups.push(cleanup);\n\t\t}\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Set an item's grid position\n */\nexport function setItemCell(item: HTMLElement, cell: GridCell): void {\n\titem.style.gridColumn = String(cell.column);\n\titem.style.gridRow = String(cell.row);\n}\n\n/**\n * Get grid info for a grid element\n */\nexport function getGridInfo(element: HTMLElement) {\n\tconst rect = element.getBoundingClientRect();\n\tconst style = getComputedStyle(element);\n\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\tconst columnGap = parseFloat(style.columnGap) || 0;\n\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\treturn {\n\t\trect,\n\t\tcolumns,\n\t\trows,\n\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\tcellWidth: columns[0] || 0,\n\t\tcellHeight: rows[0] || 0,\n\t};\n}\n", "/**\n * Camera plugin for Gridiot\n *\n * Handles viewport scrolling to keep the active item visible:\n * - Auto-scroll when dragging near viewport edges\n * - Scroll into view when selecting items via keyboard\n *\n * The \"active item\" is: the dragged item during drag, or the selected item otherwise.\n */\n\nimport { registerPlugin } from '../engine';\nimport type {\n\tDragStartDetail,\n\tDragMoveDetail,\n\tDragEndDetail,\n\tDragCancelDetail,\n\tSelectDetail,\n\tDragState,\n\tGridiotCore,\n\tCameraPluginOptions,\n} from '../types';\n\nexport type CameraMode = 'contain' | 'center' | 'off';\n\nexport interface CameraOptions {\n\t/**\n\t * Scroll behavior mode:\n\t * - 'contain': Only scroll when item would leave viewport (default)\n\t * - 'center': Keep active item centered (can feel jarring)\n\t * - 'off': Disable camera scrolling\n\t */\n\tmode?: CameraMode;\n\n\t/**\n\t * The scrollable container. Defaults to the grid's scroll parent.\n\t * Pass `window` to scroll the document.\n\t */\n\tscrollContainer?: HTMLElement | Window;\n\n\t/**\n\t * Size of edge zones that trigger auto-scroll during drag (in pixels).\n\t * @default 60\n\t */\n\tedgeSize?: number;\n\n\t/**\n\t * Maximum scroll speed in pixels per frame.\n\t * @default 15\n\t */\n\tscrollSpeed?: number;\n\n\t/**\n\t * Scroll behavior for selection changes.\n\t * @default 'smooth'\n\t */\n\tscrollBehavior?: ScrollBehavior;\n\n\t/**\n\t * Margin around item when scrolling into view (in pixels).\n\t * @default 20\n\t */\n\tscrollMargin?: number;\n\n\t/**\n\t * Whether to scroll on selection changes (keyboard nav).\n\t * @default true\n\t */\n\tscrollOnSelect?: boolean;\n\n\t/**\n\t * Whether to auto-scroll during drag.\n\t * @default true\n\t */\n\tautoScrollOnDrag?: boolean;\n\n\t/**\n\t * Time in ms after scrolling stops before considered \"settled\".\n\t * Other plugins can check isScrolling() to defer updates.\n\t * @default 150\n\t */\n\tsettleDelay?: number;\n\n\t/**\n\t * Gridiot core instance for provider registration.\n\t * If provided, registers a 'camera' provider.\n\t */\n\tcore?: GridiotCore;\n}\n\n/**\n * Camera state exposed via provider registry.\n */\nexport interface CameraState {\n\t/** Whether the camera is actively auto-scrolling */\n\tisScrolling: boolean;\n\t/** Current camera mode */\n\tmode: CameraMode;\n}\n\nexport interface CameraInstance {\n\t/** Change the camera mode */\n\tsetMode(mode: CameraMode): void;\n\t/** Get current mode */\n\tgetMode(): CameraMode;\n\t/** Manually scroll an item into view */\n\tscrollTo(item: HTMLElement, behavior?: ScrollBehavior): void;\n\t/** Stop any active auto-scrolling */\n\tstop(): void;\n\t/** Clean up and remove event listeners */\n\tdestroy(): void;\n}\n\n/**\n * Find the nearest scrollable ancestor of an element.\n */\nfunction findScrollParent(element: HTMLElement): HTMLElement | Window {\n\tlet parent = element.parentElement;\n\n\twhile (parent) {\n\t\tconst style = getComputedStyle(parent);\n\t\tconst overflowY = style.overflowY;\n\t\tconst overflowX = style.overflowX;\n\n\t\tif (\n\t\t\toverflowY === 'auto' ||\n\t\t\toverflowY === 'scroll' ||\n\t\t\toverflowX === 'auto' ||\n\t\t\toverflowX === 'scroll'\n\t\t) {\n\t\t\treturn parent;\n\t\t}\n\n\t\tparent = parent.parentElement;\n\t}\n\n\treturn window;\n}\n\n/**\n * Get viewport rect for a scroll container.\n */\nfunction getViewportRect(\n\tcontainer: HTMLElement | Window\n): { top: number; left: number; width: number; height: number } {\n\tif (container === window) {\n\t\treturn {\n\t\t\ttop: 0,\n\t\t\tleft: 0,\n\t\t\twidth: window.innerWidth,\n\t\t\theight: window.innerHeight,\n\t\t};\n\t}\n\tconst rect = (container as HTMLElement).getBoundingClientRect();\n\treturn {\n\t\ttop: rect.top,\n\t\tleft: rect.left,\n\t\twidth: rect.width,\n\t\theight: rect.height,\n\t};\n}\n\n/**\n * Attach camera behavior to a Gridiot grid element.\n */\nexport function attachCamera(\n\tgridElement: HTMLElement,\n\toptions: CameraOptions = {}\n): CameraInstance {\n\tconst {\n\t\tmode: initialMode = 'contain',\n\t\tscrollContainer: customContainer,\n\t\tedgeSize = 60,\n\t\tscrollSpeed = 15,\n\t\tscrollBehavior = 'smooth',\n\t\tscrollMargin = 20,\n\t\tscrollOnSelect = true,\n\t\tautoScrollOnDrag = true,\n\t\tsettleDelay = 150,\n\t\tcore,\n\t} = options;\n\n\tlet mode = initialMode;\n\tlet scrollContainer = customContainer ?? findScrollParent(gridElement);\n\tlet animationFrameId: number | null = null;\n\tlet isDragging = false;\n\tlet sawPointerMove = false; // Track if we actually saw pointer movement\n\tlet lastPointerX = 0;\n\tlet lastPointerY = 0;\n\tlet isScrolling = false;\n\tlet settleTimeoutId: ReturnType<typeof setTimeout> | null = null;\n\n\t// Register provider if core is provided\n\tif (core) {\n\t\tcore.providers.register<CameraState>('camera', () => ({\n\t\t\tisScrolling,\n\t\t\tmode,\n\t\t}));\n\t}\n\n\t/**\n\t * Mark scrolling as active, with settle timeout.\n\t */\n\tfunction setScrolling(active: boolean): void {\n\t\tif (active) {\n\t\t\tisScrolling = true;\n\t\t\tif (settleTimeoutId) {\n\t\t\t\tclearTimeout(settleTimeoutId);\n\t\t\t\tsettleTimeoutId = null;\n\t\t\t}\n\t\t} else {\n\t\t\t// Start settle timer\n\t\t\tif (settleTimeoutId) clearTimeout(settleTimeoutId);\n\t\t\tsettleTimeoutId = setTimeout(() => {\n\t\t\t\tisScrolling = false;\n\t\t\t\tsettleTimeoutId = null;\n\t\t\t\t// Emit settle event so algorithm can recalculate\n\t\t\t\tgridElement.dispatchEvent(\n\t\t\t\t\tnew CustomEvent('gridiot:camera-settled', { bubbles: true })\n\t\t\t\t);\n\t\t\t}, settleDelay);\n\t\t}\n\t}\n\n\t/**\n\t * Scroll an item into view based on current mode.\n\t */\n\tfunction scrollTo(item: HTMLElement, behavior: ScrollBehavior = scrollBehavior): void {\n\t\tif (mode === 'off') return;\n\n\t\tconst itemRect = item.getBoundingClientRect();\n\t\tconst viewport = getViewportRect(scrollContainer);\n\n\t\tif (mode === 'center') {\n\t\t\t// Center the item in the viewport\n\t\t\tconst targetScrollTop =\n\t\t\t\tscrollContainer === window\n\t\t\t\t\t? window.scrollY + itemRect.top - viewport.height / 2 + itemRect.height / 2\n\t\t\t\t\t: (scrollContainer as HTMLElement).scrollTop +\n\t\t\t\t\t\titemRect.top -\n\t\t\t\t\t\tviewport.top -\n\t\t\t\t\t\tviewport.height / 2 +\n\t\t\t\t\t\titemRect.height / 2;\n\n\t\t\tconst targetScrollLeft =\n\t\t\t\tscrollContainer === window\n\t\t\t\t\t? window.scrollX + itemRect.left - viewport.width / 2 + itemRect.width / 2\n\t\t\t\t\t: (scrollContainer as HTMLElement).scrollLeft +\n\t\t\t\t\t\titemRect.left -\n\t\t\t\t\t\tviewport.left -\n\t\t\t\t\t\tviewport.width / 2 +\n\t\t\t\t\t\titemRect.width / 2;\n\n\t\t\tif (scrollContainer === window) {\n\t\t\t\twindow.scrollTo({ top: targetScrollTop, left: targetScrollLeft, behavior });\n\t\t\t} else {\n\t\t\t\t(scrollContainer as HTMLElement).scrollTo({\n\t\t\t\t\ttop: targetScrollTop,\n\t\t\t\t\tleft: targetScrollLeft,\n\t\t\t\t\tbehavior,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t// 'contain' mode - use CSS scroll-margin with scrollIntoView\n\t\t\t// The scroll-margin should be set in CSS on items (or we set it here)\n\t\t\t// This lets the browser handle all the positioning math\n\n\t\t\titem.scrollIntoView({\n\t\t\t\tbehavior,\n\t\t\t\tblock: 'nearest',\n\t\t\t\tinline: 'nearest',\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Calculate scroll velocity based on pointer position relative to edges.\n\t */\n\tfunction getEdgeScrollVelocity(\n\t\tpointerX: number,\n\t\tpointerY: number\n\t): { x: number; y: number } {\n\t\tconst viewport = getViewportRect(scrollContainer);\n\t\tlet velocityX = 0;\n\t\tlet velocityY = 0;\n\n\t\t// Pointer position relative to viewport\n\t\tconst relativeX = pointerX - viewport.left;\n\t\tconst relativeY = pointerY - viewport.top;\n\n\t\t// Check horizontal edges\n\t\tif (relativeX < edgeSize) {\n\t\t\t// Near left edge - scroll left (negative)\n\t\t\tvelocityX = -scrollSpeed * (1 - relativeX / edgeSize);\n\t\t} else if (relativeX > viewport.width - edgeSize) {\n\t\t\t// Near right edge - scroll right (positive)\n\t\t\tvelocityX = scrollSpeed * (1 - (viewport.width - relativeX) / edgeSize);\n\t\t}\n\n\t\t// Check vertical edges\n\t\tif (relativeY < edgeSize) {\n\t\t\t// Near top edge - scroll up (negative)\n\t\t\tvelocityY = -scrollSpeed * (1 - relativeY / edgeSize);\n\t\t} else if (relativeY > viewport.height - edgeSize) {\n\t\t\t// Near bottom edge - scroll down (positive)\n\t\t\tvelocityY = scrollSpeed * (1 - (viewport.height - relativeY) / edgeSize);\n\t\t}\n\n\t\treturn { x: velocityX, y: velocityY };\n\t}\n\n\t/**\n\t * Animation loop for edge scrolling during drag.\n\t */\n\tlet wasScrollingLastFrame = false;\n\n\tfunction scrollLoop(): void {\n\t\tif (!isDragging || !autoScrollOnDrag || mode === 'off') {\n\t\t\tanimationFrameId = null;\n\t\t\tif (wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(false);\n\t\t\t\twasScrollingLastFrame = false;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconst velocity = getEdgeScrollVelocity(lastPointerX, lastPointerY);\n\t\tconst isNearEdge = velocity.x !== 0 || velocity.y !== 0;\n\n\t\tif (isNearEdge) {\n\t\t\tif (!wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(true);\n\t\t\t}\n\t\t\twasScrollingLastFrame = true;\n\t\t\tif (scrollContainer === window) {\n\t\t\t\twindow.scrollBy(velocity.x, velocity.y);\n\t\t\t} else {\n\t\t\t\t(scrollContainer as HTMLElement).scrollLeft += velocity.x;\n\t\t\t\t(scrollContainer as HTMLElement).scrollTop += velocity.y;\n\t\t\t}\n\t\t} else {\n\t\t\t// Not near edge\n\t\t\tif (wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(false);\n\t\t\t\twasScrollingLastFrame = false;\n\t\t\t}\n\t\t}\n\n\t\tanimationFrameId = requestAnimationFrame(scrollLoop);\n\t}\n\n\t/**\n\t * Start the scroll loop.\n\t */\n\tfunction startScrollLoop(): void {\n\t\tif (animationFrameId === null) {\n\t\t\tanimationFrameId = requestAnimationFrame(scrollLoop);\n\t\t}\n\t}\n\n\t/**\n\t * Stop the scroll loop.\n\t */\n\tfunction stopScrollLoop(): void {\n\t\tif (animationFrameId !== null) {\n\t\t\tcancelAnimationFrame(animationFrameId);\n\t\t\tanimationFrameId = null;\n\t\t}\n\t\tsetScrolling(false);\n\t}\n\n\t// Track pointer position continuously during drag (not just on cell change)\n\tfunction onPointerMove(e: PointerEvent): void {\n\t\tif (!isDragging || !autoScrollOnDrag || mode === 'off') return;\n\n\t\tsawPointerMove = true;\n\t\tlastPointerX = e.clientX;\n\t\tlastPointerY = e.clientY;\n\t\tstartScrollLoop();\n\t}\n\n\t// Event handlers\n\tfunction onDragStart(e: CustomEvent<DragStartDetail>): void {\n\t\tisDragging = true;\n\t\tsawPointerMove = false; // Reset - will be set true if pointer actually moves\n\t\t// Start listening for pointer moves on window to track edge proximity\n\t\twindow.addEventListener('pointermove', onPointerMove);\n\t}\n\n\tfunction onDragMove(e: CustomEvent<DragMoveDetail>): void {\n\t\tif (mode === 'off') return;\n\n\t\t// For pointer drag: update position for edge detection\n\t\tif (e.detail.x !== 0 || e.detail.y !== 0) {\n\t\t\tlastPointerX = e.detail.x;\n\t\t\tlastPointerY = e.detail.y;\n\t\t} else {\n\t\t\t// Keyboard drag (x/y are 0) - scroll to keep item visible\n\t\t\t// Use requestAnimationFrame to let the DOM update first\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tscrollTo(e.detail.item, 'smooth');\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction onDragEnd(e: CustomEvent<DragEndDetail>): void {\n\t\tconst wasPointerDrag = sawPointerMove; // Only true if pointer actually moved\n\t\tisDragging = false;\n\t\tsawPointerMove = false;\n\t\tstopScrollLoop();\n\t\twindow.removeEventListener('pointermove', onPointerMove);\n\n\t\t// For keyboard moves (nudge), scroll to keep item visible after it moves\n\t\t// Pointer drags handle their own scrolling via edge detection\n\t\tif (!wasPointerDrag && scrollOnSelect) {\n\t\t\t// Wait for layout to settle (view transitions may be animating)\n\t\t\t// Use setTimeout + rAF to ensure DOM has updated\n\t\t\tsetTimeout(() => {\n\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\tscrollTo(e.detail.item, 'smooth');\n\t\t\t\t});\n\t\t\t}, 100);\n\t\t}\n\t}\n\n\tfunction onDragCancel(e: CustomEvent<DragCancelDetail>): void {\n\t\tisDragging = false;\n\t\tstopScrollLoop();\n\t\twindow.removeEventListener('pointermove', onPointerMove);\n\t}\n\n\tfunction onSelect(e: CustomEvent<SelectDetail>): void {\n\t\tif (!scrollOnSelect || mode === 'off') return;\n\n\t\t// Don't scroll during drag - the drag handles its own scrolling\n\t\tif (isDragging) return;\n\n\t\tscrollTo(e.detail.item);\n\t}\n\n\t// Attach event listeners\n\tgridElement.addEventListener(\n\t\t'gridiot:drag-start',\n\t\tonDragStart as EventListener\n\t);\n\tgridElement.addEventListener(\n\t\t'gridiot:drag-move',\n\t\tonDragMove as EventListener\n\t);\n\tgridElement.addEventListener('gridiot:drag-end', onDragEnd as EventListener);\n\tgridElement.addEventListener(\n\t\t'gridiot:drag-cancel',\n\t\tonDragCancel as EventListener\n\t);\n\tgridElement.addEventListener('gridiot:select', onSelect as EventListener);\n\n\tfunction destroy(): void {\n\t\tstopScrollLoop();\n\t\tgridElement.removeEventListener(\n\t\t\t'gridiot:drag-start',\n\t\t\tonDragStart as EventListener\n\t\t);\n\t\tgridElement.removeEventListener(\n\t\t\t'gridiot:drag-move',\n\t\t\tonDragMove as EventListener\n\t\t);\n\t\tgridElement.removeEventListener(\n\t\t\t'gridiot:drag-end',\n\t\t\tonDragEnd as EventListener\n\t\t);\n\t\tgridElement.removeEventListener(\n\t\t\t'gridiot:drag-cancel',\n\t\t\tonDragCancel as EventListener\n\t\t);\n\t\tgridElement.removeEventListener(\n\t\t\t'gridiot:select',\n\t\t\tonSelect as EventListener\n\t\t);\n\t}\n\n\treturn {\n\t\tsetMode(newMode: CameraMode): void {\n\t\t\tmode = newMode;\n\t\t\tif (mode === 'off') {\n\t\t\t\tstopScrollLoop();\n\t\t\t}\n\t\t},\n\t\tgetMode(): CameraMode {\n\t\t\treturn mode;\n\t\t},\n\t\tscrollTo,\n\t\tstop: stopScrollLoop,\n\t\tdestroy,\n\t};\n}\n\n// Register as a plugin for auto-initialization via init()\nregisterPlugin({\n\tname: 'camera',\n\tinit(core, options?: CameraPluginOptions & { core?: GridiotCore }) {\n\t\tconst instance = attachCamera(core.element, {\n\t\t\t...options,\n\t\t\tcore: options?.core ?? core,\n\t\t});\n\t\treturn () => instance.destroy();\n\t},\n});\n"],
  "mappings": "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",
  "names": []
}
