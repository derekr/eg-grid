{
  "version": 3,
  "sources": ["../state-machine.ts", "../engine.ts", "../plugins/accessibility.ts", "../plugins/keyboard.ts", "../utils/flip.ts", "../plugins/pointer.ts", "../plugins/camera.ts", "../plugins/resize.ts", "../plugins/placeholder.ts", "../plugins/algorithm-push-core.ts", "../plugins/algorithm-push.ts", "../plugins/responsive.ts", "../layout-model.ts"],
  "sourcesContent": ["/**\n * Centralized State Machine for Gridiot\n *\n * This module provides a single source of truth for interaction state,\n * replacing the distributed state management across plugins.\n *\n * Key invariants:\n * 1. Only ONE interaction can be active at a time (drag OR resize, not both)\n * 2. Column count is captured at interaction start and immutable during interaction\n * 3. CSS injection is coordinated through this state machine\n * 4. View Transitions are only used for keyboard interactions (not pointer/FLIP)\n */\n\nimport type { GridCell, ItemPosition } from './types';\n\n// ============================================================================\n// State Types\n// ============================================================================\n\nexport type InteractionMode = 'pointer' | 'keyboard';\n\nexport type InteractionType = 'drag' | 'resize';\n\nexport type GridiotPhase =\n\t| 'idle'\n\t| 'selected'\n\t| 'interacting'  // Active drag or resize\n\t| 'committing';  // Saving to layout model, clearing preview\n\nexport interface InteractionContext {\n\t/** The type of interaction (drag or resize) */\n\ttype: InteractionType;\n\t/** How the interaction was initiated */\n\tmode: InteractionMode;\n\t/** The item being interacted with */\n\titemId: string;\n\t/** The DOM element being interacted with */\n\telement: HTMLElement;\n\t/** Column count at interaction start (immutable during interaction) */\n\tcolumnCount: number;\n\t/** Original positions of all items at interaction start */\n\toriginalPositions: Map<string, ItemPosition>;\n\t/** Original sizes of all items at interaction start (for resize) */\n\toriginalSizes: Map<string, { width: number; height: number }>;\n\t/** Current target cell during interaction */\n\ttargetCell: GridCell;\n\t/** Current size during resize */\n\tcurrentSize: { colspan: number; rowspan: number };\n\t/** Whether FLIP animation should be used (pointer mode only) */\n\tuseFlip: boolean;\n\t/** Whether View Transitions should be used (keyboard mode only) */\n\tuseViewTransition: boolean;\n}\n\nexport interface GridiotState {\n\tphase: GridiotPhase;\n\tselectedItemId: string | null;\n\tinteraction: InteractionContext | null;\n\t/** Track if keyboard mode is active (Shift+G toggle) */\n\tkeyboardModeActive: boolean;\n}\n\n// ============================================================================\n// State Machine\n// ============================================================================\n\nexport type StateTransition =\n\t| { type: 'SELECT'; itemId: string; element: HTMLElement }\n\t| { type: 'DESELECT' }\n\t| { type: 'START_INTERACTION'; context: Omit<InteractionContext, 'useFlip' | 'useViewTransition'> }\n\t| { type: 'UPDATE_INTERACTION'; targetCell: GridCell; currentSize?: { colspan: number; rowspan: number } }\n\t| { type: 'COMMIT_INTERACTION' }\n\t| { type: 'CANCEL_INTERACTION' }\n\t| { type: 'FINISH_COMMIT' }\n\t| { type: 'TOGGLE_KEYBOARD_MODE' };\n\nexport type StateListener = (state: GridiotState, transition: StateTransition) => void;\n\nexport interface GridiotStateMachine {\n\tgetState(): GridiotState;\n\ttransition(action: StateTransition): GridiotState;\n\tsubscribe(listener: StateListener): () => void;\n\t/** Check if a transition is valid from current state */\n\tcanTransition(action: StateTransition): boolean;\n}\n\n/**\n * Create the initial state\n */\nexport function createInitialState(): GridiotState {\n\treturn {\n\t\tphase: 'idle',\n\t\tselectedItemId: null,\n\t\tinteraction: null,\n\t\tkeyboardModeActive: false,\n\t};\n}\n\n/**\n * Pure state reducer - computes next state from current state and action\n */\nexport function reducer(state: GridiotState, action: StateTransition): GridiotState {\n\tswitch (action.type) {\n\t\tcase 'SELECT': {\n\t\t\t// Can select from idle or selected (changes selection)\n\t\t\tif (state.phase !== 'idle' && state.phase !== 'selected') {\n\t\t\t\treturn state; // Can't select during interaction\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'selected',\n\t\t\t\tselectedItemId: action.itemId,\n\t\t\t};\n\t\t}\n\n\t\tcase 'DESELECT': {\n\t\t\t// Can deselect from selected only\n\t\t\tif (state.phase !== 'selected') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'idle',\n\t\t\t\tselectedItemId: null,\n\t\t\t};\n\t\t}\n\n\t\tcase 'START_INTERACTION': {\n\t\t\t// Can start interaction from selected only\n\t\t\tif (state.phase !== 'selected') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\tconst { context } = action;\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'interacting',\n\t\t\t\tinteraction: {\n\t\t\t\t\t...context,\n\t\t\t\t\t// Derive animation strategy from mode\n\t\t\t\t\tuseFlip: context.mode === 'pointer',\n\t\t\t\t\tuseViewTransition: context.mode === 'keyboard',\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tcase 'UPDATE_INTERACTION': {\n\t\t\t// Can only update during active interaction\n\t\t\tif (state.phase !== 'interacting' || !state.interaction) {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tinteraction: {\n\t\t\t\t\t...state.interaction,\n\t\t\t\t\ttargetCell: action.targetCell,\n\t\t\t\t\tcurrentSize: action.currentSize ?? state.interaction.currentSize,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tcase 'COMMIT_INTERACTION': {\n\t\t\t// Transition from interacting to committing\n\t\t\tif (state.phase !== 'interacting') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'committing',\n\t\t\t};\n\t\t}\n\n\t\tcase 'CANCEL_INTERACTION': {\n\t\t\t// Can cancel from interacting\n\t\t\tif (state.phase !== 'interacting') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'selected',\n\t\t\t\tinteraction: null,\n\t\t\t};\n\t\t}\n\n\t\tcase 'FINISH_COMMIT': {\n\t\t\t// Transition from committing back to selected\n\t\t\tif (state.phase !== 'committing') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'selected',\n\t\t\t\tinteraction: null,\n\t\t\t};\n\t\t}\n\n\t\tcase 'TOGGLE_KEYBOARD_MODE': {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tkeyboardModeActive: !state.keyboardModeActive,\n\t\t\t};\n\t\t}\n\n\t\tdefault:\n\t\t\treturn state;\n\t}\n}\n\n/**\n * Check if a transition is valid from the current state\n */\nexport function canTransition(state: GridiotState, action: StateTransition): boolean {\n\tswitch (action.type) {\n\t\tcase 'SELECT':\n\t\t\treturn state.phase === 'idle' || state.phase === 'selected';\n\t\tcase 'DESELECT':\n\t\t\treturn state.phase === 'selected';\n\t\tcase 'START_INTERACTION':\n\t\t\treturn state.phase === 'selected';\n\t\tcase 'UPDATE_INTERACTION':\n\t\t\treturn state.phase === 'interacting' && state.interaction !== null;\n\t\tcase 'COMMIT_INTERACTION':\n\t\t\treturn state.phase === 'interacting';\n\t\tcase 'CANCEL_INTERACTION':\n\t\t\treturn state.phase === 'interacting';\n\t\tcase 'FINISH_COMMIT':\n\t\t\treturn state.phase === 'committing';\n\t\tcase 'TOGGLE_KEYBOARD_MODE':\n\t\t\treturn true; // Always allowed\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n/**\n * Create a state machine instance\n */\nexport function createStateMachine(initialState?: GridiotState): GridiotStateMachine {\n\tlet state = initialState ?? createInitialState();\n\tconst listeners = new Set<StateListener>();\n\n\treturn {\n\t\tgetState() {\n\t\t\treturn state;\n\t\t},\n\n\t\ttransition(action: StateTransition) {\n\t\t\tconst nextState = reducer(state, action);\n\t\t\tif (nextState !== state) {\n\t\t\t\tstate = nextState;\n\t\t\t\tfor (const listener of listeners) {\n\t\t\t\t\tlistener(state, action);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn state;\n\t\t},\n\n\t\tsubscribe(listener: StateListener) {\n\t\t\tlisteners.add(listener);\n\t\t\treturn () => listeners.delete(listener);\n\t\t},\n\n\t\tcanTransition(action: StateTransition) {\n\t\t\treturn canTransition(state, action);\n\t\t},\n\t};\n}\n\n// ============================================================================\n// Derived State Helpers\n// ============================================================================\n\n/**\n * Check if currently in an active interaction\n */\nexport function isInteracting(state: GridiotState): boolean {\n\treturn state.phase === 'interacting' || state.phase === 'committing';\n}\n\n/**\n * Check if currently dragging (not resizing)\n */\nexport function isDragging(state: GridiotState): boolean {\n\treturn isInteracting(state) && state.interaction?.type === 'drag';\n}\n\n/**\n * Check if currently resizing (not dragging)\n */\nexport function isResizing(state: GridiotState): boolean {\n\treturn isInteracting(state) && state.interaction?.type === 'resize';\n}\n\n/**\n * Get the interaction mode if active\n */\nexport function getInteractionMode(state: GridiotState): InteractionMode | null {\n\treturn state.interaction?.mode ?? null;\n}\n\n/**\n * Check if View Transitions should be used for current interaction\n */\nexport function shouldUseViewTransition(state: GridiotState): boolean {\n\treturn state.interaction?.useViewTransition ?? false;\n}\n\n/**\n * Check if FLIP animation should be used for current interaction\n */\nexport function shouldUseFlip(state: GridiotState): boolean {\n\treturn state.interaction?.useFlip ?? false;\n}\n\n/**\n * Get the captured column count for current interaction\n */\nexport function getInteractionColumnCount(state: GridiotState): number | null {\n\treturn state.interaction?.columnCount ?? null;\n}\n", "import type { GridCell, GridiotCore, InitOptions, Plugin, PluginOptions, ProviderRegistry } from './types';\nimport { createStateMachine, type GridiotStateMachine } from './state-machine';\n\n// Global plugin registry\nconst plugins = new Map<string, Plugin>();\n\nexport function registerPlugin(plugin: Plugin): void {\n\tplugins.set(plugin.name, plugin);\n}\n\nexport function getPlugin(name: string): Plugin | undefined {\n\treturn plugins.get(name);\n}\n\n/**\n * Initialize Gridiot on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options including layoutModel, styleElement, and plugin options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): GridiotCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t\tplugins: pluginOptions = {},\n\t\tdisablePlugins = [],\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\t// Create centralized state machine\n\tconst stateMachine = createStateMachine();\n\n\t// Track selected element (state machine stores itemId, we need the element)\n\tlet selectedElement: HTMLElement | null = null;\n\n\t// Provider registry for inter-plugin communication\n\tconst providerMap = new Map<string, () => unknown>();\n\tconst providers: ProviderRegistry = {\n\t\tregister<T>(capability: string, provider: () => T): void {\n\t\t\tif (providerMap.has(capability)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Gridiot: Provider for \"${capability}\" already registered, overwriting`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tproviderMap.set(capability, provider);\n\t\t},\n\n\t\tget<T>(capability: string): T | undefined {\n\t\t\tconst provider = providerMap.get(capability);\n\t\t\treturn provider ? (provider() as T) : undefined;\n\t\t},\n\n\t\thas(capability: string): boolean {\n\t\t\treturn providerMap.has(capability);\n\t\t},\n\t};\n\n\tconst core: GridiotCore = {\n\t\telement,\n\t\tproviders,\n\t\tstateMachine,\n\n\t\t// Selection state (backed by state machine)\n\t\tget selectedItem() {\n\t\t\treturn selectedElement;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedElement) return;\n\n\t\t\tconst previousItem = selectedElement;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-gridiot-selected');\n\t\t\t}\n\n\t\t\t// Update state machine and local element reference\n\t\t\tif (item) {\n\t\t\t\tconst itemId = item.id || item.getAttribute('data-gridiot-item') || '';\n\t\t\t\tstateMachine.transition({ type: 'SELECT', itemId, element: item });\n\t\t\t\tselectedElement = item;\n\t\t\t\titem.setAttribute('data-gridiot-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else {\n\t\t\t\tstateMachine.transition({ type: 'DESELECT' });\n\t\t\t\tselectedElement = null;\n\t\t\t\tif (previousItem) {\n\t\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`gridiot:${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tobserver.disconnect();\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Observe position changes and animate with View Transitions\n\tconst observer = new MutationObserver((mutations) => {\n\t\t// Collect items that changed position\n\t\tconst changedItems = new Set<HTMLElement>();\n\n\t\tfor (const mutation of mutations) {\n\t\t\tif (\n\t\t\t\tmutation.type === 'attributes' &&\n\t\t\t\tmutation.target instanceof HTMLElement\n\t\t\t) {\n\t\t\t\tconst item = mutation.target.closest(\n\t\t\t\t\t'[data-gridiot-item]',\n\t\t\t\t) as HTMLElement | null;\n\t\t\t\tif (item && element.contains(item)) {\n\t\t\t\t\tchangedItems.add(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Animate changes with View Transitions if available\n\t\tif (changedItems.size > 0 && 'startViewTransition' in document) {\n\t\t\t// Items already moved - View Transitions will handle animation\n\t\t\t// The browser captures before/after states automatically\n\t\t}\n\t});\n\n\tobserver.observe(element, {\n\t\tsubtree: true,\n\t\tattributes: true,\n\t\tattributeFilter: ['style', 'class'],\n\t});\n\n\t// Register state machine provider for plugin access\n\tproviders.register('state', () => stateMachine.getState());\n\n\t// Initialize all registered plugins with options\n\tfor (const plugin of plugins.values()) {\n\t\t// Skip disabled plugins\n\t\tif (disablePlugins.includes(plugin.name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Build options for this plugin\n\t\tconst pluginSpecificOptions = pluginOptions[plugin.name as keyof PluginOptions] ?? {};\n\t\tconst opts = {\n\t\t\t...pluginSpecificOptions,\n\t\t\t// Pass shared resources to all plugins that might need them\n\t\t\tlayoutModel,\n\t\t\tstyleElement,\n\t\t\tcore,\n\t\t};\n\n\t\tconst cleanup = plugin.init(core, opts);\n\t\tif (cleanup) {\n\t\t\tcleanups.push(cleanup);\n\t\t}\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Set an item's grid position\n */\nexport function setItemCell(item: HTMLElement, cell: GridCell): void {\n\titem.style.gridColumn = String(cell.column);\n\titem.style.gridRow = String(cell.row);\n}\n\n/**\n * Get grid info for a grid element\n */\nexport function getGridInfo(element: HTMLElement) {\n\tconst rect = element.getBoundingClientRect();\n\tconst style = getComputedStyle(element);\n\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\tconst columnGap = parseFloat(style.columnGap) || 0;\n\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\treturn {\n\t\trect,\n\t\tcolumns,\n\t\trows,\n\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\tcellWidth: columns[0] || 0,\n\t\tcellHeight: rows[0] || 0,\n\t};\n}\n", "import { registerPlugin } from '../engine';\nimport type {\n\tDragCancelDetail,\n\tDragEndDetail,\n\tDragMoveDetail,\n\tDragStartDetail,\n\tGridCell,\n} from '../types';\n\nregisterPlugin({\n\tname: 'accessibility',\n\tinit(core) {\n\t\t// Create live region for screen reader announcements\n\t\tconst liveRegion = document.createElement('div');\n\t\tliveRegion.setAttribute('aria-live', 'assertive');\n\t\tliveRegion.setAttribute('aria-atomic', 'true');\n\t\t// Visually hidden but accessible to screen readers\n\t\tObject.assign(liveRegion.style, {\n\t\t\tposition: 'absolute',\n\t\t\twidth: '1px',\n\t\t\theight: '1px',\n\t\t\tpadding: '0',\n\t\t\tmargin: '-1px',\n\t\t\toverflow: 'hidden',\n\t\t\tclip: 'rect(0, 0, 0, 0)',\n\t\t\twhiteSpace: 'nowrap',\n\t\t\tborder: '0',\n\t\t});\n\t\tcore.element.appendChild(liveRegion);\n\n\t\tlet lastCell: GridCell | null = null;\n\n\t\tfunction announce(message: string) {\n\t\t\t// Clear and re-set to force re-announcement\n\t\t\tliveRegion.textContent = '';\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tliveRegion.textContent = message;\n\t\t\t});\n\t\t}\n\n\t\tfunction getLabel(item: HTMLElement): string {\n\t\t\treturn (\n\t\t\t\titem.getAttribute('data-gridiot-label') ||\n\t\t\t\titem.getAttribute('aria-label') ||\n\t\t\t\titem.id ||\n\t\t\t\t'Item'\n\t\t\t);\n\t\t}\n\n\t\tfunction formatPosition(cell: GridCell): string {\n\t\t\treturn `row ${cell.row}, column ${cell.column}`;\n\t\t}\n\n\t\tfunction getAnnouncement(\n\t\t\titem: HTMLElement,\n\t\t\tevent: 'grab' | 'move' | 'drop' | 'cancel',\n\t\t\tcell?: GridCell,\n\t\t): string {\n\t\t\tconst label = getLabel(item);\n\t\t\tconst pos = cell ? formatPosition(cell) : '';\n\n\t\t\t// Check for custom template on the item\n\t\t\tconst itemTemplate = item.getAttribute(`data-gridiot-announce-${event}`);\n\t\t\tif (itemTemplate) {\n\t\t\t\treturn itemTemplate\n\t\t\t\t\t.replace('{label}', label)\n\t\t\t\t\t.replace('{row}', String(cell?.row ?? ''))\n\t\t\t\t\t.replace('{column}', String(cell?.column ?? ''));\n\t\t\t}\n\n\t\t\t// Check for custom template on the grid container\n\t\t\tconst gridTemplate = core.element.getAttribute(\n\t\t\t\t`data-gridiot-announce-${event}`,\n\t\t\t);\n\t\t\tif (gridTemplate) {\n\t\t\t\treturn gridTemplate\n\t\t\t\t\t.replace('{label}', label)\n\t\t\t\t\t.replace('{row}', String(cell?.row ?? ''))\n\t\t\t\t\t.replace('{column}', String(cell?.column ?? ''));\n\t\t\t}\n\n\t\t\t// Default announcements\n\t\t\tswitch (event) {\n\t\t\t\tcase 'grab':\n\t\t\t\t\treturn `${label} grabbed. Position ${pos}. Use arrow keys to move, Enter to drop, Escape to cancel.`;\n\t\t\t\tcase 'move':\n\t\t\t\t\treturn `Moved to ${pos}.`;\n\t\t\t\tcase 'drop':\n\t\t\t\t\treturn `${label} dropped at ${pos}.`;\n\t\t\t\tcase 'cancel':\n\t\t\t\t\treturn `${label} drag cancelled.`;\n\t\t\t}\n\t\t}\n\n\t\tconst onDragStart = (e: CustomEvent<DragStartDetail>) => {\n\t\t\tlastCell = e.detail.cell;\n\t\t\tannounce(getAnnouncement(e.detail.item, 'grab', e.detail.cell));\n\t\t};\n\n\t\tconst onDragMove = (e: CustomEvent<DragMoveDetail>) => {\n\t\t\t// Only announce if cell actually changed\n\t\t\tconst { cell } = e.detail;\n\t\t\tif (\n\t\t\t\tlastCell &&\n\t\t\t\tcell.row === lastCell.row &&\n\t\t\t\tcell.column === lastCell.column\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastCell = cell;\n\t\t\tannounce(getAnnouncement(e.detail.item, 'move', cell));\n\t\t};\n\n\t\tconst onDragEnd = (e: CustomEvent<DragEndDetail>) => {\n\t\t\tlastCell = null;\n\t\t\tannounce(getAnnouncement(e.detail.item, 'drop', e.detail.cell));\n\t\t};\n\n\t\tconst onDragCancel = (e: CustomEvent<DragCancelDetail>) => {\n\t\t\tlastCell = null;\n\t\t\tannounce(getAnnouncement(e.detail.item, 'cancel'));\n\t\t};\n\n\t\tcore.element.addEventListener(\n\t\t\t'gridiot:drag-start',\n\t\t\tonDragStart as EventListener,\n\t\t);\n\t\tcore.element.addEventListener(\n\t\t\t'gridiot:drag-move',\n\t\t\tonDragMove as EventListener,\n\t\t);\n\t\tcore.element.addEventListener(\n\t\t\t'gridiot:drag-end',\n\t\t\tonDragEnd as EventListener,\n\t\t);\n\t\tcore.element.addEventListener(\n\t\t\t'gridiot:drag-cancel',\n\t\t\tonDragCancel as EventListener,\n\t\t);\n\n\t\treturn () => {\n\t\t\tcore.element.removeEventListener(\n\t\t\t\t'gridiot:drag-start',\n\t\t\t\tonDragStart as EventListener,\n\t\t\t);\n\t\t\tcore.element.removeEventListener(\n\t\t\t\t'gridiot:drag-move',\n\t\t\t\tonDragMove as EventListener,\n\t\t\t);\n\t\t\tcore.element.removeEventListener(\n\t\t\t\t'gridiot:drag-end',\n\t\t\t\tonDragEnd as EventListener,\n\t\t\t);\n\t\t\tcore.element.removeEventListener(\n\t\t\t\t'gridiot:drag-cancel',\n\t\t\t\tonDragCancel as EventListener,\n\t\t\t);\n\t\t\tliveRegion.remove();\n\t\t};\n\t},\n});\n", "import { getItemCell, registerPlugin } from '../engine';\nimport type { GridCell, ItemPosition } from '../types';\nimport { isDragging, isResizing } from '../state-machine';\n\nconst DEBUG = false;\nfunction log(...args: unknown[]) {\n\tif (DEBUG) console.log('[keyboard]', ...args);\n}\n\nregisterPlugin({\n\tname: 'keyboard',\n\tinit(core) {\n\t\t// Use state machine for all interaction state\n\t\tconst { stateMachine } = core;\n\n\t\t// Track pending viewTransitionName restoration to avoid race conditions\n\t\tlet pendingVtnRestore: { item: HTMLElement; timeoutId: number } | null = null;\n\n\t\t/**\n\t\t * Helper to get current column count from grid\n\t\t */\n\t\tconst getColumnCount = (): number => {\n\t\t\treturn core.getGridInfo().columns.length;\n\t\t};\n\n\t\t/**\n\t\t * Helper to capture all item positions from DOM\n\t\t */\n\t\tconst capturePositions = (): Map<string, ItemPosition> => {\n\t\t\tconst positions = new Map<string, ItemPosition>();\n\t\t\tconst items = core.element.querySelectorAll('[data-gridiot-item]');\n\t\t\tfor (const item of items) {\n\t\t\t\tconst id = item.id || (item as HTMLElement).getAttribute('data-gridiot-item') || '';\n\t\t\t\tif (id) {\n\t\t\t\t\tconst cell = getItemCell(item as HTMLElement);\n\t\t\t\t\tpositions.set(id, { column: cell.column, row: cell.row });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn positions;\n\t\t};\n\n\t\t/**\n\t\t * Helper to capture all item sizes from DOM\n\t\t */\n\t\tconst captureSizes = (): Map<string, { width: number; height: number }> => {\n\t\t\tconst sizes = new Map<string, { width: number; height: number }>();\n\t\t\tconst items = core.element.querySelectorAll('[data-gridiot-item]');\n\t\t\tfor (const item of items) {\n\t\t\t\tconst el = item as HTMLElement;\n\t\t\t\tconst id = el.id || el.getAttribute('data-gridiot-item') || '';\n\t\t\t\tif (id) {\n\t\t\t\t\tconst width = parseInt(el.getAttribute('data-gridiot-colspan') || '1', 10) || 1;\n\t\t\t\t\tconst height = parseInt(el.getAttribute('data-gridiot-rowspan') || '1', 10) || 1;\n\t\t\t\t\tsizes.set(id, { width, height });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sizes;\n\t\t};\n\n\t\t/**\n\t\t * Check if currently holding an item (keyboard drag in progress)\n\t\t */\n\t\tconst isHoldingItem = (): boolean => {\n\t\t\tconst state = stateMachine.getState();\n\t\t\treturn isDragging(state) && state.interaction?.mode === 'keyboard';\n\t\t};\n\n\t\t/**\n\t\t * Get the held item element from state machine\n\t\t */\n\t\tconst getHeldItem = (): HTMLElement | null => {\n\t\t\tconst state = stateMachine.getState();\n\t\t\tif (isDragging(state) && state.interaction?.mode === 'keyboard') {\n\t\t\t\treturn state.interaction.element;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\n\t\t/**\n\t\t * Get direction from key, supporting both arrows and vim-style hjkl.\n\t\t * Uses both e.key and e.code to handle Alt+hjkl on Mac (Alt produces special chars).\n\t\t */\n\t\tconst getDirection = (\n\t\t\tkey: string,\n\t\t\tcode: string,\n\t\t): 'up' | 'down' | 'left' | 'right' | null => {\n\t\t\tswitch (key) {\n\t\t\t\tcase 'ArrowUp':\n\t\t\t\t\treturn 'up';\n\t\t\t\tcase 'ArrowDown':\n\t\t\t\t\treturn 'down';\n\t\t\t\tcase 'ArrowLeft':\n\t\t\t\t\treturn 'left';\n\t\t\t\tcase 'ArrowRight':\n\t\t\t\t\treturn 'right';\n\t\t\t\tcase 'k':\n\t\t\t\tcase 'K':\n\t\t\t\t\treturn 'up';\n\t\t\t\tcase 'j':\n\t\t\t\tcase 'J':\n\t\t\t\t\treturn 'down';\n\t\t\t\tcase 'h':\n\t\t\t\tcase 'H':\n\t\t\t\t\treturn 'left';\n\t\t\t\tcase 'l':\n\t\t\t\tcase 'L':\n\t\t\t\t\treturn 'right';\n\t\t\t}\n\t\t\t// Fallback to code for Alt+hjkl on Mac (Alt produces special characters)\n\t\t\tswitch (code) {\n\t\t\t\tcase 'KeyK':\n\t\t\t\t\treturn 'up';\n\t\t\t\tcase 'KeyJ':\n\t\t\t\t\treturn 'down';\n\t\t\t\tcase 'KeyH':\n\t\t\t\t\treturn 'left';\n\t\t\t\tcase 'KeyL':\n\t\t\t\t\treturn 'right';\n\t\t\t\tdefault:\n\t\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Get adjacent cell in a direction\n\t\t */\n\t\tconst getAdjacentCell = (\n\t\t\tcell: GridCell,\n\t\t\tdirection: 'up' | 'down' | 'left' | 'right',\n\t\t\tamount = 1,\n\t\t): GridCell => {\n\t\t\tswitch (direction) {\n\t\t\t\tcase 'up':\n\t\t\t\t\treturn { ...cell, row: Math.max(1, cell.row - amount) };\n\t\t\t\tcase 'down':\n\t\t\t\t\treturn { ...cell, row: cell.row + amount };\n\t\t\t\tcase 'left':\n\t\t\t\t\treturn { ...cell, column: Math.max(1, cell.column - amount) };\n\t\t\t\tcase 'right':\n\t\t\t\t\treturn { ...cell, column: cell.column + amount };\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Find the item at or closest to a cell position in a direction\n\t\t */\n\t\tconst findItemInDirection = (\n\t\t\tfromCell: GridCell,\n\t\t\tdirection: 'up' | 'down' | 'left' | 'right',\n\t\t\texcludeItem: HTMLElement,\n\t\t): HTMLElement | null => {\n\t\t\tconst items = Array.from(\n\t\t\t\tcore.element.querySelectorAll('[data-gridiot-item]'),\n\t\t\t) as HTMLElement[];\n\n\t\t\tlet bestItem: HTMLElement | null = null;\n\t\t\tlet bestDistance = Infinity;\n\n\t\t\tfor (const item of items) {\n\t\t\t\tif (item === excludeItem) continue;\n\n\t\t\t\tconst cell = getItemCell(item);\n\t\t\t\tlet distance: number;\n\t\t\t\tlet isInDirection: boolean;\n\n\t\t\t\tswitch (direction) {\n\t\t\t\t\tcase 'up':\n\t\t\t\t\t\tisInDirection = cell.row < fromCell.row;\n\t\t\t\t\t\tdistance = fromCell.row - cell.row + Math.abs(cell.column - fromCell.column) * 0.1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'down':\n\t\t\t\t\t\tisInDirection = cell.row > fromCell.row;\n\t\t\t\t\t\tdistance = cell.row - fromCell.row + Math.abs(cell.column - fromCell.column) * 0.1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'left':\n\t\t\t\t\t\tisInDirection = cell.column < fromCell.column;\n\t\t\t\t\t\tdistance = fromCell.column - cell.column + Math.abs(cell.row - fromCell.row) * 0.1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'right':\n\t\t\t\t\t\tisInDirection = cell.column > fromCell.column;\n\t\t\t\t\t\tdistance = cell.column - fromCell.column + Math.abs(cell.row - fromCell.row) * 0.1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isInDirection && distance < bestDistance) {\n\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\tbestItem = item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn bestItem;\n\t\t};\n\n\t\t/**\n\t\t * Get the size of an item for jump calculations\n\t\t */\n\t\tconst getItemSize = (item: HTMLElement): { colspan: number; rowspan: number } => {\n\t\t\treturn {\n\t\t\t\tcolspan: parseInt(item.getAttribute('data-gridiot-colspan') || '1', 10) || 1,\n\t\t\t\trowspan: parseInt(item.getAttribute('data-gridiot-rowspan') || '1', 10) || 1,\n\t\t\t};\n\t\t};\n\n\t\tconst onKeyDown = (e: KeyboardEvent) => {\n\t\t\t// Toggle keyboard mode with Shift+G (G for Grid)\n\t\t\tif (e.key === 'G' && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {\n\t\t\t\te.preventDefault();\n\t\t\t\tstateMachine.transition({ type: 'TOGGLE_KEYBOARD_MODE' });\n\t\t\t\tconst keyboardMode = stateMachine.getState().keyboardModeActive;\n\t\t\t\tlog('keyboard mode:', keyboardMode);\n\n\t\t\t\tif (keyboardMode) {\n\t\t\t\t\tcore.element.setAttribute('data-gridiot-keyboard-mode', '');\n\t\t\t\t\t// If no item is selected, select the first one\n\t\t\t\t\tif (!core.selectedItem) {\n\t\t\t\t\t\tconst firstItem = core.element.querySelector('[data-gridiot-item]') as HTMLElement | null;\n\t\t\t\t\t\tif (firstItem) {\n\t\t\t\t\t\t\tcore.select(firstItem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcore.element.removeAttribute('data-gridiot-keyboard-mode');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// All other keyboard shortcuts require keyboard mode, selected item, or focus inside grid\n\t\t\tconst focused = document.activeElement as HTMLElement | null;\n\t\t\tconst focusInGrid = focused && core.element.contains(focused);\n\t\t\tconst hasSelection = core.selectedItem !== null;\n\t\t\tconst keyboardMode = stateMachine.getState().keyboardModeActive;\n\t\t\tif (!keyboardMode && !focusInGrid && !hasSelection) return;\n\n\t\t\tconst selectedItem = core.selectedItem;\n\t\t\tconst direction = getDirection(e.key, e.code);\n\n\t\t\t// Cancel drag or deselect with Escape\n\t\t\tif (e.key === 'Escape') {\n\t\t\t\te.preventDefault();\n\t\t\t\tconst heldItem = getHeldItem();\n\t\t\t\tif (heldItem) {\n\t\t\t\t\theldItem.removeAttribute('data-gridiot-dragging');\n\t\t\t\t\tcore.emit('drag-cancel', { item: heldItem });\n\t\t\t\t\tstateMachine.transition({ type: 'CANCEL_INTERACTION' });\n\t\t\t\t} else if (selectedItem) {\n\t\t\t\t\tcore.deselect();\n\t\t\t\t}\n\t\t\t\t// Turn off keyboard mode if it's active\n\t\t\t\tif (stateMachine.getState().keyboardModeActive) {\n\t\t\t\t\tstateMachine.transition({ type: 'TOGGLE_KEYBOARD_MODE' });\n\t\t\t\t}\n\t\t\t\tcore.element.removeAttribute('data-gridiot-keyboard-mode');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Pick up / drop with Enter or Space\n\t\t\tif (e.key === 'Enter' || e.key === ' ') {\n\t\t\t\tif (!selectedItem) return;\n\t\t\t\te.preventDefault();\n\n\t\t\t\tconst heldItem = getHeldItem();\n\t\t\t\tif (heldItem) {\n\t\t\t\t\t// Drop the held item - use target cell from state machine\n\t\t\t\t\tconst state = stateMachine.getState();\n\t\t\t\t\tconst targetCell = state.interaction?.targetCell ?? getItemCell(heldItem);\n\t\t\t\t\tconst size = getItemSize(heldItem);\n\t\t\t\t\theldItem.removeAttribute('data-gridiot-dragging');\n\t\t\t\t\tcore.emit('drag-end', { item: heldItem, cell: targetCell, colspan: size.colspan, rowspan: size.rowspan });\n\t\t\t\t\tstateMachine.transition({ type: 'COMMIT_INTERACTION' });\n\t\t\t\t\tstateMachine.transition({ type: 'FINISH_COMMIT' });\n\t\t\t\t\tlog('drop', { cell: targetCell });\n\t\t\t\t} else {\n\t\t\t\t\t// Pick up the selected item\n\t\t\t\t\tconst itemId = selectedItem.id || selectedItem.getAttribute('data-gridiot-item') || '';\n\t\t\t\t\tconst size = getItemSize(selectedItem);\n\t\t\t\t\tconst startCell = getItemCell(selectedItem);\n\n\t\t\t\t\t// Start interaction via state machine\n\t\t\t\t\tstateMachine.transition({\n\t\t\t\t\t\ttype: 'START_INTERACTION',\n\t\t\t\t\t\tcontext: {\n\t\t\t\t\t\t\ttype: 'drag',\n\t\t\t\t\t\t\tmode: 'keyboard',\n\t\t\t\t\t\t\titemId,\n\t\t\t\t\t\t\telement: selectedItem,\n\t\t\t\t\t\t\tcolumnCount: getColumnCount(),\n\t\t\t\t\t\t\toriginalPositions: capturePositions(),\n\t\t\t\t\t\t\toriginalSizes: captureSizes(),\n\t\t\t\t\t\t\ttargetCell: startCell,\n\t\t\t\t\t\t\tcurrentSize: { colspan: size.colspan, rowspan: size.rowspan },\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\t\tselectedItem.setAttribute('data-gridiot-dragging', '');\n\t\t\t\t\tcore.emit('drag-start', { item: selectedItem, cell: startCell, colspan: size.colspan, rowspan: size.rowspan });\n\t\t\t\t\tlog('pick up');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Navigation keys\n\t\t\tif (direction) {\n\t\t\t\te.preventDefault();\n\n\t\t\t\t// Alt+nav: Select adjacent item\n\t\t\t\tif (e.altKey && !e.ctrlKey && !e.shiftKey && selectedItem) {\n\t\t\t\t\tconst fromCell = getItemCell(selectedItem);\n\t\t\t\t\tconst adjacentItem = findItemInDirection(fromCell, direction, selectedItem);\n\t\t\t\t\tif (adjacentItem) {\n\t\t\t\t\t\tcore.select(adjacentItem);\n\t\t\t\t\t\tlog('select adjacent', direction);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Must have a selected item for other nav actions\n\t\t\t\tif (!selectedItem) return;\n\n\t\t\t\tconst currentCell = getItemCell(selectedItem);\n\t\t\t\tconst itemSize = getItemSize(selectedItem);\n\t\t\t\tconst gridInfo = core.getGridInfo();\n\n\t\t\t\t// Shift+nav: Resize item (change colspan/rowspan)\n\t\t\t\tif (e.shiftKey && !e.ctrlKey && !e.altKey) {\n\t\t\t\t\tlet newColspan = itemSize.colspan;\n\t\t\t\t\tlet newRowspan = itemSize.rowspan;\n\n\t\t\t\t\t// Calculate new size based on direction\n\t\t\t\t\tswitch (direction) {\n\t\t\t\t\t\tcase 'right':\n\t\t\t\t\t\t\tnewColspan = Math.min(itemSize.colspan + 1, gridInfo.columns.length - currentCell.column + 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'left':\n\t\t\t\t\t\t\tnewColspan = Math.max(1, itemSize.colspan - 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'down':\n\t\t\t\t\t\t\tnewRowspan = itemSize.rowspan + 1; // No max for rows (grid auto-grows)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'up':\n\t\t\t\t\t\t\tnewRowspan = Math.max(1, itemSize.rowspan - 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Skip if size didn't change (already at limit)\n\t\t\t\t\tif (newColspan === itemSize.colspan && newRowspan === itemSize.rowspan) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Cancel any pending viewTransitionName restoration\n\t\t\t\t\tif (pendingVtnRestore) {\n\t\t\t\t\t\tclearTimeout(pendingVtnRestore.timeoutId);\n\t\t\t\t\t\tpendingVtnRestore.item.style.removeProperty('view-transition-name');\n\t\t\t\t\t\tpendingVtnRestore = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst itemId = selectedItem.id || selectedItem.getAttribute('data-gridiot-item') || '';\n\n\t\t\t\t\t// Start resize interaction via state machine\n\t\t\t\t\tstateMachine.transition({\n\t\t\t\t\t\ttype: 'START_INTERACTION',\n\t\t\t\t\t\tcontext: {\n\t\t\t\t\t\t\ttype: 'resize',\n\t\t\t\t\t\t\tmode: 'keyboard',\n\t\t\t\t\t\t\titemId,\n\t\t\t\t\t\t\telement: selectedItem,\n\t\t\t\t\t\t\tcolumnCount: getColumnCount(),\n\t\t\t\t\t\t\toriginalPositions: capturePositions(),\n\t\t\t\t\t\t\toriginalSizes: captureSizes(),\n\t\t\t\t\t\t\ttargetCell: currentCell,\n\t\t\t\t\t\t\tcurrentSize: { colspan: newColspan, rowspan: newRowspan },\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\t\t// Mark item as resizing so CSS can disable its View Transition animation\n\t\t\t\t\t// (matches pointer resize behavior - item snaps, others animate)\n\t\t\t\t\t(selectedItem.style as any).viewTransitionName = 'resizing';\n\n\t\t\t\t\t// Emit resize events for algorithm and other plugins to handle\n\t\t\t\t\t// Use 'se' handle for increases, appropriate edge for decreases\n\t\t\t\t\tconst handle = direction === 'right' || direction === 'down' ? 'se' :\n\t\t\t\t\t               direction === 'left' ? 'w' : 'n';\n\n\t\t\t\t\tcore.emit('resize-start', {\n\t\t\t\t\t\titem: selectedItem,\n\t\t\t\t\t\tcell: currentCell,\n\t\t\t\t\t\tcolspan: itemSize.colspan,\n\t\t\t\t\t\trowspan: itemSize.rowspan,\n\t\t\t\t\t\thandle,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Update item data attributes (algorithm reads these for size)\n\t\t\t\t\tselectedItem.setAttribute('data-gridiot-colspan', String(newColspan));\n\t\t\t\t\tselectedItem.setAttribute('data-gridiot-rowspan', String(newRowspan));\n\n\t\t\t\t\t// Don't set inline grid styles - let algorithm handle layout via CSS rules\n\t\t\t\t\t// This allows View Transitions to animate other items smoothly\n\n\t\t\t\t\tcore.emit('resize-end', {\n\t\t\t\t\t\titem: selectedItem,\n\t\t\t\t\t\tcell: currentCell,\n\t\t\t\t\t\tcolspan: newColspan,\n\t\t\t\t\t\trowspan: newRowspan,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Complete the interaction via state machine\n\t\t\t\t\tstateMachine.transition({ type: 'COMMIT_INTERACTION' });\n\t\t\t\t\tstateMachine.transition({ type: 'FINISH_COMMIT' });\n\n\t\t\t\t\t// Restore viewTransitionName after View Transition completes (200ms)\n\t\t\t\t\t// Track the timeout so we can cancel it if another resize starts\n\t\t\t\t\tconst itemToRestore = selectedItem;\n\t\t\t\t\tconst timeoutId = window.setTimeout(() => {\n\t\t\t\t\t\titemToRestore.style.removeProperty('view-transition-name');\n\t\t\t\t\t\tif (pendingVtnRestore?.item === itemToRestore) {\n\t\t\t\t\t\t\tpendingVtnRestore = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 250);\n\t\t\t\t\tpendingVtnRestore = { item: itemToRestore, timeoutId };\n\n\t\t\t\t\tlog('resize', { direction, newColspan, newRowspan });\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Calculate move amount\n\t\t\t\tlet amount = 1;\n\t\t\t\tif (e.ctrlKey || e.metaKey) {\n\t\t\t\t\t// Ctrl+nav: Jump by item size\n\t\t\t\t\tamount = direction === 'up' || direction === 'down'\n\t\t\t\t\t\t? itemSize.rowspan\n\t\t\t\t\t\t: itemSize.colspan;\n\t\t\t\t}\n\n\t\t\t\tconst rawCell = getAdjacentCell(currentCell, direction, amount);\n\n\t\t\t\t// Clamp cell so item fits within grid bounds\n\t\t\t\tconst maxColumn = Math.max(1, gridInfo.columns.length - itemSize.colspan + 1);\n\t\t\t\tconst maxRow = Math.max(1, gridInfo.rows.length - itemSize.rowspan + 1);\n\t\t\t\tconst targetCell = {\n\t\t\t\t\tcolumn: Math.max(1, Math.min(maxColumn, rawCell.column)),\n\t\t\t\t\trow: Math.max(1, Math.min(maxRow, rawCell.row)),\n\t\t\t\t};\n\n\t\t\t\t// Skip if clamped position is same as current (at edge, can't move further)\n\t\t\t\tif (targetCell.column === currentCell.column && targetCell.row === currentCell.row) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst heldItem = getHeldItem();\n\t\t\t\tif (heldItem) {\n\t\t\t\t\t// Moving a held item - update state machine with new target\n\t\t\t\t\tstateMachine.transition({\n\t\t\t\t\t\ttype: 'UPDATE_INTERACTION',\n\t\t\t\t\t\ttargetCell,\n\t\t\t\t\t});\n\t\t\t\t\tcore.emit('drag-move', { item: heldItem, cell: targetCell, x: 0, y: 0, colspan: itemSize.colspan, rowspan: itemSize.rowspan });\n\t\t\t\t\tlog('move', { direction, amount, targetCell });\n\t\t\t\t} else {\n\t\t\t\t\t// Nudge: Move item directly\n\t\t\t\t\t// Emit drag-start then drag-end (skip drag-move since we don't need preview)\n\t\t\t\t\tcore.emit('drag-start', { item: selectedItem, cell: currentCell, colspan: itemSize.colspan, rowspan: itemSize.rowspan });\n\t\t\t\t\tcore.emit('drag-end', { item: selectedItem, cell: targetCell, colspan: itemSize.colspan, rowspan: itemSize.rowspan });\n\t\t\t\t\tlog('nudge', { direction, amount, targetCell });\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t};\n\n\t\tdocument.addEventListener('keydown', onKeyDown);\n\n\t\treturn () => {\n\t\t\tdocument.removeEventListener('keydown', onKeyDown);\n\t\t\tcore.element.removeAttribute('data-gridiot-keyboard-mode');\n\t\t};\n\t},\n});\n", "/**\n * FLIP Animation Utility\n *\n * Provides shared FLIP (First, Last, Invert, Play) animation utilities\n * used by pointer and resize plugins for smooth position/scale transitions.\n */\n\nexport interface FLIPOptions {\n\t/** Animation duration in milliseconds. @default 200 */\n\tduration?: number;\n\t/** CSS easing function. @default 'cubic-bezier(0.2, 0, 0, 1)' */\n\teasing?: string;\n\t/** Include scale transform (for resize). @default false */\n\tincludeScale?: boolean;\n\t/** Transform origin for scale animations. @default undefined (uses center) */\n\ttransformOrigin?: string;\n\t/** Callback when animation starts */\n\tonStart?: () => void;\n\t/** Callback when animation finishes */\n\tonFinish?: () => void;\n}\n\n/**\n * Animate an element from its previous position/size to its new position/size using FLIP.\n *\n * @param element - The element to animate\n * @param firstRect - The element's bounding rect before the DOM change (the \"First\" in FLIP)\n * @param options - Animation options\n * @returns The Animation object, or null if no animation was needed\n *\n * @example\n * ```ts\n * // Capture position before DOM change\n * const firstRect = element.getBoundingClientRect();\n *\n * // Make DOM changes (e.g., update grid position)\n * element.style.gridColumn = '2 / span 2';\n *\n * // Animate from old position to new\n * requestAnimationFrame(() => {\n *   animateFLIP(element, firstRect);\n * });\n * ```\n */\nexport function animateFLIP(\n\telement: HTMLElement,\n\tfirstRect: DOMRect,\n\toptions: FLIPOptions = {},\n): Animation | null {\n\tconst {\n\t\tduration = 200,\n\t\teasing = 'cubic-bezier(0.2, 0, 0, 1)',\n\t\tincludeScale = false,\n\t\ttransformOrigin,\n\t\tonStart,\n\t\tonFinish,\n\t} = options;\n\n\t// Measure final position (the \"Last\" in FLIP)\n\tconst lastRect = element.getBoundingClientRect();\n\n\t// Calculate position deltas (the \"Invert\" in FLIP)\n\tconst deltaX = firstRect.left - lastRect.left;\n\tconst deltaY = firstRect.top - lastRect.top;\n\n\tconst needsTranslate = Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1;\n\n\t// Calculate scale deltas (for resize)\n\tlet scaleX = 1;\n\tlet scaleY = 1;\n\tlet needsScale = false;\n\n\tif (includeScale) {\n\t\tscaleX = firstRect.width / lastRect.width;\n\t\tscaleY = firstRect.height / lastRect.height;\n\t\tneedsScale = Math.abs(scaleX - 1) > 0.01 || Math.abs(scaleY - 1) > 0.01;\n\t}\n\n\t// Skip animation if no significant change\n\tif (!needsTranslate && !needsScale) {\n\t\tonFinish?.();\n\t\treturn null;\n\t}\n\n\tonStart?.();\n\n\t// Build keyframes based on what's needed\n\tconst keyframes: Keyframe[] = includeScale\n\t\t? [\n\t\t\t\t{\n\t\t\t\t\ttransform: `translate(${deltaX}px, ${deltaY}px) scale(${scaleX}, ${scaleY})`,\n\t\t\t\t\ttransformOrigin: transformOrigin ?? 'top left',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttransform: 'translate(0, 0) scale(1, 1)',\n\t\t\t\t\ttransformOrigin: transformOrigin ?? 'top left',\n\t\t\t\t},\n\t\t\t]\n\t\t: [\n\t\t\t\t{ transform: `translate(${deltaX}px, ${deltaY}px)` },\n\t\t\t\t{ transform: 'translate(0, 0)' },\n\t\t\t];\n\n\t// Play the animation\n\tconst animation = element.animate(keyframes, {\n\t\tduration,\n\t\teasing,\n\t});\n\n\tanimation.onfinish = () => onFinish?.();\n\n\treturn animation;\n}\n\n/**\n * Get the item's view transition name from various sources.\n * Checks --item-id CSS property, id attribute, and data-id attribute.\n */\nexport function getItemViewTransitionName(element: HTMLElement): string | null {\n\treturn (\n\t\telement.style.getPropertyValue('--item-id') ||\n\t\telement.id ||\n\t\telement.dataset.id ||\n\t\tnull\n\t);\n}\n\n/**\n * Execute a FLIP animation while temporarily excluding the element from View Transitions.\n *\n * This is useful when you want to use FLIP for an animation instead of View Transitions,\n * to prevent the two from conflicting.\n *\n * @param element - The element to animate\n * @param fn - Function that performs the animation (receives firstRect)\n * @returns The Animation object, or null if no animation was needed\n *\n * @example\n * ```ts\n * const firstRect = element.getBoundingClientRect();\n *\n * // Make DOM changes\n * element.style.gridColumn = '2 / span 2';\n *\n * // Animate with View Transition exclusion\n * requestAnimationFrame(() => {\n *   withViewTransitionExclusion(element, () =>\n *     animateFLIP(element, firstRect)\n *   );\n * });\n * ```\n */\nexport function withViewTransitionExclusion(\n\telement: HTMLElement,\n\tfn: () => Animation | null,\n): Animation | null {\n\t// Exclude from View Transitions during FLIP\n\telement.style.viewTransitionName = 'none';\n\n\tconst animation = fn();\n\n\tconst restoreViewTransitionName = () => {\n\t\tconst itemId = getItemViewTransitionName(element);\n\t\tif (itemId) {\n\t\t\telement.style.viewTransitionName = itemId;\n\t\t}\n\t};\n\n\tif (animation) {\n\t\tanimation.addEventListener('finish', restoreViewTransitionName, { once: true });\n\t} else {\n\t\t// No animation needed, restore immediately\n\t\trestoreViewTransitionName();\n\t}\n\n\treturn animation;\n}\n\n/**\n * Perform a complete FLIP animation with data attribute tracking.\n *\n * This is a higher-level helper that:\n * 1. Excludes the element from View Transitions\n * 2. Sets a tracking attribute during animation\n * 3. Animates using FLIP\n * 4. Restores View Transition name when done\n *\n * @param element - The element to animate\n * @param firstRect - The element's bounding rect before the DOM change\n * @param options - Animation options plus optional attribute name\n *\n * @example\n * ```ts\n * const firstRect = element.getBoundingClientRect();\n * element.style.gridColumn = '2 / span 2';\n *\n * requestAnimationFrame(() => {\n *   animateFLIPWithTracking(element, firstRect, {\n *     attributeName: 'data-gridiot-dropping',\n *     includeScale: true,\n *     transformOrigin: 'top left',\n *   });\n * });\n * ```\n */\nexport function animateFLIPWithTracking(\n\telement: HTMLElement,\n\tfirstRect: DOMRect,\n\toptions: FLIPOptions & { attributeName?: string } = {},\n): Animation | null {\n\tconst { attributeName = 'data-gridiot-dropping', ...flipOptions } = options;\n\n\t// Exclude from View Transitions\n\telement.style.viewTransitionName = 'none';\n\n\tconst animation = animateFLIP(element, firstRect, {\n\t\t...flipOptions,\n\t\tonStart: () => {\n\t\t\telement.setAttribute(attributeName, '');\n\t\t\tflipOptions.onStart?.();\n\t\t},\n\t\tonFinish: () => {\n\t\t\telement.removeAttribute(attributeName);\n\t\t\t// Restore view transition name\n\t\t\tconst itemId = getItemViewTransitionName(element);\n\t\t\tif (itemId) {\n\t\t\t\telement.style.viewTransitionName = itemId;\n\t\t\t}\n\t\t\tflipOptions.onFinish?.();\n\t\t},\n\t});\n\n\t// If no animation was needed, clean up immediately\n\tif (!animation) {\n\t\tconst itemId = getItemViewTransitionName(element);\n\t\tif (itemId) {\n\t\t\telement.style.viewTransitionName = itemId;\n\t\t}\n\t}\n\n\treturn animation;\n}\n", "import { getItemCell, registerPlugin } from '../engine';\nimport type { DragState as ExposedDragState, GridCell } from '../types';\nimport { animateFLIPWithTracking } from '../utils/flip';\n\n// Hysteresis: distance in grid units before changing target cell\nconst HYSTERESIS = 0.4;\n// Minimum time (ms) between target changes to prevent jitter\nconst TARGET_CHANGE_DEBOUNCE = 40;\n// Minimum pixels of movement before starting a drag\nconst DRAG_THRESHOLD = 5;\n// Minimum pixels of cumulative movement before applying predictive offset\nconst PREDICTION_THRESHOLD = 30;\n// Fraction of cell to lead ahead when prediction is active (0.5 = half a cell)\nconst PREDICTION_LEAD = 0.5;\n\nconst DEBUG = false;\nfunction log(...args: unknown[]) {\n\tif (DEBUG) console.log('[pointer]', ...args);\n}\n\ninterface PendingDrag {\n\titem: HTMLElement;\n\tpointerId: number;\n\tstartX: number;\n\tstartY: number;\n\trect: DOMRect;\n\tstartCell: GridCell;\n\tcolspan: number;\n\trowspan: number;\n}\n\ninterface DragState {\n\titem: HTMLElement;\n\tpointerId: number;\n\toffsetX: number;\n\toffsetY: number;\n\tinitialRect: DOMRect;\n\tstartCell: GridCell;\n\tlastCell: GridCell;\n\tlastTargetChangeTime: number;\n\tcolspan: number;\n\trowspan: number;\n\t// For predictive placeholder\n\tdragStartX: number;\n\tdragStartY: number;\n}\n\nregisterPlugin({\n\tname: 'pointer',\n\tinit(core) {\n\t\tlet pendingDrag: PendingDrag | null = null;\n\t\tlet dragState: DragState | null = null;\n\n\t\t// Register provider for drag state - allows other plugins to query current drag\n\t\tcore.providers.register<ExposedDragState | null>('drag', () => {\n\t\t\tif (!dragState) return null;\n\t\t\treturn {\n\t\t\t\titem: dragState.item,\n\t\t\t\tcell: dragState.lastCell,\n\t\t\t\tstartCell: dragState.startCell,\n\t\t\t\tcolspan: dragState.colspan,\n\t\t\t\trowspan: dragState.rowspan,\n\t\t\t};\n\t\t});\n\n\t\tconst startDrag = (pending: PendingDrag, e: PointerEvent) => {\n\t\t\tconst { item, pointerId, rect, startCell, colspan, rowspan } = pending;\n\n\t\t\tdragState = {\n\t\t\t\titem,\n\t\t\t\tpointerId,\n\t\t\t\toffsetX: e.clientX - rect.left,\n\t\t\t\toffsetY: e.clientY - rect.top,\n\t\t\t\tinitialRect: rect,\n\t\t\t\tstartCell,\n\t\t\t\tlastCell: startCell,\n\t\t\t\tlastTargetChangeTime: 0,\n\t\t\t\tcolspan,\n\t\t\t\trowspan,\n\t\t\t\tdragStartX: e.clientX,\n\t\t\t\tdragStartY: e.clientY,\n\t\t\t};\n\n\t\t\titem.setAttribute('data-gridiot-dragging', '');\n\t\t\tdocument.body.classList.add('is-dragging');\n\n\t\t\tlog('drag-start', { startCell, rect: { left: rect.left, top: rect.top } });\n\t\t\t// Emit drag-start BEFORE changing grid styles so originalPositions captures correct layout\n\t\t\tcore.emit('drag-start', { item, cell: startCell, colspan, rowspan });\n\n\t\t\t// Switch to fixed positioning - CSS Grid ignores fixed positioned children\n\t\t\t// No need to move item out of grid container\n\t\t\titem.style.position = 'fixed';\n\t\t\titem.style.left = `${rect.left}px`;\n\t\t\titem.style.top = `${rect.top}px`;\n\t\t\titem.style.width = `${rect.width}px`;\n\t\t\titem.style.height = `${rect.height}px`;\n\t\t\titem.style.zIndex = '100';\n\n\t\t\tpendingDrag = null;\n\t\t};\n\n\t\tconst onPointerDown = (e: PointerEvent) => {\n\t\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t\t'[data-gridiot-item]',\n\t\t\t) as HTMLElement | null;\n\t\t\tif (!item) return;\n\n\t\t\t// Select the item on click\n\t\t\tcore.select(item);\n\n\t\t\t// Prevent text selection during potential drag\n\t\t\te.preventDefault();\n\n\t\t\tconst rect = item.getBoundingClientRect();\n\t\t\tconst startCell = getItemCell(item);\n\t\t\tconst colspan =\n\t\t\t\tparseInt(item.getAttribute('data-gridiot-colspan') || '1', 10) || 1;\n\t\t\tconst rowspan =\n\t\t\t\tparseInt(item.getAttribute('data-gridiot-rowspan') || '1', 10) || 1;\n\n\t\t\t// Store pending drag state - don't start drag until movement\n\t\t\tpendingDrag = {\n\t\t\t\titem,\n\t\t\t\tpointerId: e.pointerId,\n\t\t\t\tstartX: e.clientX,\n\t\t\t\tstartY: e.clientY,\n\t\t\t\trect,\n\t\t\t\tstartCell,\n\t\t\t\tcolspan,\n\t\t\t\trowspan,\n\t\t\t};\n\n\t\t\titem.setPointerCapture(e.pointerId);\n\t\t\titem.addEventListener('pointermove', onPointerMove);\n\t\t\titem.addEventListener('pointerup', onPointerUp);\n\t\t\titem.addEventListener('pointercancel', onPointerCancel);\n\t\t};\n\n\t\tconst onPointerMove = (e: PointerEvent) => {\n\t\t\t// Check if we need to start dragging\n\t\t\tif (pendingDrag && !dragState) {\n\t\t\t\tconst dx = e.clientX - pendingDrag.startX;\n\t\t\t\tconst dy = e.clientY - pendingDrag.startY;\n\t\t\t\tconst distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\tif (distance >= DRAG_THRESHOLD) {\n\t\t\t\t\tstartDrag(pendingDrag, e);\n\t\t\t\t} else {\n\t\t\t\t\treturn; // Not enough movement yet\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dragState) return;\n\n\t\t\tconst { item, offsetX, offsetY, initialRect, colspan, rowspan } = dragState;\n\n\t\t\t// Move item with cursor\n\t\t\tconst newLeft = e.clientX - offsetX;\n\t\t\tconst newTop = e.clientY - offsetY;\n\t\t\titem.style.left = `${newLeft}px`;\n\t\t\titem.style.top = `${newTop}px`;\n\n\t\t\t// Calculate target based on card center (feels more natural for multi-cell items)\n\t\t\tlet cardCenterX = newLeft + initialRect.width / 2;\n\t\t\tlet cardCenterY = newTop + initialRect.height / 2;\n\n\t\t\t// Predictive offset: shift the effective center in the direction of movement\n\t\t\tconst gridInfo = core.getGridInfo();\n\t\t\tconst cumulativeDx = e.clientX - dragState.dragStartX;\n\t\t\tconst cumulativeDy = e.clientY - dragState.dragStartY;\n\n\t\t\t// Apply prediction offset when movement exceeds threshold\n\t\t\tif (Math.abs(cumulativeDx) > PREDICTION_THRESHOLD) {\n\t\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellWidth + gridInfo.gap);\n\t\t\t\tcardCenterX += Math.sign(cumulativeDx) * leadOffset;\n\t\t\t}\n\t\t\tif (Math.abs(cumulativeDy) > PREDICTION_THRESHOLD) {\n\t\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellHeight + gridInfo.gap);\n\t\t\t\tcardCenterY += Math.sign(cumulativeDy) * leadOffset;\n\t\t\t}\n\n\t\t\tconst rawCell = core.getCellFromPoint(cardCenterX, cardCenterY);\n\t\t\tif (rawCell) {\n\t\t\t\t// Clamp cell so item fits within grid bounds\n\t\t\t\tconst gridInfo = core.getGridInfo();\n\t\t\t\tconst maxColumn = Math.max(1, gridInfo.columns.length - colspan + 1);\n\t\t\t\tconst maxRow = Math.max(1, gridInfo.rows.length - rowspan + 1);\n\n\t\t\t\tconst cell: GridCell = {\n\t\t\t\t\tcolumn: Math.max(1, Math.min(maxColumn, rawCell.column)),\n\t\t\t\t\trow: Math.max(1, Math.min(maxRow, rawCell.row)),\n\t\t\t\t};\n\n\t\t\t\tconst now = performance.now();\n\t\t\t\tconst timeSinceLastChange = now - dragState.lastTargetChangeTime;\n\n\t\t\t\t// Check if cell actually changed\n\t\t\t\tconst cellChanged =\n\t\t\t\t\tcell.column !== dragState.lastCell.column ||\n\t\t\t\t\tcell.row !== dragState.lastCell.row;\n\n\t\t\t\tif (cellChanged && timeSinceLastChange >= TARGET_CHANGE_DEBOUNCE) {\n\t\t\t\t\tconst cellWidth = gridInfo.cellWidth + gridInfo.gap;\n\t\t\t\t\tconst cellHeight = gridInfo.cellHeight + gridInfo.gap;\n\n\t\t\t\t\t// Current cell center in pixels (CSS Grid is 1-indexed)\n\t\t\t\t\tconst currentCellCenterX =\n\t\t\t\t\t\tgridInfo.rect.left +\n\t\t\t\t\t\t(dragState.lastCell.column - 1) * cellWidth +\n\t\t\t\t\t\tgridInfo.cellWidth / 2;\n\t\t\t\t\tconst currentCellCenterY =\n\t\t\t\t\t\tgridInfo.rect.top +\n\t\t\t\t\t\t(dragState.lastCell.row - 1) * cellHeight +\n\t\t\t\t\t\tgridInfo.cellHeight / 2;\n\n\t\t\t\t\t// Signed distance from card center to current cell center (in grid units)\n\t\t\t\t\tconst offsetFromCellX = (cardCenterX - currentCellCenterX) / cellWidth;\n\t\t\t\t\tconst offsetFromCellY = (cardCenterY - currentCellCenterY) / cellHeight;\n\n\t\t\t\t\t// Direction-aware hysteresis\n\t\t\t\t\tconst newCellIsRight = cell.column > dragState.lastCell.column;\n\t\t\t\t\tconst newCellIsBelow = cell.row > dragState.lastCell.row;\n\t\t\t\t\tconst cardIsRight = offsetFromCellX > 0;\n\t\t\t\t\tconst cardIsBelow = offsetFromCellY > 0;\n\n\t\t\t\t\tconst alignedX = (newCellIsRight && cardIsRight) || (!newCellIsRight && !cardIsRight);\n\t\t\t\t\tconst alignedY = (newCellIsBelow && cardIsBelow) || (!newCellIsBelow && !cardIsBelow);\n\n\t\t\t\t\tconst thresholdX = alignedX ? 0.5 : 0.5 + HYSTERESIS;\n\t\t\t\t\tconst thresholdY = alignedY ? 0.5 : 0.5 + HYSTERESIS;\n\n\t\t\t\t\tconst distX = Math.abs(offsetFromCellX);\n\t\t\t\t\tconst distY = Math.abs(offsetFromCellY);\n\n\t\t\t\t\tif (distX < thresholdX && distY < thresholdY) {\n\t\t\t\t\t\treturn; // Stay in current cell\n\t\t\t\t\t}\n\n\t\t\t\t\tlog('drag-move', { cell, distX: distX.toFixed(2), distY: distY.toFixed(2) });\n\t\t\t\t\tdragState.lastCell = cell;\n\t\t\t\t\tdragState.lastTargetChangeTime = now;\n\t\t\t\t\tcore.emit('drag-move', { item, cell, x: e.clientX, y: e.clientY, colspan, rowspan });\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst onPointerUp = (e: PointerEvent) => {\n\t\t\tconst item = pendingDrag?.item || dragState?.item;\n\t\t\tif (!item) return;\n\n\t\t\t// If drag never started, this was just a click - nothing more to do\n\t\t\tif (pendingDrag && !dragState) {\n\t\t\t\tlog('click (no drag)');\n\t\t\t\tcleanupListeners(item, pendingDrag.pointerId);\n\t\t\t\tpendingDrag = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!dragState) return;\n\n\t\t\tconst { initialRect, colspan, rowspan, lastCell, offsetX, offsetY, dragStartX, dragStartY } = dragState;\n\n\t\t\t// Calculate drop position with same predictive offset as drag-move\n\t\t\tconst gridInfo = core.getGridInfo();\n\t\t\tconst cumulativeDx = e.clientX - dragStartX;\n\t\t\tconst cumulativeDy = e.clientY - dragStartY;\n\n\t\t\t// Apply prediction offset to get effective center for cell calculation\n\t\t\tconst newLeft = e.clientX - offsetX;\n\t\t\tconst newTop = e.clientY - offsetY;\n\t\t\tlet effectiveCenterX = newLeft + initialRect.width / 2;\n\t\t\tlet effectiveCenterY = newTop + initialRect.height / 2;\n\n\t\t\tif (Math.abs(cumulativeDx) > PREDICTION_THRESHOLD) {\n\t\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellWidth + gridInfo.gap);\n\t\t\t\teffectiveCenterX += Math.sign(cumulativeDx) * leadOffset;\n\t\t\t}\n\t\t\tif (Math.abs(cumulativeDy) > PREDICTION_THRESHOLD) {\n\t\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellHeight + gridInfo.gap);\n\t\t\t\teffectiveCenterY += Math.sign(cumulativeDy) * leadOffset;\n\t\t\t}\n\n\t\t\tconst rawCell = core.getCellFromPoint(effectiveCenterX, effectiveCenterY);\n\n\t\t\t// FLIP: Capture current visual position (First)\n\t\t\tconst firstRect = item.getBoundingClientRect();\n\n\t\t\t// Emit event BEFORE cleanup so algorithm can set final position\n\t\t\tif (rawCell) {\n\t\t\t\tconst maxColumn = Math.max(1, gridInfo.columns.length - colspan + 1);\n\t\t\t\tconst maxRow = Math.max(1, gridInfo.rows.length - rowspan + 1);\n\n\t\t\t\tconst cell: GridCell = {\n\t\t\t\t\tcolumn: Math.max(1, Math.min(maxColumn, rawCell.column)),\n\t\t\t\t\trow: Math.max(1, Math.min(maxRow, rawCell.row)),\n\t\t\t\t};\n\n\t\t\t\tlog('drag-end', { cell });\n\t\t\t\tcore.emit('drag-end', { item, cell, colspan, rowspan });\n\t\t\t} else {\n\t\t\t\tlog('drag-end', { cell: lastCell, note: 'using lastCell (pointer outside grid)' });\n\t\t\t\tcore.emit('drag-end', { item, cell: lastCell, colspan, rowspan });\n\t\t\t}\n\n\t\t\tcleanup();\n\n\t\t\t// FLIP: Animate from visual position to final grid position\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tlog('FLIP', { firstRect: { left: firstRect.left.toFixed(0), top: firstRect.top.toFixed(0) } });\n\t\t\t\tanimateFLIPWithTracking(item, firstRect);\n\t\t\t});\n\t\t};\n\n\t\tconst onPointerCancel = () => {\n\t\t\tconst item = pendingDrag?.item || dragState?.item;\n\t\t\tif (!item) return;\n\n\t\t\tif (dragState) {\n\t\t\t\tcore.emit('drag-cancel', { item });\n\t\t\t}\n\t\t\tcleanup();\n\t\t};\n\n\t\tconst cleanupListeners = (item: HTMLElement, pointerId: number) => {\n\t\t\titem.releasePointerCapture(pointerId);\n\t\t\titem.removeEventListener('pointermove', onPointerMove);\n\t\t\titem.removeEventListener('pointerup', onPointerUp);\n\t\t\titem.removeEventListener('pointercancel', onPointerCancel);\n\t\t};\n\n\t\tconst cleanup = () => {\n\t\t\tif (dragState) {\n\t\t\t\tconst { item, pointerId } = dragState;\n\n\t\t\t\titem.removeAttribute('data-gridiot-dragging');\n\t\t\t\tdocument.body.classList.remove('is-dragging');\n\t\t\t\titem.style.position = '';\n\t\t\t\titem.style.left = '';\n\t\t\t\titem.style.top = '';\n\t\t\t\titem.style.width = '';\n\t\t\t\titem.style.height = '';\n\t\t\t\titem.style.zIndex = '';\n\n\t\t\t\tcleanupListeners(item, pointerId);\n\t\t\t\tdragState = null;\n\t\t\t}\n\n\t\t\tif (pendingDrag) {\n\t\t\t\tcleanupListeners(pendingDrag.item, pendingDrag.pointerId);\n\t\t\t\tpendingDrag = null;\n\t\t\t}\n\t\t};\n\n\t\t// Deselect when clicking outside the grid\n\t\tconst onDocumentPointerDown = (e: PointerEvent) => {\n\t\t\tif (core.element.contains(e.target as Node)) return;\n\t\t\tif (dragState) return;\n\t\t\tcore.deselect();\n\t\t};\n\n\t\tcore.element.addEventListener('pointerdown', onPointerDown);\n\t\tdocument.addEventListener('pointerdown', onDocumentPointerDown);\n\n\t\treturn () => {\n\t\t\tcore.element.removeEventListener('pointerdown', onPointerDown);\n\t\t\tdocument.removeEventListener('pointerdown', onDocumentPointerDown);\n\t\t\tcleanup();\n\t\t};\n\t},\n});\n", "/**\n * Camera plugin for Gridiot\n *\n * Handles viewport scrolling to keep the active item visible:\n * - Auto-scroll when dragging near viewport edges\n * - Scroll into view when selecting items via keyboard\n *\n * The \"active item\" is: the dragged item during drag, or the selected item otherwise.\n */\n\nimport { registerPlugin } from '../engine';\nimport type {\n\tDragStartDetail,\n\tDragMoveDetail,\n\tDragEndDetail,\n\tDragCancelDetail,\n\tSelectDetail,\n\tDragState,\n\tGridiotCore,\n\tCameraPluginOptions,\n} from '../types';\n\nexport type CameraMode = 'contain' | 'center' | 'off';\n\nexport interface CameraOptions {\n\t/**\n\t * Scroll behavior mode:\n\t * - 'contain': Only scroll when item would leave viewport (default)\n\t * - 'center': Keep active item centered (can feel jarring)\n\t * - 'off': Disable camera scrolling\n\t */\n\tmode?: CameraMode;\n\n\t/**\n\t * The scrollable container. Defaults to the grid's scroll parent.\n\t * Pass `window` to scroll the document.\n\t */\n\tscrollContainer?: HTMLElement | Window;\n\n\t/**\n\t * Size of edge zones that trigger auto-scroll during drag (in pixels).\n\t * @default 60\n\t */\n\tedgeSize?: number;\n\n\t/**\n\t * Maximum scroll speed in pixels per frame.\n\t * @default 15\n\t */\n\tscrollSpeed?: number;\n\n\t/**\n\t * Scroll behavior for selection changes.\n\t * @default 'smooth'\n\t */\n\tscrollBehavior?: ScrollBehavior;\n\n\t/**\n\t * Margin around item when scrolling into view (in pixels).\n\t * @default 20\n\t */\n\tscrollMargin?: number;\n\n\t/**\n\t * Whether to scroll on selection changes (keyboard nav).\n\t * @default true\n\t */\n\tscrollOnSelect?: boolean;\n\n\t/**\n\t * Whether to auto-scroll during drag.\n\t * @default true\n\t */\n\tautoScrollOnDrag?: boolean;\n\n\t/**\n\t * Time in ms after scrolling stops before considered \"settled\".\n\t * Other plugins can check isScrolling() to defer updates.\n\t * @default 150\n\t */\n\tsettleDelay?: number;\n\n\t/**\n\t * Gridiot core instance for provider registration.\n\t * If provided, registers a 'camera' provider.\n\t */\n\tcore?: GridiotCore;\n}\n\n/**\n * Camera state exposed via provider registry.\n */\nexport interface CameraState {\n\t/** Whether the camera is actively auto-scrolling */\n\tisScrolling: boolean;\n\t/** Current camera mode */\n\tmode: CameraMode;\n}\n\nexport interface CameraInstance {\n\t/** Change the camera mode */\n\tsetMode(mode: CameraMode): void;\n\t/** Get current mode */\n\tgetMode(): CameraMode;\n\t/** Manually scroll an item into view */\n\tscrollTo(item: HTMLElement, behavior?: ScrollBehavior): void;\n\t/** Stop any active auto-scrolling */\n\tstop(): void;\n\t/** Clean up and remove event listeners */\n\tdestroy(): void;\n}\n\n/**\n * Find the nearest scrollable ancestor of an element.\n */\nfunction findScrollParent(element: HTMLElement): HTMLElement | Window {\n\tlet parent = element.parentElement;\n\n\twhile (parent) {\n\t\tconst style = getComputedStyle(parent);\n\t\tconst overflowY = style.overflowY;\n\t\tconst overflowX = style.overflowX;\n\n\t\tif (\n\t\t\toverflowY === 'auto' ||\n\t\t\toverflowY === 'scroll' ||\n\t\t\toverflowX === 'auto' ||\n\t\t\toverflowX === 'scroll'\n\t\t) {\n\t\t\treturn parent;\n\t\t}\n\n\t\tparent = parent.parentElement;\n\t}\n\n\treturn window;\n}\n\n/**\n * Get viewport rect for a scroll container.\n */\nfunction getViewportRect(\n\tcontainer: HTMLElement | Window\n): { top: number; left: number; width: number; height: number } {\n\tif (container === window) {\n\t\treturn {\n\t\t\ttop: 0,\n\t\t\tleft: 0,\n\t\t\twidth: window.innerWidth,\n\t\t\theight: window.innerHeight,\n\t\t};\n\t}\n\tconst rect = (container as HTMLElement).getBoundingClientRect();\n\treturn {\n\t\ttop: rect.top,\n\t\tleft: rect.left,\n\t\twidth: rect.width,\n\t\theight: rect.height,\n\t};\n}\n\n/**\n * Attach camera behavior to a Gridiot grid element.\n */\nexport function attachCamera(\n\tgridElement: HTMLElement,\n\toptions: CameraOptions = {}\n): CameraInstance {\n\tconst {\n\t\tmode: initialMode = 'contain',\n\t\tscrollContainer: customContainer,\n\t\tedgeSize = 60,\n\t\tscrollSpeed = 15,\n\t\tscrollBehavior = 'smooth',\n\t\tscrollMargin = 20,\n\t\tscrollOnSelect = true,\n\t\tautoScrollOnDrag = true,\n\t\tsettleDelay = 150,\n\t\tcore,\n\t} = options;\n\n\tlet mode = initialMode;\n\tlet scrollContainer = customContainer ?? findScrollParent(gridElement);\n\tlet animationFrameId: number | null = null;\n\tlet isDragging = false;\n\tlet sawPointerMove = false; // Track if we actually saw pointer movement\n\tlet lastPointerX = 0;\n\tlet lastPointerY = 0;\n\tlet isScrolling = false;\n\tlet settleTimeoutId: ReturnType<typeof setTimeout> | null = null;\n\n\t// Register provider if core is provided\n\tif (core) {\n\t\tcore.providers.register<CameraState>('camera', () => ({\n\t\t\tisScrolling,\n\t\t\tmode,\n\t\t}));\n\t}\n\n\t/**\n\t * Mark scrolling as active, with settle timeout.\n\t */\n\tfunction setScrolling(active: boolean): void {\n\t\tif (active) {\n\t\t\tisScrolling = true;\n\t\t\tif (settleTimeoutId) {\n\t\t\t\tclearTimeout(settleTimeoutId);\n\t\t\t\tsettleTimeoutId = null;\n\t\t\t}\n\t\t} else {\n\t\t\t// Start settle timer\n\t\t\tif (settleTimeoutId) clearTimeout(settleTimeoutId);\n\t\t\tsettleTimeoutId = setTimeout(() => {\n\t\t\t\tisScrolling = false;\n\t\t\t\tsettleTimeoutId = null;\n\t\t\t\t// Emit settle event so algorithm can recalculate\n\t\t\t\tgridElement.dispatchEvent(\n\t\t\t\t\tnew CustomEvent('gridiot:camera-settled', { bubbles: true })\n\t\t\t\t);\n\t\t\t}, settleDelay);\n\t\t}\n\t}\n\n\t/**\n\t * Scroll an item into view based on current mode.\n\t */\n\tfunction scrollTo(item: HTMLElement, behavior: ScrollBehavior = scrollBehavior): void {\n\t\tif (mode === 'off') return;\n\n\t\tconst itemRect = item.getBoundingClientRect();\n\t\tconst viewport = getViewportRect(scrollContainer);\n\n\t\tif (mode === 'center') {\n\t\t\t// Center the item in the viewport\n\t\t\tconst targetScrollTop =\n\t\t\t\tscrollContainer === window\n\t\t\t\t\t? window.scrollY + itemRect.top - viewport.height / 2 + itemRect.height / 2\n\t\t\t\t\t: (scrollContainer as HTMLElement).scrollTop +\n\t\t\t\t\t\titemRect.top -\n\t\t\t\t\t\tviewport.top -\n\t\t\t\t\t\tviewport.height / 2 +\n\t\t\t\t\t\titemRect.height / 2;\n\n\t\t\tconst targetScrollLeft =\n\t\t\t\tscrollContainer === window\n\t\t\t\t\t? window.scrollX + itemRect.left - viewport.width / 2 + itemRect.width / 2\n\t\t\t\t\t: (scrollContainer as HTMLElement).scrollLeft +\n\t\t\t\t\t\titemRect.left -\n\t\t\t\t\t\tviewport.left -\n\t\t\t\t\t\tviewport.width / 2 +\n\t\t\t\t\t\titemRect.width / 2;\n\n\t\t\tif (scrollContainer === window) {\n\t\t\t\twindow.scrollTo({ top: targetScrollTop, left: targetScrollLeft, behavior });\n\t\t\t} else {\n\t\t\t\t(scrollContainer as HTMLElement).scrollTo({\n\t\t\t\t\ttop: targetScrollTop,\n\t\t\t\t\tleft: targetScrollLeft,\n\t\t\t\t\tbehavior,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t// 'contain' mode - use CSS scroll-margin with scrollIntoView\n\t\t\t// The scroll-margin should be set in CSS on items (or we set it here)\n\t\t\t// This lets the browser handle all the positioning math\n\n\t\t\titem.scrollIntoView({\n\t\t\t\tbehavior,\n\t\t\t\tblock: 'nearest',\n\t\t\t\tinline: 'nearest',\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Calculate scroll velocity based on pointer position relative to edges.\n\t */\n\tfunction getEdgeScrollVelocity(\n\t\tpointerX: number,\n\t\tpointerY: number\n\t): { x: number; y: number } {\n\t\tconst viewport = getViewportRect(scrollContainer);\n\t\tlet velocityX = 0;\n\t\tlet velocityY = 0;\n\n\t\t// Pointer position relative to viewport\n\t\tconst relativeX = pointerX - viewport.left;\n\t\tconst relativeY = pointerY - viewport.top;\n\n\t\t// Check horizontal edges\n\t\tif (relativeX < edgeSize) {\n\t\t\t// Near left edge - scroll left (negative)\n\t\t\tvelocityX = -scrollSpeed * (1 - relativeX / edgeSize);\n\t\t} else if (relativeX > viewport.width - edgeSize) {\n\t\t\t// Near right edge - scroll right (positive)\n\t\t\tvelocityX = scrollSpeed * (1 - (viewport.width - relativeX) / edgeSize);\n\t\t}\n\n\t\t// Check vertical edges\n\t\tif (relativeY < edgeSize) {\n\t\t\t// Near top edge - scroll up (negative)\n\t\t\tvelocityY = -scrollSpeed * (1 - relativeY / edgeSize);\n\t\t} else if (relativeY > viewport.height - edgeSize) {\n\t\t\t// Near bottom edge - scroll down (positive)\n\t\t\tvelocityY = scrollSpeed * (1 - (viewport.height - relativeY) / edgeSize);\n\t\t}\n\n\t\treturn { x: velocityX, y: velocityY };\n\t}\n\n\t/**\n\t * Animation loop for edge scrolling during drag.\n\t */\n\tlet wasScrollingLastFrame = false;\n\n\tfunction scrollLoop(): void {\n\t\tif (!isDragging || !autoScrollOnDrag || mode === 'off') {\n\t\t\tanimationFrameId = null;\n\t\t\tif (wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(false);\n\t\t\t\twasScrollingLastFrame = false;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconst velocity = getEdgeScrollVelocity(lastPointerX, lastPointerY);\n\t\tconst isNearEdge = velocity.x !== 0 || velocity.y !== 0;\n\n\t\tif (isNearEdge) {\n\t\t\tif (!wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(true);\n\t\t\t}\n\t\t\twasScrollingLastFrame = true;\n\t\t\tif (scrollContainer === window) {\n\t\t\t\twindow.scrollBy(velocity.x, velocity.y);\n\t\t\t} else {\n\t\t\t\t(scrollContainer as HTMLElement).scrollLeft += velocity.x;\n\t\t\t\t(scrollContainer as HTMLElement).scrollTop += velocity.y;\n\t\t\t}\n\t\t} else {\n\t\t\t// Not near edge\n\t\t\tif (wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(false);\n\t\t\t\twasScrollingLastFrame = false;\n\t\t\t}\n\t\t}\n\n\t\tanimationFrameId = requestAnimationFrame(scrollLoop);\n\t}\n\n\t/**\n\t * Start the scroll loop.\n\t */\n\tfunction startScrollLoop(): void {\n\t\tif (animationFrameId === null) {\n\t\t\tanimationFrameId = requestAnimationFrame(scrollLoop);\n\t\t}\n\t}\n\n\t/**\n\t * Stop the scroll loop.\n\t */\n\tfunction stopScrollLoop(): void {\n\t\tif (animationFrameId !== null) {\n\t\t\tcancelAnimationFrame(animationFrameId);\n\t\t\tanimationFrameId = null;\n\t\t}\n\t\tsetScrolling(false);\n\t}\n\n\t// Track pointer position continuously during drag (not just on cell change)\n\tfunction onPointerMove(e: PointerEvent): void {\n\t\tif (!isDragging || !autoScrollOnDrag || mode === 'off') return;\n\n\t\tsawPointerMove = true;\n\t\tlastPointerX = e.clientX;\n\t\tlastPointerY = e.clientY;\n\t\tstartScrollLoop();\n\t}\n\n\t// Event handlers\n\tfunction onDragStart(e: CustomEvent<DragStartDetail>): void {\n\t\tisDragging = true;\n\t\tsawPointerMove = false; // Reset - will be set true if pointer actually moves\n\t\t// Start listening for pointer moves on window to track edge proximity\n\t\twindow.addEventListener('pointermove', onPointerMove);\n\t}\n\n\tfunction onDragMove(e: CustomEvent<DragMoveDetail>): void {\n\t\tif (mode === 'off') return;\n\n\t\t// For pointer drag: update position for edge detection\n\t\tif (e.detail.x !== 0 || e.detail.y !== 0) {\n\t\t\tlastPointerX = e.detail.x;\n\t\t\tlastPointerY = e.detail.y;\n\t\t} else {\n\t\t\t// Keyboard drag (x/y are 0) - scroll to keep item visible\n\t\t\t// Use requestAnimationFrame to let the DOM update first\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tscrollTo(e.detail.item, 'smooth');\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction onDragEnd(e: CustomEvent<DragEndDetail>): void {\n\t\tconst wasPointerDrag = sawPointerMove; // Only true if pointer actually moved\n\t\tisDragging = false;\n\t\tsawPointerMove = false;\n\t\tstopScrollLoop();\n\t\twindow.removeEventListener('pointermove', onPointerMove);\n\n\t\t// For keyboard moves (nudge), scroll to keep item visible after it moves\n\t\t// Pointer drags handle their own scrolling via edge detection\n\t\tif (!wasPointerDrag && scrollOnSelect) {\n\t\t\t// Wait for layout to settle (view transitions may be animating)\n\t\t\t// Use setTimeout + rAF to ensure DOM has updated\n\t\t\tsetTimeout(() => {\n\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\tscrollTo(e.detail.item, 'smooth');\n\t\t\t\t});\n\t\t\t}, 100);\n\t\t}\n\t}\n\n\tfunction onDragCancel(e: CustomEvent<DragCancelDetail>): void {\n\t\tisDragging = false;\n\t\tstopScrollLoop();\n\t\twindow.removeEventListener('pointermove', onPointerMove);\n\t}\n\n\tfunction onSelect(e: CustomEvent<SelectDetail>): void {\n\t\tif (!scrollOnSelect || mode === 'off') return;\n\n\t\t// Don't scroll during drag - the drag handles its own scrolling\n\t\tif (isDragging) return;\n\n\t\tscrollTo(e.detail.item);\n\t}\n\n\t// Attach event listeners\n\tgridElement.addEventListener(\n\t\t'gridiot:drag-start',\n\t\tonDragStart as EventListener\n\t);\n\tgridElement.addEventListener(\n\t\t'gridiot:drag-move',\n\t\tonDragMove as EventListener\n\t);\n\tgridElement.addEventListener('gridiot:drag-end', onDragEnd as EventListener);\n\tgridElement.addEventListener(\n\t\t'gridiot:drag-cancel',\n\t\tonDragCancel as EventListener\n\t);\n\tgridElement.addEventListener('gridiot:select', onSelect as EventListener);\n\n\tfunction destroy(): void {\n\t\tstopScrollLoop();\n\t\tgridElement.removeEventListener(\n\t\t\t'gridiot:drag-start',\n\t\t\tonDragStart as EventListener\n\t\t);\n\t\tgridElement.removeEventListener(\n\t\t\t'gridiot:drag-move',\n\t\t\tonDragMove as EventListener\n\t\t);\n\t\tgridElement.removeEventListener(\n\t\t\t'gridiot:drag-end',\n\t\t\tonDragEnd as EventListener\n\t\t);\n\t\tgridElement.removeEventListener(\n\t\t\t'gridiot:drag-cancel',\n\t\t\tonDragCancel as EventListener\n\t\t);\n\t\tgridElement.removeEventListener(\n\t\t\t'gridiot:select',\n\t\t\tonSelect as EventListener\n\t\t);\n\t}\n\n\treturn {\n\t\tsetMode(newMode: CameraMode): void {\n\t\t\tmode = newMode;\n\t\t\tif (mode === 'off') {\n\t\t\t\tstopScrollLoop();\n\t\t\t}\n\t\t},\n\t\tgetMode(): CameraMode {\n\t\t\treturn mode;\n\t\t},\n\t\tscrollTo,\n\t\tstop: stopScrollLoop,\n\t\tdestroy,\n\t};\n}\n\n// Register as a plugin for auto-initialization via init()\nregisterPlugin({\n\tname: 'camera',\n\tinit(core, options?: CameraPluginOptions & { core?: GridiotCore }) {\n\t\tconst instance = attachCamera(core.element, {\n\t\t\t...options,\n\t\t\tcore: options?.core ?? core,\n\t\t});\n\t\treturn () => instance.destroy();\n\t},\n});\n", "/**\n * Resize plugin for Gridiot\n *\n * Allows users to resize grid items by dragging corners/edges.\n * Resizes modify colspan/rowspan using actual CSS grid changes during resize.\n *\n * Usage:\n *   import { attachResize } from 'gridiot/resize';\n *\n *   const detach = attachResize(gridElement, {\n *     core,                 // GridiotCore instance (required)\n *     handles: 'corners',   // 'corners' | 'edges' | 'all'\n *     handleSize: 12,\n *     minSize: { colspan: 1, rowspan: 1 },\n *     maxSize: { colspan: 6, rowspan: 6 },\n *   });\n */\n\nimport { registerPlugin } from '../engine';\nimport type {\n\tGridCell,\n\tGridiotCore,\n\tResizeCancelDetail,\n\tResizeEndDetail,\n\tResizeHandle,\n\tResizeMoveDetail,\n\tResizePluginOptions,\n\tResizeStartDetail,\n\tResizeState,\n} from '../types';\nimport { animateFLIPWithTracking } from '../utils/flip';\n\nexport interface ResizeOptions {\n\t/** GridiotCore instance (required) */\n\tcore: GridiotCore;\n\t/** Which handles to show: 'corners' | 'edges' | 'all' (default: 'corners') */\n\thandles?: 'corners' | 'edges' | 'all';\n\t/** Size of the hit zone for handles in pixels (default: 12) */\n\thandleSize?: number;\n\t/** Minimum size in grid cells (default: { colspan: 1, rowspan: 1 }) */\n\tminSize?: { colspan: number; rowspan: number };\n\t/** Maximum size in grid cells (default: { colspan: 6, rowspan: 6 }) */\n\tmaxSize?: { colspan: number; rowspan: number };\n\t/** Show size label during resize (default: true) */\n\tshowSizeLabel?: boolean;\n}\n\ninterface ActiveResize {\n\titem: HTMLElement;\n\tpointerId: number;\n\thandle: ResizeHandle;\n\t/** Original cell position at start of resize - never changes */\n\tstartCell: GridCell;\n\t/** Original size at start of resize - never changes */\n\toriginalSize: { colspan: number; rowspan: number };\n\t/** Current position (may differ from startCell for NW/NE/SW handles) */\n\tcurrentCell: GridCell;\n\t/** Current size during resize */\n\tcurrentSize: { colspan: number; rowspan: number };\n\toriginalGridColumn: string;\n\toriginalGridRow: string;\n\tsizeLabel: HTMLElement | null;\n\t/** Initial bounding rect for smooth resize */\n\tinitialRect: DOMRect;\n\t/** Pointer position at start */\n\tstartPointerX: number;\n\tstartPointerY: number;\n\t/** Placeholder element (currently unused but kept for API compatibility) */\n\tplaceholder: HTMLElement | null;\n}\n\n\n/**\n * Detect which resize handle (if any) is under the pointer\n */\nfunction detectHandle(\n\te: PointerEvent,\n\titem: HTMLElement,\n\tsize: number,\n\tmode: 'corners' | 'edges' | 'all',\n): ResizeHandle | null {\n\tconst rect = item.getBoundingClientRect();\n\tconst x = e.clientX - rect.left;\n\tconst y = e.clientY - rect.top;\n\n\tconst nearLeft = x < size;\n\tconst nearRight = x > rect.width - size;\n\tconst nearTop = y < size;\n\tconst nearBottom = y > rect.height - size;\n\n\t// Corners\n\tif (mode === 'corners' || mode === 'all') {\n\t\tif (nearTop && nearLeft) return 'nw';\n\t\tif (nearTop && nearRight) return 'ne';\n\t\tif (nearBottom && nearLeft) return 'sw';\n\t\tif (nearBottom && nearRight) return 'se';\n\t}\n\n\t// Edges (only if not at corners)\n\tif (mode === 'edges' || mode === 'all') {\n\t\tif (nearTop) return 'n';\n\t\tif (nearBottom) return 's';\n\t\tif (nearLeft) return 'w';\n\t\tif (nearRight) return 'e';\n\t}\n\n\treturn null;\n}\n\n/**\n * Get cursor style for a resize handle\n */\nfunction getCursor(handle: ResizeHandle | null): string {\n\tswitch (handle) {\n\t\tcase 'nw':\n\t\tcase 'se':\n\t\t\treturn 'nwse-resize';\n\t\tcase 'ne':\n\t\tcase 'sw':\n\t\t\treturn 'nesw-resize';\n\t\tcase 'n':\n\t\tcase 's':\n\t\t\treturn 'ns-resize';\n\t\tcase 'e':\n\t\tcase 'w':\n\t\t\treturn 'ew-resize';\n\t\tdefault:\n\t\t\treturn '';\n\t}\n}\n\n/**\n * Calculate new size based on pointer position and handle\n */\nfunction calculateNewSize(\n\tcore: GridiotCore,\n\thandle: ResizeHandle,\n\tstartCell: GridCell,\n\toriginalSize: { colspan: number; rowspan: number },\n\tpointerX: number,\n\tpointerY: number,\n\tminSize: { colspan: number; rowspan: number },\n\tmaxSize: { colspan: number; rowspan: number },\n): { colspan: number; rowspan: number; column: number; row: number } {\n\tconst gridInfo = core.getGridInfo();\n\tconst maxColumn = gridInfo.columns.length;\n\tconst maxRow = gridInfo.rows.length;\n\n\t// Get pointer cell, clamping to grid bounds if outside\n\t// This allows resizing to continue even when pointer is outside grid\n\tlet pointerCell = core.getCellFromPoint(pointerX, pointerY);\n\tif (!pointerCell) {\n\t\t// Clamp to grid bounds based on pointer position relative to grid\n\t\tconst rect = gridInfo.rect;\n\t\tconst cellWidth = gridInfo.cellWidth + gridInfo.gap;\n\t\tconst cellHeight = gridInfo.cellHeight + gridInfo.gap;\n\n\t\tlet column: number;\n\t\tlet row: number;\n\n\t\tif (pointerX < rect.left) {\n\t\t\tcolumn = 1;\n\t\t} else if (pointerX > rect.right) {\n\t\t\tcolumn = maxColumn;\n\t\t} else {\n\t\t\tcolumn = Math.max(1, Math.min(maxColumn, Math.floor((pointerX - rect.left) / cellWidth) + 1));\n\t\t}\n\n\t\tif (pointerY < rect.top) {\n\t\t\trow = 1;\n\t\t} else if (pointerY > rect.bottom) {\n\t\t\trow = maxRow;\n\t\t} else {\n\t\t\trow = Math.max(1, Math.min(maxRow, Math.floor((pointerY - rect.top) / cellHeight) + 1));\n\t\t}\n\n\t\tpointerCell = { column, row };\n\t}\n\n\tlet newColspan = originalSize.colspan;\n\tlet newRowspan = originalSize.rowspan;\n\tlet newColumn = startCell.column;\n\tlet newRow = startCell.row;\n\n\t// Handle horizontal resizing\n\tif (handle === 'e' || handle === 'se' || handle === 'ne') {\n\t\t// Right edge: column stays, span grows right\n\t\tnewColspan = Math.max(\n\t\t\tminSize.colspan,\n\t\t\tMath.min(\n\t\t\t\tmaxSize.colspan,\n\t\t\t\tpointerCell.column - startCell.column + 1,\n\t\t\t\tmaxColumn - startCell.column + 1,\n\t\t\t),\n\t\t);\n\t} else if (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t// Left edge: column moves left, right edge stays fixed\n\t\tconst rightEdge = startCell.column + originalSize.colspan - 1;\n\t\tconst newLeft = Math.max(1, Math.min(pointerCell.column, rightEdge));\n\t\tnewColspan = Math.max(\n\t\t\tminSize.colspan,\n\t\t\tMath.min(maxSize.colspan, rightEdge - newLeft + 1),\n\t\t);\n\t\tnewColumn = rightEdge - newColspan + 1;\n\t}\n\n\t// Handle vertical resizing\n\tif (handle === 's' || handle === 'se' || handle === 'sw') {\n\t\t// Bottom edge: row stays, span grows down\n\t\tnewRowspan = Math.max(\n\t\t\tminSize.rowspan,\n\t\t\tMath.min(\n\t\t\t\tmaxSize.rowspan,\n\t\t\t\tpointerCell.row - startCell.row + 1,\n\t\t\t\tmaxRow - startCell.row + 1,\n\t\t\t),\n\t\t);\n\t} else if (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t// Top edge: row moves up, bottom edge stays fixed\n\t\tconst bottomEdge = startCell.row + originalSize.rowspan - 1;\n\t\tconst newTop = Math.max(1, Math.min(pointerCell.row, bottomEdge));\n\t\tnewRowspan = Math.max(\n\t\t\tminSize.rowspan,\n\t\t\tMath.min(maxSize.rowspan, bottomEdge - newTop + 1),\n\t\t);\n\t\tnewRow = bottomEdge - newRowspan + 1;\n\t}\n\n\treturn {\n\t\tcolspan: newColspan,\n\t\trowspan: newRowspan,\n\t\tcolumn: newColumn,\n\t\trow: newRow,\n\t};\n}\n\n/**\n * Create a size label element\n */\nfunction createSizeLabel(): HTMLElement {\n\tconst label = document.createElement('div');\n\tlabel.className = 'gridiot-resize-label';\n\tlabel.style.cssText = `\n\t\tposition: absolute;\n\t\ttop: 50%;\n\t\tleft: 50%;\n\t\ttransform: translate(-50%, -50%);\n\t\tbackground: rgba(0, 0, 0, 0.8);\n\t\tcolor: white;\n\t\tpadding: 4px 8px;\n\t\tborder-radius: 4px;\n\t\tfont-size: 14px;\n\t\tfont-weight: 600;\n\t\tfont-family: system-ui, sans-serif;\n\t\tpointer-events: none;\n\t\tz-index: 1000;\n\t\twhite-space: nowrap;\n\t`;\n\treturn label;\n}\n\n/**\n * Attach resize functionality to a grid element.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach resize\n */\nexport function attachResize(\n\tgridElement: HTMLElement,\n\toptions: ResizeOptions,\n): {\n\tsetSize(item: HTMLElement, size: { colspan: number; rowspan: number }): void;\n\tdestroy(): void;\n} {\n\tconst {\n\t\tcore,\n\t\thandles = 'corners',\n\t\thandleSize = 12,\n\t\tminSize = { colspan: 1, rowspan: 1 },\n\t\tmaxSize = { colspan: 6, rowspan: 6 },\n\t\tshowSizeLabel = true,\n\t} = options;\n\n\tlet activeResize: ActiveResize | null = null;\n\tlet hoveredItem: HTMLElement | null = null;\n\tlet hoveredHandle: ResizeHandle | null = null;\n\n\t// Register provider for inter-plugin state access\n\tcore.providers.register<ResizeState | null>('resize', () => {\n\t\tif (!activeResize) return null;\n\t\treturn {\n\t\t\titem: activeResize.item,\n\t\t\toriginalSize: activeResize.originalSize,\n\t\t\tcurrentSize: activeResize.currentSize,\n\t\t\thandle: activeResize.handle,\n\t\t};\n\t});\n\n\tfunction emit<T>(event: string, detail: T): void {\n\t\tgridElement.dispatchEvent(\n\t\t\tnew CustomEvent(`gridiot:${event}`, {\n\t\t\t\tbubbles: true,\n\t\t\t\tdetail,\n\t\t\t}),\n\t\t);\n\t}\n\n\tfunction startResize(item: HTMLElement, handle: ResizeHandle, e: PointerEvent) {\n\t\tconst colspan =\n\t\t\tparseInt(item.getAttribute('data-gridiot-colspan') || '1', 10) || 1;\n\t\tconst rowspan =\n\t\t\tparseInt(item.getAttribute('data-gridiot-rowspan') || '1', 10) || 1;\n\n\t\tconst style = getComputedStyle(item);\n\t\tconst column = parseInt(style.gridColumnStart, 10) || 1;\n\t\tconst row = parseInt(style.gridRowStart, 10) || 1;\n\n\t\tconst originalSize = { colspan, rowspan };\n\t\tconst startCell = { column, row };\n\t\tconst initialRect = item.getBoundingClientRect();\n\n\t\t// Create size label if enabled\n\t\tlet sizeLabel: HTMLElement | null = null;\n\t\tif (showSizeLabel) {\n\t\t\tsizeLabel = createSizeLabel();\n\t\t\tsizeLabel.textContent = `${colspan}\u00D7${rowspan}`;\n\t\t\titem.appendChild(sizeLabel);\n\t\t}\n\n\t\tactiveResize = {\n\t\t\titem,\n\t\t\tpointerId: e.pointerId,\n\t\t\thandle,\n\t\t\tstartCell,\n\t\t\toriginalSize,\n\t\t\tcurrentCell: { ...startCell },\n\t\t\tcurrentSize: { ...originalSize },\n\t\t\toriginalGridColumn: item.style.gridColumn,\n\t\t\toriginalGridRow: item.style.gridRow,\n\t\t\tsizeLabel,\n\t\t\tinitialRect,\n\t\t\tstartPointerX: e.clientX,\n\t\t\tstartPointerY: e.clientY,\n\t\t\tplaceholder: null, // Will be set below if enabled\n\t\t};\n\n\t\titem.setAttribute('data-gridiot-resizing', '');\n\t\titem.setAttribute('data-gridiot-handle-active', handle);\n\t\titem.removeAttribute('data-gridiot-handle-hover'); // Clear hover state\n\t\titem.setPointerCapture(e.pointerId);\n\n\t\t// Add event listeners to item (pointer capture sends events to this element)\n\t\titem.addEventListener('pointermove', onItemPointerMove);\n\t\titem.addEventListener('pointerup', onItemPointerUp);\n\t\titem.addEventListener('pointercancel', onItemPointerCancel);\n\n\t\t// Emit resize-start BEFORE changing grid styles so originalPositions captures correct layout\n\t\temit<ResizeStartDetail>('resize-start', {\n\t\t\titem,\n\t\t\tcell: startCell,\n\t\t\tcolspan: originalSize.colspan,\n\t\t\trowspan: originalSize.rowspan,\n\t\t\thandle,\n\t\t});\n\n\t\tactiveResize.placeholder = null;\n\n\t\t// Switch to fixed positioning - item follows cursor in viewport coordinates\n\t\t// CSS Grid ignores fixed positioned children, allowing the grid to reflow\n\t\titem.style.position = 'fixed';\n\t\titem.style.left = `${initialRect.left}px`;\n\t\titem.style.top = `${initialRect.top}px`;\n\t\titem.style.width = `${initialRect.width}px`;\n\t\titem.style.height = `${initialRect.height}px`;\n\t\titem.style.zIndex = '100';\n\t\t// Exclude from view transitions during resize\n\t\titem.style.viewTransitionName = 'resizing';\n\t}\n\n\tfunction updateResize(e: PointerEvent) {\n\t\tif (!activeResize) return;\n\n\t\tconst { item, handle, startCell, originalSize, currentCell, currentSize, sizeLabel, initialRect, startPointerX, startPointerY } =\n\t\t\tactiveResize;\n\n\t\tconst gridInfo = core.getGridInfo();\n\n\t\t// Calculate pointer delta\n\t\tconst deltaX = e.clientX - startPointerX;\n\t\tconst deltaY = e.clientY - startPointerY;\n\n\t\t// Calculate new visual dimensions based on handle\n\t\tlet newWidth = initialRect.width;\n\t\tlet newHeight = initialRect.height;\n\t\tlet newLeft = initialRect.left;\n\t\tlet newTop = initialRect.top;\n\n\t\t// Minimum visual size (1 cell)\n\t\tconst minWidth = gridInfo.cellWidth;\n\t\tconst minHeight = gridInfo.cellHeight;\n\t\t// Maximum visual size (clamped by maxSize config)\n\t\tconst maxWidthByConfig = maxSize.colspan * gridInfo.cellWidth + (maxSize.colspan - 1) * gridInfo.gap;\n\t\tconst maxHeightByConfig = maxSize.rowspan * gridInfo.cellHeight + (maxSize.rowspan - 1) * gridInfo.gap;\n\t\t// Maximum visual size (clamped by grid bounds)\n\t\tconst maxWidthByGrid = gridInfo.rect.right - initialRect.left;\n\t\tconst maxHeightByGrid = gridInfo.rect.bottom - initialRect.top;\n\t\tconst maxWidth = Math.min(maxWidthByConfig, maxWidthByGrid);\n\t\tconst maxHeight = Math.min(maxHeightByConfig, maxHeightByGrid);\n\n\t\t// Apply delta based on handle direction\n\t\tif (handle === 'e' || handle === 'se' || handle === 'ne') {\n\t\t\tnewWidth = Math.max(minWidth, Math.min(maxWidth, initialRect.width + deltaX));\n\t\t}\n\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t\t// For left edge, clamp to grid left\n\t\t\tconst maxLeftShift = initialRect.left - gridInfo.rect.left;\n\t\t\tconst maxWidthFromLeft = Math.min(maxWidthByConfig, initialRect.width + maxLeftShift);\n\t\t\tconst widthChange = Math.max(-initialRect.width + minWidth, Math.min(maxWidthFromLeft - initialRect.width, -deltaX));\n\t\t\tnewWidth = initialRect.width + widthChange;\n\t\t\tnewLeft = initialRect.left - widthChange;\n\t\t}\n\t\tif (handle === 's' || handle === 'se' || handle === 'sw') {\n\t\t\tnewHeight = Math.max(minHeight, Math.min(maxHeight, initialRect.height + deltaY));\n\t\t}\n\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t\t// For top edge, clamp to grid top\n\t\t\tconst maxTopShift = initialRect.top - gridInfo.rect.top;\n\t\t\tconst maxHeightFromTop = Math.min(maxHeightByConfig, initialRect.height + maxTopShift);\n\t\t\tconst heightChange = Math.max(-initialRect.height + minHeight, Math.min(maxHeightFromTop - initialRect.height, -deltaY));\n\t\t\tnewHeight = initialRect.height + heightChange;\n\t\t\tnewTop = initialRect.top - heightChange;\n\t\t}\n\n\t\t// Apply smooth visual size (fixed positioning uses viewport coordinates)\n\t\titem.style.left = `${newLeft}px`;\n\t\titem.style.top = `${newTop}px`;\n\t\titem.style.width = `${newWidth}px`;\n\t\titem.style.height = `${newHeight}px`;\n\n\t\t// Calculate projected final grid size (what it will snap to)\n\t\tconst cellPlusGap = gridInfo.cellWidth + gridInfo.gap;\n\t\tconst rowPlusGap = gridInfo.cellHeight + gridInfo.gap;\n\n\t\t// Calculate raw ratios\n\t\tconst rawColspanRatio = (newWidth + gridInfo.gap) / cellPlusGap;\n\t\tconst rawRowspanRatio = (newHeight + gridInfo.gap) / rowPlusGap;\n\n\t\t// Bias calculation for resize direction:\n\t\t// When resizing SE (making bigger), use a lower threshold (0.3 instead of 0.5)\n\t\t// to be more generous about giving the user the larger size\n\t\tconst isGrowingWidth = handle === 'e' || handle === 'se' || handle === 'ne';\n\t\tconst isGrowingHeight = handle === 's' || handle === 'se' || handle === 'sw';\n\n\t\t// Use floor + threshold approach for more predictable snapping\n\t\t// If we're past 30% into the next cell when growing, give the user that cell\n\t\tconst GROW_THRESHOLD = 0.3;\n\t\tconst SHRINK_THRESHOLD = 0.7;\n\n\t\tlet projectedColspan: number;\n\t\tlet projectedRowspan: number;\n\n\t\tif (isGrowingWidth) {\n\t\t\t// When growing: floor, then add 1 if we're past the threshold\n\t\t\tprojectedColspan = Math.floor(rawColspanRatio);\n\t\t\tif (rawColspanRatio - projectedColspan >= GROW_THRESHOLD) {\n\t\t\t\tprojectedColspan += 1;\n\t\t\t}\n\t\t} else {\n\t\t\t// When shrinking: ceil, then subtract 1 if we're below the threshold\n\t\t\tprojectedColspan = Math.ceil(rawColspanRatio);\n\t\t\tif (projectedColspan - rawColspanRatio > (1 - SHRINK_THRESHOLD)) {\n\t\t\t\tprojectedColspan -= 1;\n\t\t\t}\n\t\t}\n\n\t\tif (isGrowingHeight) {\n\t\t\tprojectedRowspan = Math.floor(rawRowspanRatio);\n\t\t\tif (rawRowspanRatio - projectedRowspan >= GROW_THRESHOLD) {\n\t\t\t\tprojectedRowspan += 1;\n\t\t\t}\n\t\t} else {\n\t\t\tprojectedRowspan = Math.ceil(rawRowspanRatio);\n\t\t\tif (projectedRowspan - rawRowspanRatio > (1 - SHRINK_THRESHOLD)) {\n\t\t\t\tprojectedRowspan -= 1;\n\t\t\t}\n\t\t}\n\n\t\t// Apply min/max constraints\n\t\tprojectedColspan = Math.max(minSize.colspan, Math.min(maxSize.colspan, projectedColspan));\n\t\tprojectedRowspan = Math.max(minSize.rowspan, Math.min(maxSize.rowspan, projectedRowspan));\n\n\t\t// Calculate the cell position based on the projected size and anchor corner.\n\t\t// This ensures the anchor corner stays fixed and the cell + size are consistent.\n\t\t// Previously we used calculateNewSize() which computed position from pointer,\n\t\t// but that could mismatch with the visual-based size calculation.\n\t\tlet projectedColumn = startCell.column;\n\t\tlet projectedRow = startCell.row;\n\n\t\t// For handles that move the left edge, calculate column from the right anchor\n\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t\tconst rightEdge = startCell.column + originalSize.colspan - 1;\n\t\t\tprojectedColumn = rightEdge - projectedColspan + 1;\n\t\t}\n\n\t\t// For handles that move the top edge, calculate row from the bottom anchor\n\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t\tconst bottomEdge = startCell.row + originalSize.rowspan - 1;\n\t\t\tprojectedRow = bottomEdge - projectedRowspan + 1;\n\t\t}\n\n\t\t// Update tracking\n\t\tactiveResize.currentSize = { colspan: projectedColspan, rowspan: projectedRowspan };\n\t\tactiveResize.currentCell = { column: projectedColumn, row: projectedRow };\n\n\t\t// Update size label with projected final size\n\t\tif (sizeLabel) {\n\t\t\tsizeLabel.textContent = `${projectedColspan}\u00D7${projectedRowspan}`;\n\t\t}\n\n\t\t// Calculate anchor cell (the corner that stays fixed during resize)\n\t\tlet anchorCell: GridCell;\n\t\tif (handle === 'se' || handle === 's' || handle === 'e') {\n\t\t\t// NW corner is anchor\n\t\t\tanchorCell = { column: startCell.column, row: startCell.row };\n\t\t} else if (handle === 'nw' || handle === 'n' || handle === 'w') {\n\t\t\t// SE corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column + originalSize.colspan - 1,\n\t\t\t\trow: startCell.row + originalSize.rowspan - 1,\n\t\t\t};\n\t\t} else if (handle === 'ne') {\n\t\t\t// SW corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column,\n\t\t\t\trow: startCell.row + originalSize.rowspan - 1,\n\t\t\t};\n\t\t} else {\n\t\t\t// SW handle: NE corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column + originalSize.colspan - 1,\n\t\t\t\trow: startCell.row,\n\t\t\t};\n\t\t}\n\n\t\temit<ResizeMoveDetail>('resize-move', {\n\t\t\titem,\n\t\t\tcell: { column: projectedColumn, row: projectedRow },\n\t\t\tanchorCell,\n\t\t\tstartCell,\n\t\t\tcolspan: projectedColspan,\n\t\t\trowspan: projectedRowspan,\n\t\t\thandle,\n\t\t});\n\t}\n\n\tfunction cleanupResizeListeners(item: HTMLElement, pointerId: number) {\n\t\titem.releasePointerCapture(pointerId);\n\t\titem.removeEventListener('pointermove', onItemPointerMove);\n\t\titem.removeEventListener('pointerup', onItemPointerUp);\n\t\titem.removeEventListener('pointercancel', onItemPointerCancel);\n\t}\n\n\tfunction finishResize() {\n\t\tif (!activeResize) return;\n\n\t\tconst { item, pointerId, currentSize, currentCell, originalSize, sizeLabel, initialRect, placeholder } = activeResize;\n\n\t\t// Remove placeholder if it exists\n\t\tif (placeholder) {\n\t\t\tplaceholder.remove();\n\t\t}\n\n\t\t// Clean up item event listeners\n\t\tcleanupResizeListeners(item, pointerId);\n\n\t\t// FLIP: Capture current visual position (First)\n\t\tconst firstRect = item.getBoundingClientRect();\n\n\t\t// Update data attributes to reflect new size\n\t\titem.setAttribute('data-gridiot-colspan', String(currentSize.colspan));\n\t\titem.setAttribute('data-gridiot-rowspan', String(currentSize.rowspan));\n\n\t\t// Remove size label before animations\n\t\tif (sizeLabel) {\n\t\t\tsizeLabel.remove();\n\t\t}\n\n\t\temit<ResizeEndDetail>('resize-end', {\n\t\t\titem,\n\t\t\tcell: currentCell,\n\t\t\tcolspan: currentSize.colspan,\n\t\t\trowspan: currentSize.rowspan,\n\t\t});\n\n\t\t// Helper to apply final grid state\n\t\tconst applyFinalState = () => {\n\t\t\t// Clear fixed/absolute positioning\n\t\t\titem.style.position = '';\n\t\t\titem.style.left = '';\n\t\t\titem.style.top = '';\n\t\t\titem.style.width = '';\n\t\t\titem.style.height = '';\n\t\t\titem.style.zIndex = '';\n\n\t\t\t// Set final grid position\n\t\t\titem.style.gridColumn = `${currentCell.column} / span ${currentSize.colspan}`;\n\t\t\titem.style.gridRow = `${currentCell.row} / span ${currentSize.rowspan}`;\n\n\t\t\titem.removeAttribute('data-gridiot-resizing');\n\t\t\titem.removeAttribute('data-gridiot-handle-active');\n\t\t};\n\n\t\t// Exclude from View Transitions during FLIP animation\n\t\titem.style.viewTransitionName = 'none';\n\n\t\t// Apply final state immediately (return to grid flow)\n\t\tapplyFinalState();\n\n\t\t// FLIP: Animate from captured visual position to new grid position\n\t\trequestAnimationFrame(() => {\n\t\t\tconst itemId = item.style.getPropertyValue('--item-id') || item.id || item.dataset.id;\n\n\t\t\tconst animation = animateFLIPWithTracking(item, firstRect, {\n\t\t\t\tincludeScale: true,\n\t\t\t\ttransformOrigin: 'top left',\n\t\t\t\tonFinish: () => {\n\t\t\t\t\t// Explicitly clear any transform that might persist\n\t\t\t\t\titem.style.transform = '';\n\t\t\t\t\t// Clear inline grid styles so layout-styles CSS (with container queries) takes over\n\t\t\t\t\titem.style.gridColumn = '';\n\t\t\t\t\titem.style.gridRow = '';\n\t\t\t\t\t// Restore viewTransitionName so future View Transitions work\n\t\t\t\t\tif (itemId) {\n\t\t\t\t\t\titem.style.viewTransitionName = itemId;\n\t\t\t\t\t} else {\n\t\t\t\t\t\titem.style.viewTransitionName = '';\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// If no animation was needed, ensure cleanup\n\t\t\tif (!animation) {\n\t\t\t\titem.style.transform = '';\n\t\t\t\t// Clear inline grid styles so layout-styles CSS (with container queries) takes over\n\t\t\t\titem.style.gridColumn = '';\n\t\t\t\titem.style.gridRow = '';\n\t\t\t\tif (itemId) {\n\t\t\t\t\titem.style.viewTransitionName = itemId;\n\t\t\t\t} else {\n\t\t\t\t\titem.style.viewTransitionName = '';\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tactiveResize = null;\n\t}\n\n\tfunction cancelResize() {\n\t\tif (!activeResize) return;\n\n\t\tconst { item, pointerId, originalGridColumn, originalGridRow, sizeLabel, placeholder } = activeResize;\n\n\t\t// Clean up item event listeners\n\t\tcleanupResizeListeners(item, pointerId);\n\n\t\t// Remove placeholder if it exists\n\t\tif (placeholder) {\n\t\t\tplaceholder.remove();\n\t\t}\n\n\t\t// Remove size label\n\t\tif (sizeLabel) {\n\t\t\tsizeLabel.remove();\n\t\t}\n\n\t\t// Clear fixed positioning\n\t\titem.style.position = '';\n\t\titem.style.left = '';\n\t\titem.style.top = '';\n\t\titem.style.width = '';\n\t\titem.style.height = '';\n\t\titem.style.zIndex = '';\n\n\t\t// Restore original grid position\n\t\titem.style.gridColumn = originalGridColumn;\n\t\titem.style.gridRow = originalGridRow;\n\n\t\t// Restore view transition name\n\t\tconst itemId = item.style.getPropertyValue('--item-id') || item.id || item.dataset.id;\n\t\tif (itemId) {\n\t\t\titem.style.viewTransitionName = itemId;\n\t\t} else {\n\t\t\titem.style.viewTransitionName = '';\n\t\t}\n\n\t\titem.removeAttribute('data-gridiot-resizing');\n\t\titem.removeAttribute('data-gridiot-handle-active');\n\n\t\temit<ResizeCancelDetail>('resize-cancel', {\n\t\t\titem,\n\t\t});\n\n\t\tactiveResize = null;\n\t}\n\n\t// --- Event handlers ---\n\n\t// Use capture phase to intercept before pointer plugin\n\tconst onPointerDown = (e: PointerEvent) => {\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-gridiot-item]',\n\t\t) as HTMLElement | null;\n\t\tif (!item) return;\n\n\t\tconst handle = detectHandle(e, item, handleSize, handles);\n\t\tif (!handle) return; // Not on handle - let pointer plugin handle drag\n\n\t\t// Stop event from reaching pointer plugin\n\t\te.stopPropagation();\n\t\te.preventDefault();\n\n\t\tstartResize(item, handle, e);\n\t};\n\n\t// Item-specific handlers (added during resize, removed on finish/cancel)\n\tconst onItemPointerMove = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tupdateResize(e);\n\t\t}\n\t};\n\n\tconst onItemPointerUp = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tfinishResize();\n\t\t}\n\t};\n\n\tconst onItemPointerCancel = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tcancelResize();\n\t\t}\n\t};\n\n\t// Grid-level hover handler for cursor changes and handle hover state\n\tconst onPointerMove = (e: PointerEvent) => {\n\t\t// Skip hover handling during active resize\n\t\tif (activeResize) return;\n\n\t\t// Handle hover cursor changes\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-gridiot-item]',\n\t\t) as HTMLElement | null;\n\n\t\tif (item) {\n\t\t\tconst handle = detectHandle(e, item, handleSize, handles);\n\n\t\t\tif (handle !== hoveredHandle || item !== hoveredItem) {\n\t\t\t\t// Clear previous item's hover state\n\t\t\t\tif (hoveredItem && hoveredItem !== item) {\n\t\t\t\t\thoveredItem.style.cursor = '';\n\t\t\t\t\thoveredItem.removeAttribute('data-gridiot-handle-hover');\n\t\t\t\t}\n\n\t\t\t\t// Clear hover attribute if handle changed on same item\n\t\t\t\tif (hoveredItem === item && hoveredHandle && !handle) {\n\t\t\t\t\titem.removeAttribute('data-gridiot-handle-hover');\n\t\t\t\t}\n\n\t\t\t\thoveredItem = item;\n\t\t\t\thoveredHandle = handle;\n\n\t\t\t\t// Set cursor and hover attribute based on handle\n\t\t\t\titem.style.cursor = getCursor(handle) || '';\n\t\t\t\tif (handle) {\n\t\t\t\t\titem.setAttribute('data-gridiot-handle-hover', handle);\n\t\t\t\t} else {\n\t\t\t\t\titem.removeAttribute('data-gridiot-handle-hover');\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (hoveredItem) {\n\t\t\thoveredItem.style.cursor = '';\n\t\t\thoveredItem.removeAttribute('data-gridiot-handle-hover');\n\t\t\thoveredItem = null;\n\t\t\thoveredHandle = null;\n\t\t}\n\t};\n\n\tconst onKeyDown = (e: KeyboardEvent) => {\n\t\tif (e.key === 'Escape' && activeResize) {\n\t\t\tcancelResize();\n\t\t}\n\t};\n\n\t// Register event listeners\n\tgridElement.addEventListener('pointerdown', onPointerDown, { capture: true });\n\tgridElement.addEventListener('pointermove', onPointerMove);\n\tdocument.addEventListener('keydown', onKeyDown);\n\n\t// Public API\n\tfunction setSize(\n\t\titem: HTMLElement,\n\t\tsize: { colspan: number; rowspan: number },\n\t) {\n\t\tconst clampedColspan = Math.max(\n\t\t\tminSize.colspan,\n\t\t\tMath.min(maxSize.colspan, size.colspan),\n\t\t);\n\t\tconst clampedRowspan = Math.max(\n\t\t\tminSize.rowspan,\n\t\t\tMath.min(maxSize.rowspan, size.rowspan),\n\t\t);\n\n\t\tconst style = getComputedStyle(item);\n\t\tconst column = parseInt(style.gridColumnStart, 10) || 1;\n\t\tconst row = parseInt(style.gridRowStart, 10) || 1;\n\n\t\titem.setAttribute('data-gridiot-colspan', String(clampedColspan));\n\t\titem.setAttribute('data-gridiot-rowspan', String(clampedRowspan));\n\t\titem.style.gridColumn = `${column} / span ${clampedColspan}`;\n\t\titem.style.gridRow = `${row} / span ${clampedRowspan}`;\n\n\t\temit<ResizeEndDetail>('resize-end', {\n\t\t\titem,\n\t\t\tcell: { column, row },\n\t\t\tcolspan: clampedColspan,\n\t\t\trowspan: clampedRowspan,\n\t\t});\n\t}\n\n\tfunction destroy() {\n\t\tgridElement.removeEventListener('pointerdown', onPointerDown, {\n\t\t\tcapture: true,\n\t\t});\n\t\tgridElement.removeEventListener('pointermove', onPointerMove);\n\t\tdocument.removeEventListener('keydown', onKeyDown);\n\n\t\tif (activeResize) {\n\t\t\tcancelResize();\n\t\t}\n\t}\n\n\treturn { setSize, destroy };\n}\n\n// Register as a plugin for auto-initialization via init()\nregisterPlugin({\n\tname: 'resize',\n\tinit(core, options?: ResizePluginOptions & { core?: GridiotCore }) {\n\t\tconst instance = attachResize(core.element, {\n\t\t\t...options,\n\t\t\tcore: options?.core ?? core,\n\t\t});\n\t\treturn () => instance.destroy();\n\t},\n});\n\nexport type { ResizeHandle };\n", "/**\n * Placeholder plugin for Gridiot\n *\n * Shows a visual placeholder where the dragged item will land.\n * Handles creation, positioning, and cleanup automatically.\n */\n\nimport { registerPlugin } from '../engine';\nimport type {\n\tDragStartDetail,\n\tDragMoveDetail,\n\tDragEndDetail,\n\tDragCancelDetail,\n\tPlaceholderPluginOptions,\n\tResizeStartDetail,\n\tResizeMoveDetail,\n\tResizeEndDetail,\n\tResizeCancelDetail,\n} from '../types';\n\nexport interface PlaceholderOptions {\n\t/**\n\t * CSS class name for the placeholder element.\n\t * @default 'gridiot-placeholder'\n\t */\n\tclassName?: string;\n\n\t/**\n\t * Custom element to use as placeholder instead of creating one.\n\t * If provided, className is ignored.\n\t */\n\telement?: HTMLElement;\n\n\t/**\n\t * Whether to disable view-transition-name on the placeholder.\n\t * Set to true to prevent the placeholder from animating with View Transitions.\n\t * @default true\n\t */\n\tdisableViewTransition?: boolean;\n}\n\nexport interface PlaceholderInstance {\n\t/** Manually show the placeholder at a position */\n\tshow(column: number, row: number, colspan?: number, rowspan?: number): void;\n\t/** Manually hide the placeholder */\n\thide(): void;\n\t/** Remove event listeners and clean up */\n\tdestroy(): void;\n}\n\n/**\n * Attach a placeholder to a Gridiot grid element.\n *\n * @example\n * ```js\n * import { init } from './gridiot.js';\n * import { attachPlaceholder } from './placeholder.js';\n *\n * const grid = init(document.getElementById('grid'));\n * const placeholder = attachPlaceholder(grid.element);\n *\n * // Later, to clean up:\n * placeholder.destroy();\n * ```\n */\nexport function attachPlaceholder(\n\tgridElement: HTMLElement,\n\toptions: PlaceholderOptions = {}\n): PlaceholderInstance {\n\tconst {\n\t\tclassName = 'gridiot-placeholder',\n\t\telement: customElement,\n\t\tdisableViewTransition = true,\n\t} = options;\n\n\tlet placeholder: HTMLElement | null = null;\n\tlet isCustomElement = false;\n\n\tfunction create(): void {\n\t\tif (placeholder) return;\n\n\t\tif (customElement) {\n\t\t\tplaceholder = customElement;\n\t\t\tisCustomElement = true;\n\t\t} else {\n\t\t\tplaceholder = document.createElement('div');\n\t\t\tplaceholder.className = className;\n\t\t}\n\n\t\t// Prevent placeholder from interfering with pointer events\n\t\tplaceholder.style.pointerEvents = 'none';\n\n\t\t// Disable view transitions on placeholder to prevent animation artifacts\n\t\tif (disableViewTransition) {\n\t\t\tplaceholder.style.viewTransitionName = 'none';\n\t\t}\n\n\t\tgridElement.appendChild(placeholder);\n\t}\n\n\tfunction update(\n\t\tcolumn: number,\n\t\trow: number,\n\t\tcolspan: number = 1,\n\t\trowspan: number = 1\n\t): void {\n\t\tif (!placeholder) return;\n\t\tplaceholder.style.gridColumn = `${column} / span ${colspan}`;\n\t\tplaceholder.style.gridRow = `${row} / span ${rowspan}`;\n\t}\n\n\tfunction remove(): void {\n\t\tif (placeholder) {\n\t\t\tplaceholder.remove();\n\t\t\t// Only null out if we created it; keep reference if custom\n\t\t\tif (!isCustomElement) {\n\t\t\t\tplaceholder = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Event handlers\n\tfunction handleDragStart(e: CustomEvent<DragStartDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tcreate();\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleDragMove(e: CustomEvent<DragMoveDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleDragEnd(_e: CustomEvent<DragEndDetail>): void {\n\t\tremove();\n\t}\n\n\tfunction handleDragCancel(_e: CustomEvent<DragCancelDetail>): void {\n\t\tremove();\n\t}\n\n\t// Resize event handlers\n\t// The placeholder shows where the item will land after resize. For handles that\n\t// change position (NW, NE, SW, N, W), the cell position changes but the anchor\n\t// corner stays fixed. This is correct - the placeholder shows the final landing spot.\n\tfunction handleResizeStart(e: CustomEvent<ResizeStartDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tcreate();\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleResizeMove(e: CustomEvent<ResizeMoveDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleResizeEnd(_e: CustomEvent<ResizeEndDetail>): void {\n\t\tremove();\n\t}\n\n\tfunction handleResizeCancel(_e: CustomEvent<ResizeCancelDetail>): void {\n\t\tremove();\n\t}\n\n\t// Fallback cleanup for edge cases (pointer released outside window, etc.)\n\tfunction handlePointerUp(): void {\n\t\trequestAnimationFrame(() => {\n\t\t\tif (\n\t\t\t\tplaceholder &&\n\t\t\t\t!document.querySelector('[data-gridiot-dragging]') &&\n\t\t\t\t!document.querySelector('[data-gridiot-resizing]')\n\t\t\t) {\n\t\t\t\tremove();\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction handlePointerCancel(): void {\n\t\tremove();\n\t}\n\n\t// Attach listeners\n\tgridElement.addEventListener(\n\t\t'gridiot:drag-start',\n\t\thandleDragStart as EventListener\n\t);\n\tgridElement.addEventListener(\n\t\t'gridiot:drag-move',\n\t\thandleDragMove as EventListener\n\t);\n\tgridElement.addEventListener(\n\t\t'gridiot:drag-end',\n\t\thandleDragEnd as EventListener\n\t);\n\tgridElement.addEventListener(\n\t\t'gridiot:drag-cancel',\n\t\thandleDragCancel as EventListener\n\t);\n\t// Resize events\n\tgridElement.addEventListener(\n\t\t'gridiot:resize-start',\n\t\thandleResizeStart as EventListener\n\t);\n\tgridElement.addEventListener(\n\t\t'gridiot:resize-move',\n\t\thandleResizeMove as EventListener\n\t);\n\tgridElement.addEventListener(\n\t\t'gridiot:resize-end',\n\t\thandleResizeEnd as EventListener\n\t);\n\tgridElement.addEventListener(\n\t\t'gridiot:resize-cancel',\n\t\thandleResizeCancel as EventListener\n\t);\n\tdocument.addEventListener('pointerup', handlePointerUp);\n\tdocument.addEventListener('pointercancel', handlePointerCancel);\n\n\t// Public API\n\treturn {\n\t\tshow(\n\t\t\tcolumn: number,\n\t\t\trow: number,\n\t\t\tcolspan: number = 1,\n\t\t\trowspan: number = 1\n\t\t): void {\n\t\t\tcreate();\n\t\t\tupdate(column, row, colspan, rowspan);\n\t\t},\n\n\t\thide(): void {\n\t\t\tremove();\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tremove();\n\t\t\tgridElement.removeEventListener(\n\t\t\t\t'gridiot:drag-start',\n\t\t\t\thandleDragStart as EventListener\n\t\t\t);\n\t\t\tgridElement.removeEventListener(\n\t\t\t\t'gridiot:drag-move',\n\t\t\t\thandleDragMove as EventListener\n\t\t\t);\n\t\t\tgridElement.removeEventListener(\n\t\t\t\t'gridiot:drag-end',\n\t\t\t\thandleDragEnd as EventListener\n\t\t\t);\n\t\t\tgridElement.removeEventListener(\n\t\t\t\t'gridiot:drag-cancel',\n\t\t\t\thandleDragCancel as EventListener\n\t\t\t);\n\t\t\t// Resize events\n\t\t\tgridElement.removeEventListener(\n\t\t\t\t'gridiot:resize-start',\n\t\t\t\thandleResizeStart as EventListener\n\t\t\t);\n\t\t\tgridElement.removeEventListener(\n\t\t\t\t'gridiot:resize-move',\n\t\t\t\thandleResizeMove as EventListener\n\t\t\t);\n\t\t\tgridElement.removeEventListener(\n\t\t\t\t'gridiot:resize-end',\n\t\t\t\thandleResizeEnd as EventListener\n\t\t\t);\n\t\t\tgridElement.removeEventListener(\n\t\t\t\t'gridiot:resize-cancel',\n\t\t\t\thandleResizeCancel as EventListener\n\t\t\t);\n\t\t\tdocument.removeEventListener('pointerup', handlePointerUp);\n\t\t\tdocument.removeEventListener('pointercancel', handlePointerCancel);\n\t\t},\n\t};\n}\n\n/**\n * Default CSS for the placeholder.\n * Include this in your stylesheet or use attachPlaceholderStyles().\n */\nexport const PLACEHOLDER_CSS = `\n.gridiot-placeholder {\n  background: rgba(255, 255, 255, 0.1);\n  border: 2px dashed rgba(255, 255, 255, 0.4);\n  border-radius: 8px;\n  pointer-events: none;\n}\n`;\n\n/**\n * Inject default placeholder styles into the document.\n * Call once at app initialization if you don't want to add CSS manually.\n */\nexport function attachPlaceholderStyles(): void {\n\tif (document.getElementById('gridiot-placeholder-styles')) return;\n\n\tconst style = document.createElement('style');\n\tstyle.id = 'gridiot-placeholder-styles';\n\tstyle.textContent = PLACEHOLDER_CSS;\n\tdocument.head.appendChild(style);\n}\n\n// Register as a plugin for auto-initialization via init()\nregisterPlugin({\n\tname: 'placeholder',\n\tinit(core, options?: PlaceholderPluginOptions) {\n\t\tconst instance = attachPlaceholder(core.element, options);\n\t\treturn () => instance.destroy();\n\t},\n});\n", "/**\n * Pure push-down layout algorithm - no DOM dependencies\n * This module contains the core layout logic that can be tested independently.\n */\n\nexport interface GridCell {\n\tcolumn: number;\n\trow: number;\n}\n\nexport interface ItemRect {\n\tid: string;\n\tcolumn: number;\n\trow: number;\n\twidth: number;\n\theight: number;\n}\n\n/**\n * Check if two items overlap\n */\nexport function itemsOverlap(a: ItemRect, b: ItemRect): boolean {\n\treturn !(\n\t\ta.column + a.width <= b.column ||\n\t\tb.column + b.width <= a.column ||\n\t\ta.row + a.height <= b.row ||\n\t\tb.row + b.height <= a.row\n\t);\n}\n\n/**\n * Check if any items in the layout overlap\n * @returns Array of overlapping pairs, empty if no overlaps\n */\nexport function findOverlaps(items: ItemRect[]): Array<[ItemRect, ItemRect]> {\n\tconst overlaps: Array<[ItemRect, ItemRect]> = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tfor (let j = i + 1; j < items.length; j++) {\n\t\t\tif (itemsOverlap(items[i], items[j])) {\n\t\t\t\toverlaps.push([items[i], items[j]]);\n\t\t\t}\n\t\t}\n\t}\n\treturn overlaps;\n}\n\n/**\n * Push items down recursively to resolve collisions\n * Mutates the items array in place\n */\nexport function pushDown(\n\titems: ItemRect[],\n\tmoved: ItemRect,\n\tmovedId: string,\n\tdepth = 0,\n): void {\n\tif (depth > 50) {\n\t\treturn;\n\t}\n\n\t// Sort by row descending - push bottom items first so upper items settle on top\n\t// This preserves the original relative ordering of items\n\tconst colliders = items\n\t\t.filter((it) => it.id !== movedId && it.id !== moved.id && itemsOverlap(moved, it))\n\t\t.sort((a, b) => b.row - a.row || a.column - b.column);\n\n\tfor (const collider of colliders) {\n\t\tconst newRow = moved.row + moved.height;\n\t\tif (collider.row < newRow) {\n\t\t\tcollider.row = newRow;\n\t\t\tpushDown(items, collider, movedId, depth + 1);\n\t\t}\n\t}\n}\n\n/**\n * Compact items upward to fill gaps\n * Mutates the items array in place\n */\nexport function compactUp(items: ItemRect[], excludeId: string): void {\n\tconst sorted = [...items]\n\t\t.filter((it) => it.id !== excludeId)\n\t\t.sort((a, b) => a.row - b.row || a.column - b.column);\n\n\tfor (const item of sorted) {\n\t\tlet iterations = 0;\n\t\twhile (item.row > 1 && iterations < 100) {\n\t\t\titerations++;\n\t\t\titem.row -= 1;\n\t\t\tconst hasCollision = items.some(\n\t\t\t\t(other) => other.id !== item.id && itemsOverlap(item, other),\n\t\t\t);\n\t\t\tif (hasCollision) {\n\t\t\t\titem.row += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Options for calculateLayout\n */\nexport interface CalculateLayoutOptions {\n\t/**\n\t * Whether to compact items upward after resolving collisions (default: true)\n\t */\n\tcompact?: boolean;\n}\n\n/**\n * Calculate new layout after moving an item\n * Returns a new array with updated positions\n */\nexport function calculateLayout(\n\titems: ItemRect[],\n\tmovedId: string,\n\ttargetCell: GridCell,\n\toptions: CalculateLayoutOptions = {},\n): ItemRect[] {\n\tconst { compact = true } = options;\n\n\t// Deep copy items\n\tconst result = items.map((item) => ({ ...item }));\n\n\tconst movedItem = result.find((it) => it.id === movedId);\n\tif (!movedItem) return result;\n\n\tmovedItem.column = targetCell.column;\n\tmovedItem.row = targetCell.row;\n\n\tpushDown(result, movedItem, movedId);\n\tif (compact) {\n\t\tcompactUp(result, movedId);\n\t}\n\n\treturn result;\n}\n\n/**\n * Options for CSS generation\n */\nexport interface LayoutToCSSOptions {\n\t/**\n\t * CSS selector prefix for items (default: '#')\n\t * Use '#' for id selectors, '.' for class selectors, or '[data-id=\"' for attribute selectors\n\t */\n\tselectorPrefix?: string;\n\t/**\n\t * CSS selector suffix for items (default: '')\n\t * Use ']' to close attribute selectors\n\t */\n\tselectorSuffix?: string;\n\t/**\n\t * Additional selector to exclude (e.g., ':not(.dragging)')\n\t */\n\texcludeSelector?: string;\n\t/**\n\t * Maximum column count for width clamping (optional)\n\t */\n\tmaxColumns?: number;\n}\n\n/**\n * Convert layout to CSS rules for injection into a <style> tag.\n * This enables the \"CSS-driven layout\" pattern where:\n * 1. Algorithm returns pure ItemRect[] data\n * 2. Caller converts to CSS string\n * 3. CSS injected into <style> tag\n * 4. View Transitions animate the change\n *\n * @param items - The layout items with positions\n * @param options - CSS generation options\n * @returns CSS rules string ready for injection\n *\n * @example\n * // Basic usage with id selectors\n * const css = layoutToCSS(items);\n * styleElement.textContent = css;\n *\n * @example\n * // During drag, exclude the dragging item\n * const css = layoutToCSS(items, { excludeSelector: ':not(.dragging)' });\n *\n * @example\n * // With data-id attribute selectors\n * const css = layoutToCSS(items, {\n *   selectorPrefix: '[data-id=\"',\n *   selectorSuffix: '\"]'\n * });\n */\nexport function layoutToCSS(\n\titems: ItemRect[],\n\toptions: LayoutToCSSOptions = {},\n): string {\n\tconst {\n\t\tselectorPrefix = '#',\n\t\tselectorSuffix = '',\n\t\texcludeSelector = '',\n\t\tmaxColumns,\n\t} = options;\n\n\tconst rules: string[] = [];\n\n\tfor (const item of items) {\n\t\tconst width = maxColumns ? Math.min(item.width, maxColumns) : item.width;\n\t\t// Clamp column so item fits within maxColumns (prevents implicit column creation)\n\t\tconst column = maxColumns ? Math.max(1, Math.min(item.column, maxColumns - width + 1)) : item.column;\n\t\tconst selector = `${selectorPrefix}${item.id}${selectorSuffix}${excludeSelector}`;\n\t\tconst gridColumn = `${column} / span ${width}`;\n\t\tconst gridRow = `${item.row} / span ${item.height}`;\n\n\t\trules.push(`${selector} { grid-column: ${gridColumn}; grid-row: ${gridRow}; }`);\n\t}\n\n\treturn rules.join('\\n');\n}\n", "/**\n * Push-down layout algorithm for Gridiot\n *\n * This module provides both:\n * 1. Pure algorithm functions (re-exported from algorithm-push-core)\n * 2. DOM integration helper for attaching the algorithm to a grid element\n *\n * Usage (pure functions):\n *   import { calculateLayout, layoutToCSS } from 'gridiot/algorithm-push';\n *   const newLayout = calculateLayout(items, movedId, targetCell);\n *   styleElement.textContent = layoutToCSS(newLayout);\n *\n * Usage (DOM integration):\n *   import { init } from 'gridiot';\n *   import { attachPushAlgorithm } from 'gridiot/algorithm-push';\n *\n *   const grid = init(element);\n *   const detach = attachPushAlgorithm(grid.element);\n */\n\nimport { registerPlugin } from '../engine';\n\n// Re-export pure algorithm functions\nexport {\n\tcalculateLayout,\n\tcompactUp,\n\tfindOverlaps,\n\titemsOverlap,\n\tlayoutToCSS,\n\tpushDown,\n\ttype CalculateLayoutOptions,\n\ttype GridCell,\n\ttype ItemRect,\n\ttype LayoutToCSSOptions,\n} from './algorithm-push-core';\n\nimport type {\n\tAlgorithmPushPluginOptions,\n\tDragCancelDetail,\n\tDragEndDetail,\n\tDragMoveDetail,\n\tDragStartDetail,\n\tGridCell,\n\tGridiotCore,\n\tItemPosition,\n\tLayoutState,\n\tResizeCancelDetail,\n\tResizeEndDetail,\n\tResizeMoveDetail,\n\tResizeStartDetail,\n\tResponsiveLayoutModel,\n} from '../types';\n\nimport type { CameraState } from './camera';\n\nimport {\n\tcalculateLayout,\n\tlayoutToCSS,\n\ttype ItemRect,\n} from './algorithm-push-core';\n\nconst DEBUG = false;\nfunction log(...args: unknown[]) {\n\tif (DEBUG) console.log('[algorithm-push]', ...args);\n}\n\n/**\n * Read item positions from DOM elements\n */\nexport function readItemsFromDOM(container: HTMLElement): ItemRect[] {\n\tconst elements = container.querySelectorAll('[data-gridiot-item]');\n\treturn Array.from(elements).map((el) => {\n\t\tconst element = el as HTMLElement;\n\t\tconst style = getComputedStyle(element);\n\t\tconst column = parseInt(style.gridColumnStart, 10) || 1;\n\t\tconst row = parseInt(style.gridRowStart, 10) || 1;\n\t\tconst width =\n\t\t\tparseInt(element.getAttribute('data-gridiot-colspan') || '1', 10) || 1;\n\t\tconst height =\n\t\t\tparseInt(element.getAttribute('data-gridiot-rowspan') || '1', 10) || 1;\n\t\tconst id = element.dataset.id || element.dataset.gridiotItem || '';\n\n\t\treturn { id, column, row, width, height };\n\t});\n}\n\n/**\n * Options for attachPushAlgorithm\n */\nexport interface AttachPushAlgorithmOptions {\n\t/**\n\t * Style element to inject layout CSS into.\n\t * If not provided, positions are applied directly to element.style.\n\t *\n\t * When using with a layoutModel, this becomes the \"preview\" style element\n\t * used during drag. The responsive plugin manages the main layout CSS.\n\t */\n\tstyleElement?: HTMLStyleElement;\n\t/**\n\t * CSS selector options for layoutToCSS\n\t */\n\tselectorPrefix?: string;\n\tselectorSuffix?: string;\n\t/**\n\t * Whether to compact items upward after resolving collisions (default: true)\n\t * When false, items only get pushed down but won't float back up to fill gaps.\n\t */\n\tcompaction?: boolean;\n\t/**\n\t * GridiotCore instance for provider registration.\n\t * If provided, registers a 'layout' provider that exposes current layout state.\n\t */\n\tcore?: GridiotCore;\n\t/**\n\t * Responsive layout model for multi-breakpoint support.\n\t * When provided, final positions are saved to the layout model on drag-end,\n\t * which triggers CSS regeneration via the responsive plugin.\n\t */\n\tlayoutModel?: ResponsiveLayoutModel;\n}\n\n/**\n * Attach push-down algorithm to a grid element.\n *\n * This creates event listeners for gridiot drag events and updates\n * the layout when items are moved. Layout changes are animated\n * via View Transitions.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach the algorithm\n */\nexport function attachPushAlgorithm(\n\tgridElement: HTMLElement,\n\toptions: AttachPushAlgorithmOptions = {},\n): () => void {\n\tconst { styleElement, selectorPrefix = '#', selectorSuffix = '', compaction = true, core, layoutModel } = options;\n\n\t/**\n\t * Get current column count from computed grid style\n\t */\n\tfunction getCurrentColumnCount(): number {\n\t\tconst style = getComputedStyle(gridElement);\n\t\tconst columns = style.gridTemplateColumns.split(' ').filter(Boolean);\n\t\treturn Math.max(1, columns.length);\n\t}\n\n\tlet originalPositions: Map<string, { column: number; row: number }> | null =\n\t\tnull;\n\tlet draggedItemId: string | null = null;\n\tlet draggedElement: HTMLElement | null = null;\n\tlet layoutVersion = 0; // Prevent stale async view transitions from overwriting newer layouts\n\tlet currentLayout: ItemRect[] | null = null;\n\tlet dragStartColumnCount: number | null = null; // Track column count at drag start to avoid implicit columns\n\n\t// Register layout provider if core is provided\n\tif (core) {\n\t\tcore.providers.register<LayoutState | null>('layout', () => {\n\t\t\tif (!currentLayout) return null;\n\t\t\tconst gridStyle = getComputedStyle(gridElement);\n\t\t\tconst columns = gridStyle.gridTemplateColumns.split(' ').length;\n\t\t\treturn {\n\t\t\t\titems: currentLayout.map((item) => ({\n\t\t\t\t\tid: item.id,\n\t\t\t\t\tcolumn: item.column,\n\t\t\t\t\trow: item.row,\n\t\t\t\t\tcolspan: item.width,\n\t\t\t\t\trowspan: item.height,\n\t\t\t\t})),\n\t\t\t\tcolumns,\n\t\t\t};\n\t\t});\n\t}\n\n\tfunction getItemId(element: HTMLElement): string {\n\t\treturn element.dataset.id || element.dataset.gridiotItem || '';\n\t}\n\n\tfunction setItemCell(item: HTMLElement, cell: GridCell): void {\n\t\tconst colspan =\n\t\t\tparseInt(item.getAttribute('data-gridiot-colspan') || '1', 10) || 1;\n\t\tconst rowspan =\n\t\t\tparseInt(item.getAttribute('data-gridiot-rowspan') || '1', 10) || 1;\n\t\tconst colValue = `${cell.column} / span ${colspan}`;\n\t\tconst rowValue = `${cell.row} / span ${rowspan}`;\n\t\tlog('setItemCell', { id: getItemId(item), colValue, rowValue });\n\t\titem.style.gridColumn = colValue;\n\t\titem.style.gridRow = rowValue;\n\t}\n\n\tfunction applyLayout(\n\t\tlayout: ItemRect[],\n\t\texcludeId: string | null,\n\t\tuseViewTransition: boolean,\n\t\tonApplied?: () => void,\n\t): void {\n\t\t// Increment version to invalidate any pending async transitions\n\t\tconst thisVersion = ++layoutVersion;\n\n\t\t// Update current layout for provider access\n\t\tcurrentLayout = layout;\n\n\t\t// Capture column count NOW, before the async callback runs\n\t\t// (the state variables get cleared after applyLayout returns)\n\t\tconst capturedColumnCount = dragStartColumnCount ?? resizeStartColumnCount;\n\n\t\tconst applyChanges = () => {\n\t\t\t// Skip if a newer layout has been applied (stale async view transition)\n\t\t\tif (thisVersion !== layoutVersion) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (styleElement) {\n\t\t\t\t// CSS injection mode - preferred\n\t\t\t\t// Filter out the excluded item (being dragged) from CSS generation\n\t\t\t\tconst itemsToStyle = excludeId\n\t\t\t\t\t? layout.filter((item) => item.id !== excludeId)\n\t\t\t\t\t: layout;\n\t\t\t\t// Use the captured column count to clamp widths and prevent implicit column creation\n\t\t\t\tconst css = layoutToCSS(itemsToStyle, {\n\t\t\t\t\tselectorPrefix,\n\t\t\t\t\tselectorSuffix,\n\t\t\t\t\tmaxColumns: capturedColumnCount ?? undefined,\n\t\t\t\t});\n\t\t\t\tlog('injecting CSS:', css.substring(0, 200) + '...');\n\t\t\t\tstyleElement.textContent = css;\n\n\t\t\t\t// Clear inline grid styles so CSS rules take effect\n\t\t\t\t// (inline styles have higher specificity than stylesheet rules)\n\t\t\t\tconst elements = gridElement.querySelectorAll('[data-gridiot-item]');\n\t\t\t\tfor (const el of elements) {\n\t\t\t\t\tconst element = el as HTMLElement;\n\t\t\t\t\tconst id = getItemId(element);\n\t\t\t\t\t// Don't clear styles for:\n\t\t\t\t\t// 1. The excluded item (being dragged with fixed positioning)\n\t\t\t\t\t// 2. Items with viewTransitionName='none' (being FLIP-animated by resize plugin)\n\t\t\t\t\tconst vtn = element.style.viewTransitionName;\n\t\t\t\t\tif (id !== excludeId && vtn !== 'none') {\n\t\t\t\t\t\telement.style.gridColumn = '';\n\t\t\t\t\t\telement.style.gridRow = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Direct style mutation mode - fallback\n\t\t\t\tconst elements = gridElement.querySelectorAll('[data-gridiot-item]');\n\t\t\t\tfor (const el of elements) {\n\t\t\t\t\tconst element = el as HTMLElement;\n\t\t\t\t\tconst id = getItemId(element);\n\t\t\t\t\tif (id === excludeId) continue;\n\n\t\t\t\t\tconst item = layout.find((it) => it.id === id);\n\t\t\t\t\tif (item) {\n\t\t\t\t\t\tsetItemCell(element, { column: item.column, row: item.row });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Call onApplied callback after CSS changes are made\n\t\t\t// This runs inside the View Transition callback, so layoutModel updates\n\t\t\t// happen after the \"new\" state is captured\n\t\t\tif (onApplied) {\n\t\t\t\tonApplied();\n\t\t\t}\n\t\t};\n\n\t\tif (useViewTransition && 'startViewTransition' in document) {\n\t\t\tlog('starting view transition, excludeId:', excludeId);\n\t\t\t// Only suppress animation for item being pointer-dragged (not keyboard nudges)\n\t\t\t// During pointer drag, excludeId is set; during keyboard nudge or final drop, it's null\n\t\t\tif (draggedElement && excludeId) {\n\t\t\t\tdraggedElement.style.viewTransitionName = 'dragging';\n\t\t\t}\n\t\t\t// Log items' view-transition-names before transition\n\t\t\tconst items = gridElement.querySelectorAll('[data-gridiot-item]');\n\t\t\tfor (const item of items) {\n\t\t\t\tconst el = item as HTMLElement;\n\t\t\t\tconst vtn = getComputedStyle(el).viewTransitionName;\n\t\t\t\tlog('item', getItemId(el), 'view-transition-name:', vtn);\n\t\t\t}\n\t\t\tconst transition = (document as any).startViewTransition(applyChanges);\n\t\t\ttransition.finished.then(() => log('view transition finished'));\n\t\t} else {\n\t\t\tlog('applying without view transition, useViewTransition:', useViewTransition, 'hasAPI:', 'startViewTransition' in document);\n\t\t\tapplyChanges();\n\t\t}\n\t}\n\n\tconst onDragStart = (e: Event) => {\n\t\tconst detail = (e as CustomEvent<DragStartDetail>).detail;\n\t\tdraggedElement = detail.item;\n\t\tdraggedItemId = getItemId(detail.item);\n\n\t\t// Capture column count BEFORE any CSS changes to avoid implicit columns from span values\n\t\tdragStartColumnCount = getCurrentColumnCount();\n\n\t\t// Store original positions to reset from during drag\n\t\tconst items = readItemsFromDOM(gridElement);\n\t\toriginalPositions = new Map();\n\t\tfor (const item of items) {\n\t\t\toriginalPositions.set(item.id, { column: item.column, row: item.row });\n\t\t}\n\n\t\t// In CSS injection mode, clear inline styles so CSS rules take effect\n\t\tif (styleElement) {\n\t\t\tconst elements = gridElement.querySelectorAll('[data-gridiot-item]');\n\t\t\tfor (const el of elements) {\n\t\t\t\tconst element = el as HTMLElement;\n\t\t\t\tif (element !== draggedElement) {\n\t\t\t\t\telement.style.gridColumn = '';\n\t\t\t\t\telement.style.gridRow = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Generate initial CSS for current positions, clamping to current column count\n\t\t\tconst css = layoutToCSS(items, { selectorPrefix, selectorSuffix, maxColumns: dragStartColumnCount });\n\t\t\tstyleElement.textContent = css;\n\t\t}\n\n\t\tlog('drag-start', {\n\t\t\titem: draggedItemId,\n\t\t\tpositions: Array.from(originalPositions.entries()),\n\t\t});\n\t};\n\n\t// Track pending cell during camera scroll for deferred update\n\tlet pendingCell: { column: number; row: number } | null = null;\n\n\tconst onDragMove = (e: Event) => {\n\t\tif (!draggedItemId || !originalPositions) return;\n\n\t\tconst detail = (e as CustomEvent<DragMoveDetail>).detail;\n\n\t\t// Skip layout updates while camera is auto-scrolling, but track pending cell\n\t\tif (core) {\n\t\t\tconst cameraState = core.providers.get<CameraState>('camera');\n\t\t\tif (cameraState?.isScrolling) {\n\t\t\t\tpendingCell = detail.cell;\n\t\t\t\tlog('drag-move deferred (camera scrolling)', pendingCell);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Clear pendingCell since we're processing normally now\n\t\tpendingCell = null;\n\n\t\t// Build items array from original positions\n\t\tconst items: ItemRect[] = readItemsFromDOM(gridElement).map((item) => {\n\t\t\tconst original = originalPositions!.get(item.id);\n\t\t\tif (original && item.id !== draggedItemId) {\n\t\t\t\treturn { ...item, column: original.column, row: original.row };\n\t\t\t}\n\t\t\treturn item;\n\t\t});\n\n\t\tlog('drag-move', { targetCell: detail.cell });\n\t\tconst newLayout = calculateLayout(items, draggedItemId, detail.cell, { compact: compaction });\n\t\tlog(\n\t\t\t'calculated layout',\n\t\t\tnewLayout.map((it) => ({ id: it.id, col: it.column, row: it.row })),\n\t\t);\n\t\tapplyLayout(newLayout, draggedItemId, true);\n\t};\n\n\tconst onDragEnd = (e: Event) => {\n\t\tif (!draggedItemId || !originalPositions) return;\n\t\tconst detail = (e as CustomEvent<DragEndDetail>).detail;\n\n\t\tlog('drag-end', { finalCell: detail.cell });\n\n\t\t// Build items array from original positions\n\t\tconst items: ItemRect[] = readItemsFromDOM(gridElement).map((item) => {\n\t\t\tconst original = originalPositions!.get(item.id);\n\t\t\tif (original && item.id !== draggedItemId) {\n\t\t\t\treturn { ...item, column: original.column, row: original.row };\n\t\t\t}\n\t\t\treturn item;\n\t\t});\n\n\t\tconst finalLayout = calculateLayout(items, draggedItemId, detail.cell, { compact: compaction });\n\t\tlog(\n\t\t\t'final layout',\n\t\t\tfinalLayout.map((it) => ({ id: it.id, col: it.column, row: it.row })),\n\t\t);\n\n\t\t// Check if this is a pointer drag (item is in fixed position) or keyboard nudge\n\t\tconst isPointerDrag = draggedElement?.style.position === 'fixed';\n\t\tlog('drag-end isPointerDrag:', isPointerDrag, 'position:', draggedElement?.style.position);\n\n\t\t// Clear the 'dragging' viewTransitionName so CSS view-transition-name applies\n\t\tif (draggedElement && draggedElement.style.viewTransitionName === 'dragging') {\n\t\t\tdraggedElement.style.viewTransitionName = '';\n\t\t}\n\n\t\t// For pointer drag: don't use View Transitions - other items are already in position\n\t\t// from drag-move, and FLIP handles the dropped item. Using VT would conflict with FLIP.\n\t\t// For keyboard nudge: use View Transitions to animate all items.\n\t\tconst useViewTransition = !isPointerDrag;\n\t\tlog('drag-end useViewTransition:', useViewTransition);\n\n\t\t// Capture values needed for the callback before clearing state\n\t\tconst savedDragStartColumnCount = dragStartColumnCount;\n\n\t\t// Callback to save layout - runs inside View Transition callback so it happens\n\t\t// AFTER the new state is captured (prevents layout-styles from updating too early)\n\t\tconst saveToLayoutModel = () => {\n\t\t\tif (layoutModel && savedDragStartColumnCount) {\n\t\t\t\tconst positions = new Map<string, ItemPosition>();\n\t\t\t\tfor (const item of finalLayout) {\n\t\t\t\t\tpositions.set(item.id, { column: item.column, row: item.row });\n\t\t\t\t}\n\t\t\t\tlayoutModel.saveLayout(savedDragStartColumnCount, positions);\n\t\t\t\tlog('saved layout to model for', savedDragStartColumnCount, 'columns');\n\n\t\t\t\t// Clear preview styles so container query CSS (layout-styles) takes over.\n\t\t\t\t// This is safe because layoutModel now has the correct positions, and\n\t\t\t\t// we're inside the View Transition callback so any mismatch gets animated.\n\t\t\t\tif (styleElement) {\n\t\t\t\t\tstyleElement.textContent = '';\n\t\t\t\t\tlog('cleared preview styles');\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tapplyLayout(finalLayout, null, useViewTransition, saveToLayoutModel);\n\n\t\tdraggedItemId = null;\n\t\tdraggedElement = null;\n\t\toriginalPositions = null;\n\t\tpendingCell = null;\n\t\tdragStartColumnCount = null;\n\t};\n\n\tconst onDragCancel = () => {\n\t\tif (!draggedItemId || !originalPositions) return;\n\n\t\t// Clear the 'dragging' viewTransitionName only if it was set (during pointer drag)\n\t\tif (draggedElement && draggedElement.style.viewTransitionName === 'dragging') {\n\t\t\tdraggedElement.style.viewTransitionName = '';\n\t\t}\n\n\t\t// Restore original positions\n\t\tconst restoreLayout: ItemRect[] = readItemsFromDOM(gridElement).map(\n\t\t\t(item) => {\n\t\t\t\tconst original = originalPositions!.get(item.id);\n\t\t\t\tif (original) {\n\t\t\t\t\treturn { ...item, column: original.column, row: original.row };\n\t\t\t\t}\n\t\t\t\treturn item;\n\t\t\t},\n\t\t);\n\n\t\tconst restore = () => {\n\t\t\tapplyLayout(restoreLayout, null, false);\n\t\t};\n\n\t\tif ('startViewTransition' in document) {\n\t\t\t(document as any).startViewTransition(restore);\n\t\t} else {\n\t\t\trestore();\n\t\t}\n\n\t\tdraggedItemId = null;\n\t\tdraggedElement = null;\n\t\toriginalPositions = null;\n\t\tpendingCell = null;\n\t\tdragStartColumnCount = null;\n\t};\n\n\t// Recalculate layout when camera settles after auto-scrolling\n\tconst onCameraSettled = () => {\n\t\tif (!draggedItemId || !originalPositions) return;\n\n\t\t// Use pending cell if available, otherwise get from element position\n\t\tlet cell = pendingCell;\n\t\tif (!cell && draggedElement) {\n\t\t\tconst rect = draggedElement.getBoundingClientRect();\n\t\t\tconst centerX = rect.left + rect.width / 2;\n\t\t\tconst centerY = rect.top + rect.height / 2;\n\t\t\tcell = core?.getCellFromPoint(centerX, centerY) ?? null;\n\t\t}\n\n\t\tif (!cell) {\n\t\t\tlog('camera-settled, no cell to update to');\n\t\t\treturn;\n\t\t}\n\n\t\tlog('camera-settled, updating to cell', cell);\n\t\tpendingCell = null;\n\n\t\t// Rebuild items from original positions\n\t\tconst items: ItemRect[] = readItemsFromDOM(gridElement).map((item) => {\n\t\t\tconst original = originalPositions!.get(item.id);\n\t\t\tif (original && item.id !== draggedItemId) {\n\t\t\t\treturn { ...item, column: original.column, row: original.row };\n\t\t\t}\n\t\t\treturn item;\n\t\t});\n\n\t\tconst newLayout = calculateLayout(items, draggedItemId!, cell, { compact: compaction });\n\t\tapplyLayout(newLayout, draggedItemId, true);\n\t};\n\n\t// =========================================================================\n\t// Resize event handlers\n\t// =========================================================================\n\n\tlet resizedItemId: string | null = null;\n\tlet resizedElement: HTMLElement | null = null;\n\tlet resizeOriginalPositions: Map<string, { column: number; row: number; width: number; height: number }> | null = null;\n\tlet lastResizeLayout: { cell: GridCell; colspan: number; rowspan: number } | null = null;\n\tlet resizeStartColumnCount: number | null = null; // Track column count at resize start\n\n\tconst onResizeStart = (e: Event) => {\n\t\tconst detail = (e as CustomEvent<ResizeStartDetail>).detail;\n\t\tresizedElement = detail.item;\n\t\tresizedItemId = getItemId(detail.item);\n\n\t\t// Capture column count BEFORE any CSS changes to avoid implicit columns\n\t\tresizeStartColumnCount = getCurrentColumnCount();\n\n\t\t// Store original positions AND sizes to reset from during resize\n\t\tconst items = readItemsFromDOM(gridElement);\n\t\tresizeOriginalPositions = new Map();\n\t\tfor (const item of items) {\n\t\t\tresizeOriginalPositions.set(item.id, {\n\t\t\t\tcolumn: item.column,\n\t\t\t\trow: item.row,\n\t\t\t\twidth: item.width,\n\t\t\t\theight: item.height,\n\t\t\t});\n\t\t}\n\n\t\t// In CSS injection mode, set up preview styles for animations during resize\n\t\tif (styleElement) {\n\t\t\tconst elements = gridElement.querySelectorAll('[data-gridiot-item]');\n\t\t\tfor (const el of elements) {\n\t\t\t\tconst element = el as HTMLElement;\n\t\t\t\tif (element !== resizedElement) {\n\t\t\t\t\telement.style.gridColumn = '';\n\t\t\t\t\telement.style.gridRow = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Generate initial CSS for current positions, clamping to current column count\n\t\t\tconst css = layoutToCSS(items, { selectorPrefix, selectorSuffix, maxColumns: resizeStartColumnCount });\n\t\t\tstyleElement.textContent = css;\n\t\t}\n\n\t\t// Clear last resize layout to ensure first resize-move triggers an update\n\t\tlastResizeLayout = null;\n\n\t\tlog('resize-start', {\n\t\t\titem: resizedItemId,\n\t\t\tcell: detail.cell,\n\t\t\tsize: { colspan: detail.colspan, rowspan: detail.rowspan },\n\t\t});\n\t};\n\n\tconst onResizeMove = (e: Event) => {\n\t\tif (!resizedItemId || !resizeOriginalPositions) return;\n\n\t\tconst detail = (e as CustomEvent<ResizeMoveDetail>).detail;\n\n\t\t// Only update layout when projected size/position actually changes\n\t\t// This prevents rapid view transitions from cancelling each other\n\t\tif (lastResizeLayout &&\n\t\t\tlastResizeLayout.cell.column === detail.cell.column &&\n\t\t\tlastResizeLayout.cell.row === detail.cell.row &&\n\t\t\tlastResizeLayout.colspan === detail.colspan &&\n\t\t\tlastResizeLayout.rowspan === detail.rowspan) {\n\t\t\treturn;\n\t\t}\n\t\tlastResizeLayout = {\n\t\t\tcell: { ...detail.cell },\n\t\t\tcolspan: detail.colspan,\n\t\t\trowspan: detail.rowspan,\n\t\t};\n\n\t\t// Build items array from original positions, but with updated size for resized item\n\t\tconst items: ItemRect[] = [];\n\t\tfor (const [id, original] of resizeOriginalPositions) {\n\t\t\tif (id === resizedItemId) {\n\t\t\t\t// Use the projected position and size from resize event\n\t\t\t\titems.push({\n\t\t\t\t\tid,\n\t\t\t\t\tcolumn: detail.cell.column,\n\t\t\t\t\trow: detail.cell.row,\n\t\t\t\t\twidth: detail.colspan,\n\t\t\t\t\theight: detail.rowspan,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Use original position and size\n\t\t\t\titems.push({\n\t\t\t\t\tid,\n\t\t\t\t\tcolumn: original.column,\n\t\t\t\t\trow: original.row,\n\t\t\t\t\twidth: original.width,\n\t\t\t\t\theight: original.height,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tlog('resize-move', { targetCell: detail.cell, size: { colspan: detail.colspan, rowspan: detail.rowspan } });\n\t\tconst newLayout = calculateLayout(items, resizedItemId, detail.cell, { compact: compaction });\n\t\tlog(\n\t\t\t'calculated resize layout',\n\t\t\tnewLayout.map((it) => ({ id: it.id, col: it.column, row: it.row, w: it.width, h: it.height })),\n\t\t);\n\n\t\t// Apply layout WITHOUT view transitions during resize-move to avoid visual glitches\n\t\t// View transitions during rapid updates can cause items to appear to shrink/jitter\n\t\tapplyLayout(newLayout, resizedItemId, false);\n\t};\n\n\tconst onResizeEnd = (e: Event) => {\n\t\tif (!resizedItemId || !resizeOriginalPositions) return;\n\t\tconst detail = (e as CustomEvent<ResizeEndDetail>).detail;\n\n\t\tlog('resize-end', { finalCell: detail.cell, size: { colspan: detail.colspan, rowspan: detail.rowspan } });\n\n\t\t// Build final layout from original positions with final resize size\n\t\tconst items: ItemRect[] = [];\n\t\tfor (const [id, original] of resizeOriginalPositions) {\n\t\t\tif (id === resizedItemId) {\n\t\t\t\titems.push({\n\t\t\t\t\tid,\n\t\t\t\t\tcolumn: detail.cell.column,\n\t\t\t\t\trow: detail.cell.row,\n\t\t\t\t\twidth: detail.colspan,\n\t\t\t\t\theight: detail.rowspan,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\titems.push({\n\t\t\t\t\tid,\n\t\t\t\t\tcolumn: original.column,\n\t\t\t\t\trow: original.row,\n\t\t\t\t\twidth: original.width,\n\t\t\t\t\theight: original.height,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconst finalLayout = calculateLayout(items, resizedItemId, detail.cell, { compact: compaction });\n\t\tlog(\n\t\t\t'final resize layout',\n\t\t\tfinalLayout.map((it) => ({ id: it.id, col: it.column, row: it.row, w: it.width, h: it.height })),\n\t\t);\n\n\t\t// Check if this is a pointer resize (item is in fixed position) or keyboard resize\n\t\tconst isPointerResize = resizedElement?.style.position === 'fixed';\n\t\tlog('resize-end isPointerResize:', isPointerResize);\n\n\t\t// For pointer resize: don't use View Transitions - other items are already in position\n\t\t// from resize-move, and FLIP handles the resized item. Using VT would conflict with FLIP.\n\t\t// For keyboard resize: use View Transitions to animate all items.\n\t\tconst useViewTransition = !isPointerResize;\n\t\tlog('resize-end: useViewTransition:', useViewTransition);\n\n\t\t// Capture values needed for the callback before clearing state\n\t\tconst savedResizedItemId = resizedItemId;\n\t\tconst savedResizeStartColumnCount = resizeStartColumnCount;\n\n\t\t// Callback to save layout - runs inside View Transition callback so it happens\n\t\t// AFTER the new state is captured (prevents layout-styles from updating too early)\n\t\tconst saveToLayoutModel = () => {\n\t\t\tif (layoutModel && savedResizeStartColumnCount) {\n\t\t\t\tconst positions = new Map<string, ItemPosition>();\n\t\t\t\tfor (const item of finalLayout) {\n\t\t\t\t\tpositions.set(item.id, { column: item.column, row: item.row });\n\t\t\t\t}\n\t\t\t\t// Save positions first, then update size. This order ensures the intermediate\n\t\t\t\t// CSS state (old size + new positions) is valid, rather than (new size + old positions)\n\t\t\t\t// which could cause overlapping items.\n\t\t\t\tlayoutModel.saveLayout(savedResizeStartColumnCount, positions);\n\t\t\t\tlayoutModel.updateItemSize(savedResizedItemId!, { width: detail.colspan, height: detail.rowspan });\n\t\t\t\tlog('saved resize layout to model for', savedResizeStartColumnCount, 'columns');\n\n\t\t\t\t// Clear preview styles so container query CSS (layout-styles) takes over.\n\t\t\t\t// This is safe because layoutModel now has the correct positions/sizes, and\n\t\t\t\t// we're inside the View Transition callback so any mismatch gets animated.\n\t\t\t\tif (styleElement) {\n\t\t\t\t\tstyleElement.textContent = '';\n\t\t\t\t\tlog('cleared preview styles');\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tapplyLayout(finalLayout, null, useViewTransition, saveToLayoutModel);\n\n\t\tresizedItemId = null;\n\t\tresizedElement = null;\n\t\tresizeOriginalPositions = null;\n\t\tlastResizeLayout = null;\n\t\tresizeStartColumnCount = null;\n\t};\n\n\tconst onResizeCancel = () => {\n\t\tif (!resizedItemId || !resizeOriginalPositions) return;\n\n\t\t// Restore original positions\n\t\tconst restoreLayout: ItemRect[] = readItemsFromDOM(gridElement).map(\n\t\t\t(item) => {\n\t\t\t\tconst original = resizeOriginalPositions!.get(item.id);\n\t\t\t\tif (original) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...item,\n\t\t\t\t\t\tcolumn: original.column,\n\t\t\t\t\t\trow: original.row,\n\t\t\t\t\t\twidth: original.width,\n\t\t\t\t\t\theight: original.height,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn item;\n\t\t\t},\n\t\t);\n\n\t\tconst restore = () => {\n\t\t\tapplyLayout(restoreLayout, null, false);\n\t\t};\n\n\t\tif ('startViewTransition' in document) {\n\t\t\t(document as any).startViewTransition(restore);\n\t\t} else {\n\t\t\trestore();\n\t\t}\n\n\t\tresizedItemId = null;\n\t\tresizedElement = null;\n\t\tresizeOriginalPositions = null;\n\t\tlastResizeLayout = null;\n\t\tresizeStartColumnCount = null;\n\t};\n\n\tgridElement.addEventListener('gridiot:drag-start', onDragStart);\n\tgridElement.addEventListener('gridiot:drag-move', onDragMove);\n\tgridElement.addEventListener('gridiot:drag-end', onDragEnd);\n\tgridElement.addEventListener('gridiot:drag-cancel', onDragCancel);\n\tgridElement.addEventListener('gridiot:camera-settled', onCameraSettled);\n\tgridElement.addEventListener('gridiot:resize-start', onResizeStart);\n\tgridElement.addEventListener('gridiot:resize-move', onResizeMove);\n\tgridElement.addEventListener('gridiot:resize-end', onResizeEnd);\n\tgridElement.addEventListener('gridiot:resize-cancel', onResizeCancel);\n\n\treturn () => {\n\t\tgridElement.removeEventListener('gridiot:drag-start', onDragStart);\n\t\tgridElement.removeEventListener('gridiot:drag-move', onDragMove);\n\t\tgridElement.removeEventListener('gridiot:drag-end', onDragEnd);\n\t\tgridElement.removeEventListener('gridiot:drag-cancel', onDragCancel);\n\t\tgridElement.removeEventListener('gridiot:camera-settled', onCameraSettled);\n\t\tgridElement.removeEventListener('gridiot:resize-start', onResizeStart);\n\t\tgridElement.removeEventListener('gridiot:resize-move', onResizeMove);\n\t\tgridElement.removeEventListener('gridiot:resize-end', onResizeEnd);\n\t\tgridElement.removeEventListener('gridiot:resize-cancel', onResizeCancel);\n\t};\n}\n\n// Register as a plugin for auto-initialization via init()\nregisterPlugin({\n\tname: 'algorithm-push',\n\tinit(\n\t\tcore,\n\t\toptions?: AlgorithmPushPluginOptions & {\n\t\t\tcore?: GridiotCore;\n\t\t\tlayoutModel?: ResponsiveLayoutModel;\n\t\t\tstyleElement?: HTMLStyleElement;\n\t\t},\n\t) {\n\t\treturn attachPushAlgorithm(core.element, {\n\t\t\t...options,\n\t\t\tcore: options?.core ?? core,\n\t\t});\n\t},\n});\n", "/**\n * Responsive Plugin\n *\n * Handles responsive column detection and CSS injection for different breakpoints.\n *\n * Responsibilities:\n * - Detect column count changes via ResizeObserver\n * - Inject CSS for all breakpoints using container queries\n * - Register 'columnCount' provider for other plugins\n * - Emit 'gridiot:column-count-change' events\n * - Regenerate CSS when layout model changes\n *\n * CSS is injected once on init and regenerated when the layout model changes.\n * The actual responsive layout switching is handled by CSS container queries.\n */\n\nimport { registerPlugin } from '../engine';\nimport type {\n\tColumnCountChangeDetail,\n\tGridiotCore,\n\tResponsiveLayoutModel,\n\tResponsivePluginOptions,\n} from '../types';\n\nconst DEBUG = false;\nfunction log(...args: unknown[]) {\n\tif (DEBUG) console.log('[responsive]', ...args);\n}\n\n/**\n * Responsive state exposed via provider registry\n */\nexport interface ResponsiveState {\n\tcolumnCount: number;\n\tmaxColumns: number;\n\tminColumns: number;\n\thasOverride: boolean;\n}\n\n/**\n * Attach the responsive plugin to a grid element.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options including layout model and style element\n * @param core - Optional GridiotCore for provider registration\n * @returns Cleanup function to detach the plugin\n */\nexport function attachResponsive(\n\tgridElement: HTMLElement,\n\toptions: ResponsivePluginOptions,\n\tcore?: GridiotCore,\n): () => void {\n\tconst { layoutModel, styleElement } = options;\n\n\t// Infer cell size and gap from CSS if not provided\n\tlet cellSize = options.cellSize;\n\tlet gap = options.gap;\n\n\tfunction inferGridMetrics(): void {\n\t\tif (cellSize !== undefined && gap !== undefined) return;\n\n\t\tconst style = getComputedStyle(gridElement);\n\n\t\tif (gap === undefined) {\n\t\t\tgap = parseFloat(style.columnGap) || parseFloat(style.gap) || 16;\n\t\t}\n\n\t\tif (cellSize === undefined) {\n\t\t\t// Try to infer from grid-auto-rows or first track\n\t\t\tconst autoRows = parseFloat(style.gridAutoRows) || 0;\n\t\t\tif (autoRows > 0) {\n\t\t\t\tcellSize = autoRows;\n\t\t\t} else {\n\t\t\t\t// Fall back to first column track width\n\t\t\t\tconst columns = style.gridTemplateColumns.split(' ');\n\t\t\t\tcellSize = parseFloat(columns[0] ?? '184') || 184;\n\t\t\t}\n\t\t}\n\n\t\tlog('Inferred grid metrics:', { cellSize, gap });\n\t}\n\n\t/**\n\t * Detect current column count from computed grid style\n\t */\n\tfunction detectColumnCount(): number {\n\t\tconst style = getComputedStyle(gridElement);\n\t\tconst columns = style.gridTemplateColumns.split(' ').filter(Boolean);\n\t\treturn Math.max(1, columns.length);\n\t}\n\n\t/**\n\t * Inject CSS for all breakpoints\n\t */\n\tfunction injectCSS(): void {\n\t\tinferGridMetrics();\n\n\t\t// Use the grid element's class or ID as the selector\n\t\tconst gridSelector = gridElement.id\n\t\t\t? `#${gridElement.id}`\n\t\t\t: gridElement.className\n\t\t\t\t? `.${gridElement.className.split(' ')[0]}`\n\t\t\t\t: '.grid';\n\n\t\tconst css = layoutModel.generateAllBreakpointCSS({\n\t\t\tcellSize: cellSize!,\n\t\t\tgap: gap!,\n\t\t\tgridSelector,\n\t\t});\n\n\t\tstyleElement.textContent = css;\n\t\tlog('Injected CSS for all breakpoints');\n\t}\n\n\t// Register provider if core is provided\n\tif (core) {\n\t\tcore.providers.register<ResponsiveState>('responsive', () => ({\n\t\t\tcolumnCount: layoutModel.currentColumnCount,\n\t\t\tmaxColumns: layoutModel.maxColumns,\n\t\t\tminColumns: layoutModel.minColumns,\n\t\t\thasOverride: layoutModel.hasOverride(layoutModel.currentColumnCount),\n\t\t}));\n\t}\n\n\t// Track if server-rendered CSS was detected\n\t// When true, we only inject CSS for explicit user overrides, not derived layouts\n\tconst hasServerRenderedCSS = !!styleElement.textContent?.trim();\n\n\t// Only inject CSS if style element is empty (not server-rendered)\n\t// This prevents flash when server has already provided initial CSS\n\tif (!hasServerRenderedCSS) {\n\t\tinjectCSS();\n\t} else {\n\t\tlog('Skipping initial CSS injection - server-rendered CSS detected');\n\t}\n\n\t// Subscribe to layout model changes\n\t// The subscription only fires on user actions (saveLayout/clearOverride),\n\t// so we always inject CSS here - the initial hasServerRenderedCSS check\n\t// prevents injection on page load, this handles user interactions.\n\tconst unsubscribe = layoutModel.subscribe(() => {\n\t\tlog('Layout model changed, regenerating CSS');\n\t\tinjectCSS();\n\t});\n\n\t// Watch for resize to update column count tracking\n\tlet lastColumnCount = layoutModel.currentColumnCount;\n\n\tconst resizeObserver = new ResizeObserver(() => {\n\t\tconst newColumnCount = detectColumnCount();\n\n\t\tif (newColumnCount !== lastColumnCount) {\n\t\t\tconst previousCount = lastColumnCount;\n\t\t\tlastColumnCount = newColumnCount;\n\n\t\t\t// Update layout model\n\t\t\tlayoutModel.setCurrentColumnCount(newColumnCount);\n\n\t\t\tlog('Column count changed:', previousCount, '->', newColumnCount);\n\n\t\t\t// Emit event\n\t\t\tconst detail: ColumnCountChangeDetail = {\n\t\t\t\tpreviousCount,\n\t\t\t\tcurrentCount: newColumnCount,\n\t\t\t};\n\n\t\t\tgridElement.dispatchEvent(\n\t\t\t\tnew CustomEvent('gridiot:column-count-change', {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t});\n\n\tresizeObserver.observe(gridElement);\n\n\t// Cleanup function\n\treturn () => {\n\t\tresizeObserver.disconnect();\n\t\tunsubscribe();\n\t};\n}\n\n/**\n * Create a container wrapper element for container queries.\n * The grid must be inside a container with `container-type: inline-size`.\n *\n * If the grid's parent doesn't have container-type set, this helper\n * can wrap the grid or apply the necessary styles.\n *\n * @param gridElement - The grid container element\n * @returns The wrapper element (or the parent if already suitable)\n */\nexport function ensureContainerWrapper(gridElement: HTMLElement): HTMLElement {\n\tconst parent = gridElement.parentElement;\n\n\tif (parent) {\n\t\tconst style = getComputedStyle(parent);\n\t\tif (style.containerType === 'inline-size' || style.containerType === 'size') {\n\t\t\t// Parent already has container-type set\n\t\t\treturn parent;\n\t\t}\n\t}\n\n\t// Check if the grid itself can be the container\n\t// (not recommended, but possible)\n\tconst gridStyle = getComputedStyle(gridElement);\n\tif (gridStyle.containerType === 'inline-size' || gridStyle.containerType === 'size') {\n\t\treturn gridElement;\n\t}\n\n\t// Need to apply container-type to parent or create a wrapper\n\tif (parent) {\n\t\tparent.style.containerType = 'inline-size';\n\t\tlog('Applied container-type: inline-size to parent');\n\t\treturn parent;\n\t}\n\n\t// Fallback: grid is at document root, can't do much\n\tconsole.warn(\n\t\t'[gridiot:responsive] Grid has no parent element. Container queries may not work.',\n\t);\n\treturn gridElement;\n}\n\n// Register as a plugin for auto-initialization via init()\nregisterPlugin({\n\tname: 'responsive',\n\tinit(\n\t\tcore,\n\t\toptions?: ResponsivePluginOptions & {\n\t\t\tcore?: GridiotCore;\n\t\t\tlayoutModel?: ResponsiveLayoutModel;\n\t\t\tstyleElement?: HTMLStyleElement;\n\t\t},\n\t) {\n\t\t// Responsive requires both layoutModel and styleElement\n\t\tif (!options?.layoutModel || !options?.styleElement) {\n\t\t\t// Skip silently - responsive is optional and requires these resources\n\t\t\treturn;\n\t\t}\n\n\t\treturn attachResponsive(\n\t\t\tcore.element,\n\t\t\t{\n\t\t\t\tlayoutModel: options.layoutModel,\n\t\t\t\tstyleElement: options.styleElement,\n\t\t\t\tcellSize: options.cellSize,\n\t\t\t\tgap: options.gap,\n\t\t\t},\n\t\t\toptions.core ?? core,\n\t\t);\n\t},\n});\n", "/**\n * Responsive Layout Model\n *\n * Manages layouts across different column counts with a three-tier system:\n * 1. Canonical layout - source of truth at maxColumns\n * 2. Per-column-count overrides - user customizations at specific breakpoints\n * 3. Auto-derived layouts - calculated via compaction for other column counts\n *\n * This module is pure data/logic with no DOM dependencies, making it suitable\n * for use with backend-driven state (e.g., Datastar integration).\n */\n\nimport type {\n\tBreakpointCSSOptions,\n\tCreateLayoutModelOptions,\n\tItemDefinition,\n\tItemPosition,\n\tLayoutItem,\n\tResponsiveLayoutModel,\n} from './types';\n\nconst MAX_ROWS = 100; // Safety limit for layout derivation\n\n/**\n * Create a responsive layout model\n */\nexport function createLayoutModel(\n\toptions: CreateLayoutModelOptions,\n): ResponsiveLayoutModel {\n\tconst { maxColumns, minColumns = 1, items: itemDefs } = options;\n\n\t// Store item definitions\n\tconst items = new Map<string, ItemDefinition>();\n\tfor (const item of itemDefs) {\n\t\titems.set(item.id, { id: item.id, width: item.width, height: item.height });\n\t}\n\n\t// Store canonical positions (at maxColumns)\n\tlet canonicalPositions = new Map<string, ItemPosition>(\n\t\toptions.canonicalPositions,\n\t);\n\n\t// Store per-column-count overrides\n\tconst overrides = new Map<number, Map<string, ItemPosition>>(\n\t\toptions.overrides,\n\t);\n\n\t// Current column count (updated by responsive plugin)\n\tlet currentColumnCount = maxColumns;\n\n\t// Subscribers for layout changes\n\tconst subscribers = new Set<() => void>();\n\n\tfunction notifySubscribers(): void {\n\t\tfor (const callback of Array.from(subscribers)) {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * Get items sorted by position (top-to-bottom, left-to-right)\n\t * Used for consistent ordering in layout derivation\n\t */\n\tfunction getItemsInPositionOrder(\n\t\tpositions: Map<string, ItemPosition>,\n\t): ItemDefinition[] {\n\t\treturn Array.from(items.values()).sort((a, b) => {\n\t\t\tconst posA = positions.get(a.id) ?? { column: 0, row: 0 };\n\t\t\tconst posB = positions.get(b.id) ?? { column: 0, row: 0 };\n\t\t\t// Sort by row first, then column\n\t\t\treturn posA.row - posB.row || posA.column - posB.column;\n\t\t});\n\t}\n\n\t/**\n\t * Derive layout for a given column count using first-fit compaction.\n\t * Items are placed in position order (top-to-bottom, left-to-right)\n\t * into the first available space that fits.\n\t */\n\tfunction deriveLayoutForColumns(\n\t\tcols: number,\n\t\tsourcePositions: Map<string, ItemPosition>,\n\t): Map<string, ItemPosition> {\n\t\tconst sorted = getItemsInPositionOrder(sourcePositions);\n\t\tconst result = new Map<string, ItemPosition>();\n\n\t\t// 2D occupancy grid: occupied[row][col] = itemId or null\n\t\tconst occupied: (string | null)[][] = [];\n\t\tfor (let r = 0; r < MAX_ROWS; r++) {\n\t\t\toccupied.push(new Array(cols).fill(null));\n\t\t}\n\n\t\tfor (const itemDef of sorted) {\n\t\t\t// Clamp width to available columns\n\t\t\tconst w = Math.min(itemDef.width, cols);\n\t\t\tconst h = itemDef.height;\n\n\t\t\t// Find first available position (first-fit)\n\t\t\tlet placed = false;\n\t\t\tfor (let row = 0; row < MAX_ROWS && !placed; row++) {\n\t\t\t\tfor (let col = 0; col <= cols - w && !placed; col++) {\n\t\t\t\t\t// Check if space is available\n\t\t\t\t\tlet canFit = true;\n\t\t\t\t\tfor (let dy = 0; dy < h && canFit; dy++) {\n\t\t\t\t\t\tfor (let dx = 0; dx < w && canFit; dx++) {\n\t\t\t\t\t\t\tif (occupied[row + dy]?.[col + dx] !== null) {\n\t\t\t\t\t\t\t\tcanFit = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (canFit) {\n\t\t\t\t\t\tresult.set(itemDef.id, { column: col + 1, row: row + 1 }); // 1-indexed for CSS Grid\n\t\t\t\t\t\t// Mark cells as occupied\n\t\t\t\t\t\tfor (let dy = 0; dy < h; dy++) {\n\t\t\t\t\t\t\tfor (let dx = 0; dx < w; dx++) {\n\t\t\t\t\t\t\t\tif (occupied[row + dy]) {\n\t\t\t\t\t\t\t\t\toccupied[row + dy]![col + dx] = itemDef.id;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplaced = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!placed) {\n\t\t\t\t// Fallback: place at bottom (shouldn't happen with reasonable MAX_ROWS)\n\t\t\t\tresult.set(itemDef.id, { column: 1, row: MAX_ROWS });\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Calculate breakpoint width for a given column count.\n\t * n columns needs: n * cellSize + (n - 1) * gap pixels\n\t */\n\tfunction getBreakpointWidth(cols: number, cellSize: number, gap: number): number {\n\t\treturn cols * cellSize + (cols - 1) * gap;\n\t}\n\n\tconst model: ResponsiveLayoutModel = {\n\t\tget maxColumns() {\n\t\t\treturn maxColumns;\n\t\t},\n\t\tget minColumns() {\n\t\t\treturn minColumns;\n\t\t},\n\t\tget items() {\n\t\t\treturn items;\n\t\t},\n\t\tget currentColumnCount() {\n\t\t\treturn currentColumnCount;\n\t\t},\n\n\t\tgetLayoutForColumns(columnCount: number): Map<string, ItemPosition> {\n\t\t\t// Clamp to valid range\n\t\t\tconst cols = Math.max(minColumns, Math.min(maxColumns, columnCount));\n\n\t\t\tif (cols === maxColumns) {\n\t\t\t\treturn new Map(canonicalPositions);\n\t\t\t}\n\n\t\t\t// Check for explicit override\n\t\t\tconst override = overrides.get(cols);\n\t\t\tif (override) {\n\t\t\t\treturn new Map(override);\n\t\t\t}\n\n\t\t\t// Auto-derive from canonical\n\t\t\treturn deriveLayoutForColumns(cols, canonicalPositions);\n\t\t},\n\n\t\tgetCurrentLayout(): Map<string, ItemPosition> {\n\t\t\treturn this.getLayoutForColumns(currentColumnCount);\n\t\t},\n\n\t\thasOverride(columnCount: number): boolean {\n\t\t\treturn overrides.has(columnCount);\n\t\t},\n\n\t\tgetOverrideColumnCounts(): number[] {\n\t\t\treturn Array.from(overrides.keys()).sort((a, b) => b - a);\n\t\t},\n\n\t\tsaveLayout(columnCount: number, positions: Map<string, ItemPosition>): void {\n\t\t\tconst cols = Math.max(minColumns, Math.min(maxColumns, columnCount));\n\n\t\t\tif (cols === maxColumns) {\n\t\t\t\t// Update canonical layout\n\t\t\t\tcanonicalPositions = new Map(positions);\n\t\t\t} else {\n\t\t\t\t// Create/update override\n\t\t\t\toverrides.set(cols, new Map(positions));\n\t\t\t}\n\n\t\t\tnotifySubscribers();\n\t\t},\n\n\t\tclearOverride(columnCount: number): void {\n\t\t\tif (columnCount === maxColumns) {\n\t\t\t\t// Can't clear canonical layout\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (overrides.delete(columnCount)) {\n\t\t\t\tnotifySubscribers();\n\t\t\t}\n\t\t},\n\n\t\tupdateItemSize(itemId: string, size: { width: number; height: number }): void {\n\t\t\tconst existing = items.get(itemId);\n\t\t\tif (!existing) {\n\t\t\t\tconsole.warn(`[layout-model] updateItemSize: item \"${itemId}\" not found in items Map. Available IDs:`, Array.from(items.keys()));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Update the item definition\n\t\t\titems.set(itemId, {\n\t\t\t\tid: itemId,\n\t\t\t\twidth: size.width,\n\t\t\t\theight: size.height,\n\t\t\t});\n\n\t\t\tnotifySubscribers();\n\t\t},\n\n\t\tsetCurrentColumnCount(columnCount: number): void {\n\t\t\tconst newCount = Math.max(minColumns, Math.min(maxColumns, columnCount));\n\t\t\tif (newCount !== currentColumnCount) {\n\t\t\t\tcurrentColumnCount = newCount;\n\t\t\t\t// Note: We don't notify here because this is just tracking state.\n\t\t\t\t// The responsive plugin will emit an event for UI updates.\n\t\t\t}\n\t\t},\n\n\t\tgenerateAllBreakpointCSS(options?: BreakpointCSSOptions): string {\n\t\t\tconst {\n\t\t\t\tselectorPrefix = '#',\n\t\t\t\tselectorSuffix = '',\n\t\t\t\tcellSize,\n\t\t\t\tgap,\n\t\t\t\tgridSelector = '.grid-container',\n\t\t\t} = options ?? { cellSize: 184, gap: 16 };\n\n\t\t\tconst cssRules: string[] = [];\n\n\t\t\t// Generate fallback rules (canonical layout, no container query)\n\t\t\t// These apply immediately before container queries are evaluated\n\t\t\tcssRules.push('/* Fallback: canonical layout (before container queries evaluate) */');\n\t\t\tfor (const [id, pos] of Array.from(canonicalPositions)) {\n\t\t\t\tconst itemDef = items.get(id);\n\t\t\t\tif (!itemDef) continue;\n\t\t\t\tcssRules.push(\n\t\t\t\t\t`${selectorPrefix}${id}${selectorSuffix} { grid-column: ${pos.column} / span ${itemDef.width}; grid-row: ${pos.row} / span ${itemDef.height}; }`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tcssRules.push('');\n\n\t\t\t// Generate rules for each column count (maxColumns down to minColumns)\n\t\t\tfor (let cols = maxColumns; cols >= minColumns; cols--) {\n\t\t\t\tconst positions = this.getLayoutForColumns(cols);\n\t\t\t\tconst minWidth = getBreakpointWidth(cols, cellSize, gap);\n\t\t\t\tconst hasOverride = overrides.has(cols);\n\n\t\t\t\t// Build container query\n\t\t\t\tlet containerQuery: string;\n\t\t\t\tif (cols === maxColumns) {\n\t\t\t\t\tcontainerQuery = `@container (min-width: ${minWidth}px)`;\n\t\t\t\t} else if (cols === minColumns) {\n\t\t\t\t\t// Smallest size is the default/fallback\n\t\t\t\t\tconst maxWidth = getBreakpointWidth(cols + 1, cellSize, gap) - 1;\n\t\t\t\t\tcontainerQuery = `@container (max-width: ${maxWidth}px)`;\n\t\t\t\t} else {\n\t\t\t\t\tconst maxWidth = getBreakpointWidth(cols + 1, cellSize, gap) - 1;\n\t\t\t\t\tcontainerQuery = `@container (min-width: ${minWidth}px) and (max-width: ${maxWidth}px)`;\n\t\t\t\t}\n\n\t\t\t\t// Build rules for this column count\n\t\t\t\tconst itemRules: string[] = [];\n\n\t\t\t\t// Grid template\n\t\t\t\titemRules.push(\n\t\t\t\t\t`${gridSelector} { grid-template-columns: repeat(${cols}, 1fr); }`,\n\t\t\t\t);\n\n\t\t\t\t// Item positions\n\t\t\t\tfor (const [id, pos] of positions) {\n\t\t\t\t\tconst itemDef = items.get(id);\n\t\t\t\t\tif (!itemDef) continue;\n\n\t\t\t\t\t// Clamp width to current column count\n\t\t\t\t\tconst w = Math.min(itemDef.width, cols);\n\t\t\t\t\titemRules.push(\n\t\t\t\t\t\t`${selectorPrefix}${id}${selectorSuffix} { grid-column: ${pos.column} / span ${w}; grid-row: ${pos.row} / span ${itemDef.height}; }`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Add comment and rules\n\t\t\t\tconst layoutType =\n\t\t\t\t\tcols === maxColumns\n\t\t\t\t\t\t? '(canonical)'\n\t\t\t\t\t\t: hasOverride\n\t\t\t\t\t\t\t? '(override)'\n\t\t\t\t\t\t\t: '(derived)';\n\t\t\t\tcssRules.push(`/* ${cols} columns ${layoutType} */`);\n\t\t\t\tcssRules.push(`${containerQuery} {`);\n\t\t\t\tcssRules.push(itemRules.map((r) => '  ' + r).join('\\n'));\n\t\t\t\tcssRules.push('}');\n\t\t\t\tcssRules.push('');\n\t\t\t}\n\n\t\t\treturn cssRules.join('\\n');\n\t\t},\n\n\t\tsubscribe(callback: () => void): () => void {\n\t\t\tsubscribers.add(callback);\n\t\t\treturn () => subscribers.delete(callback);\n\t\t},\n\t};\n\n\treturn model;\n}\n\n/**\n * Build LayoutItem array from positions and definitions\n * Useful for algorithm plugins that need the full item data\n */\nexport function buildLayoutItems(\n\titemDefs: ReadonlyMap<string, ItemDefinition>,\n\tpositions: Map<string, ItemPosition>,\n\tcolumnCount: number,\n): LayoutItem[] {\n\tconst result: LayoutItem[] = [];\n\n\tfor (const [id, def] of Array.from(itemDefs)) {\n\t\tconst pos = positions.get(id);\n\t\tif (pos) {\n\t\t\tresult.push({\n\t\t\t\tid: def.id,\n\t\t\t\t// Clamp width to current column count\n\t\t\t\twidth: Math.min(def.width, columnCount),\n\t\t\t\theight: def.height,\n\t\t\t\tcolumn: pos.column,\n\t\t\t\trow: pos.row,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Convert LayoutItem array back to positions map\n */\nexport function layoutItemsToPositions(\n\titems: LayoutItem[],\n): Map<string, ItemPosition> {\n\tconst positions = new Map<string, ItemPosition>();\n\tfor (const item of items) {\n\t\tpositions.set(item.id, { column: item.column, row: item.row });\n\t}\n\treturn positions;\n}\n"],
  "mappings": "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",
  "names": ["keyboardMode", "DEBUG", "log", "gridInfo", "isDragging", "DEBUG", "log", "setItemCell", "DEBUG", "log", "options"]
}
