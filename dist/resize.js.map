{
  "version": 3,
  "sources": ["../engine.ts", "../utils/flip.ts", "../plugins/resize.ts"],
  "sourcesContent": ["import type { GridCell, GridiotCore, InitOptions, Plugin, PluginOptions, ProviderRegistry } from './types';\nimport { createStateMachine, type GridiotStateMachine } from './state-machine';\n\n// Global plugin registry\nconst plugins = new Map<string, Plugin>();\n\nexport function registerPlugin(plugin: Plugin): void {\n\tplugins.set(plugin.name, plugin);\n}\n\nexport function getPlugin(name: string): Plugin | undefined {\n\treturn plugins.get(name);\n}\n\n/**\n * Initialize Gridiot on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options including layoutModel, styleElement, and plugin options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): GridiotCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t\tplugins: pluginOptions = {},\n\t\tdisablePlugins = [],\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\t// Create centralized state machine\n\tconst stateMachine = createStateMachine();\n\n\t// Track selected element (state machine stores itemId, we need the element)\n\tlet selectedElement: HTMLElement | null = null;\n\n\t// Provider registry for inter-plugin communication\n\tconst providerMap = new Map<string, () => unknown>();\n\tconst providers: ProviderRegistry = {\n\t\tregister<T>(capability: string, provider: () => T): void {\n\t\t\tif (providerMap.has(capability)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Gridiot: Provider for \"${capability}\" already registered, overwriting`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tproviderMap.set(capability, provider);\n\t\t},\n\n\t\tget<T>(capability: string): T | undefined {\n\t\t\tconst provider = providerMap.get(capability);\n\t\t\treturn provider ? (provider() as T) : undefined;\n\t\t},\n\n\t\thas(capability: string): boolean {\n\t\t\treturn providerMap.has(capability);\n\t\t},\n\t};\n\n\tconst core: GridiotCore = {\n\t\telement,\n\t\tproviders,\n\t\tstateMachine,\n\n\t\t// Selection state (backed by state machine)\n\t\tget selectedItem() {\n\t\t\treturn selectedElement;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedElement) return;\n\n\t\t\tconst previousItem = selectedElement;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-gridiot-selected');\n\t\t\t}\n\n\t\t\t// Update state machine and local element reference\n\t\t\tif (item) {\n\t\t\t\tconst itemId = item.id || item.getAttribute('data-gridiot-item') || '';\n\t\t\t\tstateMachine.transition({ type: 'SELECT', itemId, element: item });\n\t\t\t\tselectedElement = item;\n\t\t\t\titem.setAttribute('data-gridiot-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else {\n\t\t\t\tstateMachine.transition({ type: 'DESELECT' });\n\t\t\t\tselectedElement = null;\n\t\t\t\tif (previousItem) {\n\t\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`gridiot:${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tobserver.disconnect();\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Observe position changes and animate with View Transitions\n\tconst observer = new MutationObserver((mutations) => {\n\t\t// Collect items that changed position\n\t\tconst changedItems = new Set<HTMLElement>();\n\n\t\tfor (const mutation of mutations) {\n\t\t\tif (\n\t\t\t\tmutation.type === 'attributes' &&\n\t\t\t\tmutation.target instanceof HTMLElement\n\t\t\t) {\n\t\t\t\tconst item = mutation.target.closest(\n\t\t\t\t\t'[data-gridiot-item]',\n\t\t\t\t) as HTMLElement | null;\n\t\t\t\tif (item && element.contains(item)) {\n\t\t\t\t\tchangedItems.add(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Animate changes with View Transitions if available\n\t\tif (changedItems.size > 0 && 'startViewTransition' in document) {\n\t\t\t// Items already moved - View Transitions will handle animation\n\t\t\t// The browser captures before/after states automatically\n\t\t}\n\t});\n\n\tobserver.observe(element, {\n\t\tsubtree: true,\n\t\tattributes: true,\n\t\tattributeFilter: ['style', 'class'],\n\t});\n\n\t// Register state machine provider for plugin access\n\tproviders.register('state', () => stateMachine.getState());\n\n\t// Initialize all registered plugins with options\n\tfor (const plugin of plugins.values()) {\n\t\t// Skip disabled plugins\n\t\tif (disablePlugins.includes(plugin.name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Build options for this plugin\n\t\tconst pluginSpecificOptions = pluginOptions[plugin.name as keyof PluginOptions] ?? {};\n\t\tconst opts = {\n\t\t\t...pluginSpecificOptions,\n\t\t\t// Pass shared resources to all plugins that might need them\n\t\t\tlayoutModel,\n\t\t\tstyleElement,\n\t\t\tcore,\n\t\t};\n\n\t\tconst cleanup = plugin.init(core, opts);\n\t\tif (cleanup) {\n\t\t\tcleanups.push(cleanup);\n\t\t}\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Set an item's grid position\n */\nexport function setItemCell(item: HTMLElement, cell: GridCell): void {\n\titem.style.gridColumn = String(cell.column);\n\titem.style.gridRow = String(cell.row);\n}\n\n/**\n * Get grid info for a grid element\n */\nexport function getGridInfo(element: HTMLElement) {\n\tconst rect = element.getBoundingClientRect();\n\tconst style = getComputedStyle(element);\n\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\tconst columnGap = parseFloat(style.columnGap) || 0;\n\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\treturn {\n\t\trect,\n\t\tcolumns,\n\t\trows,\n\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\tcellWidth: columns[0] || 0,\n\t\tcellHeight: rows[0] || 0,\n\t};\n}\n", "/**\n * FLIP Animation Utility\n *\n * Provides shared FLIP (First, Last, Invert, Play) animation utilities\n * used by pointer and resize plugins for smooth position/scale transitions.\n */\n\nexport interface FLIPOptions {\n\t/** Animation duration in milliseconds. @default 200 */\n\tduration?: number;\n\t/** CSS easing function. @default 'cubic-bezier(0.2, 0, 0, 1)' */\n\teasing?: string;\n\t/** Include scale transform (for resize). @default false */\n\tincludeScale?: boolean;\n\t/** Transform origin for scale animations. @default undefined (uses center) */\n\ttransformOrigin?: string;\n\t/** Callback when animation starts */\n\tonStart?: () => void;\n\t/** Callback when animation finishes */\n\tonFinish?: () => void;\n}\n\n/**\n * Animate an element from its previous position/size to its new position/size using FLIP.\n *\n * @param element - The element to animate\n * @param firstRect - The element's bounding rect before the DOM change (the \"First\" in FLIP)\n * @param options - Animation options\n * @returns The Animation object, or null if no animation was needed\n *\n * @example\n * ```ts\n * // Capture position before DOM change\n * const firstRect = element.getBoundingClientRect();\n *\n * // Make DOM changes (e.g., update grid position)\n * element.style.gridColumn = '2 / span 2';\n *\n * // Animate from old position to new\n * requestAnimationFrame(() => {\n *   animateFLIP(element, firstRect);\n * });\n * ```\n */\nexport function animateFLIP(\n\telement: HTMLElement,\n\tfirstRect: DOMRect,\n\toptions: FLIPOptions = {},\n): Animation | null {\n\tconst {\n\t\tduration = 200,\n\t\teasing = 'cubic-bezier(0.2, 0, 0, 1)',\n\t\tincludeScale = false,\n\t\ttransformOrigin,\n\t\tonStart,\n\t\tonFinish,\n\t} = options;\n\n\t// Measure final position (the \"Last\" in FLIP)\n\tconst lastRect = element.getBoundingClientRect();\n\n\t// Calculate position deltas (the \"Invert\" in FLIP)\n\tconst deltaX = firstRect.left - lastRect.left;\n\tconst deltaY = firstRect.top - lastRect.top;\n\n\tconst needsTranslate = Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1;\n\n\t// Calculate scale deltas (for resize)\n\tlet scaleX = 1;\n\tlet scaleY = 1;\n\tlet needsScale = false;\n\n\tif (includeScale) {\n\t\tscaleX = firstRect.width / lastRect.width;\n\t\tscaleY = firstRect.height / lastRect.height;\n\t\tneedsScale = Math.abs(scaleX - 1) > 0.01 || Math.abs(scaleY - 1) > 0.01;\n\t}\n\n\t// Skip animation if no significant change\n\tif (!needsTranslate && !needsScale) {\n\t\tonFinish?.();\n\t\treturn null;\n\t}\n\n\tonStart?.();\n\n\t// Build keyframes based on what's needed\n\tconst keyframes: Keyframe[] = includeScale\n\t\t? [\n\t\t\t\t{\n\t\t\t\t\ttransform: `translate(${deltaX}px, ${deltaY}px) scale(${scaleX}, ${scaleY})`,\n\t\t\t\t\ttransformOrigin: transformOrigin ?? 'top left',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttransform: 'translate(0, 0) scale(1, 1)',\n\t\t\t\t\ttransformOrigin: transformOrigin ?? 'top left',\n\t\t\t\t},\n\t\t\t]\n\t\t: [\n\t\t\t\t{ transform: `translate(${deltaX}px, ${deltaY}px)` },\n\t\t\t\t{ transform: 'translate(0, 0)' },\n\t\t\t];\n\n\t// Play the animation\n\tconst animation = element.animate(keyframes, {\n\t\tduration,\n\t\teasing,\n\t});\n\n\tanimation.onfinish = () => onFinish?.();\n\n\treturn animation;\n}\n\n/**\n * Get the item's view transition name from various sources.\n * Checks --item-id CSS property, id attribute, and data-id attribute.\n */\nexport function getItemViewTransitionName(element: HTMLElement): string | null {\n\treturn (\n\t\telement.style.getPropertyValue('--item-id') ||\n\t\telement.id ||\n\t\telement.dataset.id ||\n\t\tnull\n\t);\n}\n\n/**\n * Execute a FLIP animation while temporarily excluding the element from View Transitions.\n *\n * This is useful when you want to use FLIP for an animation instead of View Transitions,\n * to prevent the two from conflicting.\n *\n * @param element - The element to animate\n * @param fn - Function that performs the animation (receives firstRect)\n * @returns The Animation object, or null if no animation was needed\n *\n * @example\n * ```ts\n * const firstRect = element.getBoundingClientRect();\n *\n * // Make DOM changes\n * element.style.gridColumn = '2 / span 2';\n *\n * // Animate with View Transition exclusion\n * requestAnimationFrame(() => {\n *   withViewTransitionExclusion(element, () =>\n *     animateFLIP(element, firstRect)\n *   );\n * });\n * ```\n */\nexport function withViewTransitionExclusion(\n\telement: HTMLElement,\n\tfn: () => Animation | null,\n): Animation | null {\n\t// Exclude from View Transitions during FLIP\n\telement.style.viewTransitionName = 'none';\n\n\tconst animation = fn();\n\n\tconst restoreViewTransitionName = () => {\n\t\tconst itemId = getItemViewTransitionName(element);\n\t\tif (itemId) {\n\t\t\telement.style.viewTransitionName = itemId;\n\t\t}\n\t};\n\n\tif (animation) {\n\t\tanimation.addEventListener('finish', restoreViewTransitionName, { once: true });\n\t} else {\n\t\t// No animation needed, restore immediately\n\t\trestoreViewTransitionName();\n\t}\n\n\treturn animation;\n}\n\n/**\n * Perform a complete FLIP animation with data attribute tracking.\n *\n * This is a higher-level helper that:\n * 1. Excludes the element from View Transitions\n * 2. Sets a tracking attribute during animation\n * 3. Animates using FLIP\n * 4. Restores View Transition name when done\n *\n * @param element - The element to animate\n * @param firstRect - The element's bounding rect before the DOM change\n * @param options - Animation options plus optional attribute name\n *\n * @example\n * ```ts\n * const firstRect = element.getBoundingClientRect();\n * element.style.gridColumn = '2 / span 2';\n *\n * requestAnimationFrame(() => {\n *   animateFLIPWithTracking(element, firstRect, {\n *     attributeName: 'data-gridiot-dropping',\n *     includeScale: true,\n *     transformOrigin: 'top left',\n *   });\n * });\n * ```\n */\nexport function animateFLIPWithTracking(\n\telement: HTMLElement,\n\tfirstRect: DOMRect,\n\toptions: FLIPOptions & { attributeName?: string } = {},\n): Animation | null {\n\tconst { attributeName = 'data-gridiot-dropping', ...flipOptions } = options;\n\n\t// Exclude from View Transitions\n\telement.style.viewTransitionName = 'none';\n\n\tconst animation = animateFLIP(element, firstRect, {\n\t\t...flipOptions,\n\t\tonStart: () => {\n\t\t\telement.setAttribute(attributeName, '');\n\t\t\tflipOptions.onStart?.();\n\t\t},\n\t\tonFinish: () => {\n\t\t\telement.removeAttribute(attributeName);\n\t\t\t// Restore view transition name\n\t\t\tconst itemId = getItemViewTransitionName(element);\n\t\t\tif (itemId) {\n\t\t\t\telement.style.viewTransitionName = itemId;\n\t\t\t}\n\t\t\tflipOptions.onFinish?.();\n\t\t},\n\t});\n\n\t// If no animation was needed, clean up immediately\n\tif (!animation) {\n\t\tconst itemId = getItemViewTransitionName(element);\n\t\tif (itemId) {\n\t\t\telement.style.viewTransitionName = itemId;\n\t\t}\n\t}\n\n\treturn animation;\n}\n", "/**\n * Resize plugin for Gridiot\n *\n * Allows users to resize grid items by dragging corners/edges.\n * Resizes modify colspan/rowspan using actual CSS grid changes during resize.\n *\n * Usage:\n *   import { attachResize } from 'gridiot/resize';\n *\n *   const detach = attachResize(gridElement, {\n *     core,                 // GridiotCore instance (required)\n *     handles: 'corners',   // 'corners' | 'edges' | 'all'\n *     handleSize: 12,\n *     minSize: { colspan: 1, rowspan: 1 },\n *     maxSize: { colspan: 6, rowspan: 6 },\n *   });\n */\n\nimport { registerPlugin } from '../engine';\nimport type {\n\tGridCell,\n\tGridiotCore,\n\tResizeCancelDetail,\n\tResizeEndDetail,\n\tResizeHandle,\n\tResizeMoveDetail,\n\tResizePluginOptions,\n\tResizeStartDetail,\n\tResizeState,\n} from '../types';\nimport { animateFLIPWithTracking } from '../utils/flip';\n\nexport interface ResizeOptions {\n\t/** GridiotCore instance (required) */\n\tcore: GridiotCore;\n\t/** Which handles to show: 'corners' | 'edges' | 'all' (default: 'corners') */\n\thandles?: 'corners' | 'edges' | 'all';\n\t/** Size of the hit zone for handles in pixels (default: 12) */\n\thandleSize?: number;\n\t/** Minimum size in grid cells (default: { colspan: 1, rowspan: 1 }) */\n\tminSize?: { colspan: number; rowspan: number };\n\t/** Maximum size in grid cells (default: { colspan: 6, rowspan: 6 }) */\n\tmaxSize?: { colspan: number; rowspan: number };\n\t/** Show size label during resize (default: true) */\n\tshowSizeLabel?: boolean;\n}\n\ninterface ActiveResize {\n\titem: HTMLElement;\n\tpointerId: number;\n\thandle: ResizeHandle;\n\t/** Original cell position at start of resize - never changes */\n\tstartCell: GridCell;\n\t/** Original size at start of resize - never changes */\n\toriginalSize: { colspan: number; rowspan: number };\n\t/** Current position (may differ from startCell for NW/NE/SW handles) */\n\tcurrentCell: GridCell;\n\t/** Current size during resize */\n\tcurrentSize: { colspan: number; rowspan: number };\n\toriginalGridColumn: string;\n\toriginalGridRow: string;\n\tsizeLabel: HTMLElement | null;\n\t/** Initial bounding rect for smooth resize */\n\tinitialRect: DOMRect;\n\t/** Pointer position at start */\n\tstartPointerX: number;\n\tstartPointerY: number;\n\t/** Placeholder element (currently unused but kept for API compatibility) */\n\tplaceholder: HTMLElement | null;\n}\n\n\n/**\n * Detect which resize handle (if any) is under the pointer\n */\nfunction detectHandle(\n\te: PointerEvent,\n\titem: HTMLElement,\n\tsize: number,\n\tmode: 'corners' | 'edges' | 'all',\n): ResizeHandle | null {\n\tconst rect = item.getBoundingClientRect();\n\tconst x = e.clientX - rect.left;\n\tconst y = e.clientY - rect.top;\n\n\tconst nearLeft = x < size;\n\tconst nearRight = x > rect.width - size;\n\tconst nearTop = y < size;\n\tconst nearBottom = y > rect.height - size;\n\n\t// Corners\n\tif (mode === 'corners' || mode === 'all') {\n\t\tif (nearTop && nearLeft) return 'nw';\n\t\tif (nearTop && nearRight) return 'ne';\n\t\tif (nearBottom && nearLeft) return 'sw';\n\t\tif (nearBottom && nearRight) return 'se';\n\t}\n\n\t// Edges (only if not at corners)\n\tif (mode === 'edges' || mode === 'all') {\n\t\tif (nearTop) return 'n';\n\t\tif (nearBottom) return 's';\n\t\tif (nearLeft) return 'w';\n\t\tif (nearRight) return 'e';\n\t}\n\n\treturn null;\n}\n\n/**\n * Get cursor style for a resize handle\n */\nfunction getCursor(handle: ResizeHandle | null): string {\n\tswitch (handle) {\n\t\tcase 'nw':\n\t\tcase 'se':\n\t\t\treturn 'nwse-resize';\n\t\tcase 'ne':\n\t\tcase 'sw':\n\t\t\treturn 'nesw-resize';\n\t\tcase 'n':\n\t\tcase 's':\n\t\t\treturn 'ns-resize';\n\t\tcase 'e':\n\t\tcase 'w':\n\t\t\treturn 'ew-resize';\n\t\tdefault:\n\t\t\treturn '';\n\t}\n}\n\n/**\n * Calculate new size based on pointer position and handle\n */\nfunction calculateNewSize(\n\tcore: GridiotCore,\n\thandle: ResizeHandle,\n\tstartCell: GridCell,\n\toriginalSize: { colspan: number; rowspan: number },\n\tpointerX: number,\n\tpointerY: number,\n\tminSize: { colspan: number; rowspan: number },\n\tmaxSize: { colspan: number; rowspan: number },\n): { colspan: number; rowspan: number; column: number; row: number } {\n\tconst gridInfo = core.getGridInfo();\n\tconst maxColumn = gridInfo.columns.length;\n\tconst maxRow = gridInfo.rows.length;\n\n\t// Get pointer cell, clamping to grid bounds if outside\n\t// This allows resizing to continue even when pointer is outside grid\n\tlet pointerCell = core.getCellFromPoint(pointerX, pointerY);\n\tif (!pointerCell) {\n\t\t// Clamp to grid bounds based on pointer position relative to grid\n\t\tconst rect = gridInfo.rect;\n\t\tconst cellWidth = gridInfo.cellWidth + gridInfo.gap;\n\t\tconst cellHeight = gridInfo.cellHeight + gridInfo.gap;\n\n\t\tlet column: number;\n\t\tlet row: number;\n\n\t\tif (pointerX < rect.left) {\n\t\t\tcolumn = 1;\n\t\t} else if (pointerX > rect.right) {\n\t\t\tcolumn = maxColumn;\n\t\t} else {\n\t\t\tcolumn = Math.max(1, Math.min(maxColumn, Math.floor((pointerX - rect.left) / cellWidth) + 1));\n\t\t}\n\n\t\tif (pointerY < rect.top) {\n\t\t\trow = 1;\n\t\t} else if (pointerY > rect.bottom) {\n\t\t\trow = maxRow;\n\t\t} else {\n\t\t\trow = Math.max(1, Math.min(maxRow, Math.floor((pointerY - rect.top) / cellHeight) + 1));\n\t\t}\n\n\t\tpointerCell = { column, row };\n\t}\n\n\tlet newColspan = originalSize.colspan;\n\tlet newRowspan = originalSize.rowspan;\n\tlet newColumn = startCell.column;\n\tlet newRow = startCell.row;\n\n\t// Handle horizontal resizing\n\tif (handle === 'e' || handle === 'se' || handle === 'ne') {\n\t\t// Right edge: column stays, span grows right\n\t\tnewColspan = Math.max(\n\t\t\tminSize.colspan,\n\t\t\tMath.min(\n\t\t\t\tmaxSize.colspan,\n\t\t\t\tpointerCell.column - startCell.column + 1,\n\t\t\t\tmaxColumn - startCell.column + 1,\n\t\t\t),\n\t\t);\n\t} else if (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t// Left edge: column moves left, right edge stays fixed\n\t\tconst rightEdge = startCell.column + originalSize.colspan - 1;\n\t\tconst newLeft = Math.max(1, Math.min(pointerCell.column, rightEdge));\n\t\tnewColspan = Math.max(\n\t\t\tminSize.colspan,\n\t\t\tMath.min(maxSize.colspan, rightEdge - newLeft + 1),\n\t\t);\n\t\tnewColumn = rightEdge - newColspan + 1;\n\t}\n\n\t// Handle vertical resizing\n\tif (handle === 's' || handle === 'se' || handle === 'sw') {\n\t\t// Bottom edge: row stays, span grows down\n\t\tnewRowspan = Math.max(\n\t\t\tminSize.rowspan,\n\t\t\tMath.min(\n\t\t\t\tmaxSize.rowspan,\n\t\t\t\tpointerCell.row - startCell.row + 1,\n\t\t\t\tmaxRow - startCell.row + 1,\n\t\t\t),\n\t\t);\n\t} else if (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t// Top edge: row moves up, bottom edge stays fixed\n\t\tconst bottomEdge = startCell.row + originalSize.rowspan - 1;\n\t\tconst newTop = Math.max(1, Math.min(pointerCell.row, bottomEdge));\n\t\tnewRowspan = Math.max(\n\t\t\tminSize.rowspan,\n\t\t\tMath.min(maxSize.rowspan, bottomEdge - newTop + 1),\n\t\t);\n\t\tnewRow = bottomEdge - newRowspan + 1;\n\t}\n\n\treturn {\n\t\tcolspan: newColspan,\n\t\trowspan: newRowspan,\n\t\tcolumn: newColumn,\n\t\trow: newRow,\n\t};\n}\n\n/**\n * Create a size label element\n */\nfunction createSizeLabel(): HTMLElement {\n\tconst label = document.createElement('div');\n\tlabel.className = 'gridiot-resize-label';\n\tlabel.style.cssText = `\n\t\tposition: absolute;\n\t\ttop: 50%;\n\t\tleft: 50%;\n\t\ttransform: translate(-50%, -50%);\n\t\tbackground: rgba(0, 0, 0, 0.8);\n\t\tcolor: white;\n\t\tpadding: 4px 8px;\n\t\tborder-radius: 4px;\n\t\tfont-size: 14px;\n\t\tfont-weight: 600;\n\t\tfont-family: system-ui, sans-serif;\n\t\tpointer-events: none;\n\t\tz-index: 1000;\n\t\twhite-space: nowrap;\n\t`;\n\treturn label;\n}\n\n/**\n * Attach resize functionality to a grid element.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach resize\n */\nexport function attachResize(\n\tgridElement: HTMLElement,\n\toptions: ResizeOptions,\n): {\n\tsetSize(item: HTMLElement, size: { colspan: number; rowspan: number }): void;\n\tdestroy(): void;\n} {\n\tconst {\n\t\tcore,\n\t\thandles = 'corners',\n\t\thandleSize = 12,\n\t\tminSize = { colspan: 1, rowspan: 1 },\n\t\tmaxSize = { colspan: 6, rowspan: 6 },\n\t\tshowSizeLabel = true,\n\t} = options;\n\n\tlet activeResize: ActiveResize | null = null;\n\tlet hoveredItem: HTMLElement | null = null;\n\tlet hoveredHandle: ResizeHandle | null = null;\n\n\t// Register provider for inter-plugin state access\n\tcore.providers.register<ResizeState | null>('resize', () => {\n\t\tif (!activeResize) return null;\n\t\treturn {\n\t\t\titem: activeResize.item,\n\t\t\toriginalSize: activeResize.originalSize,\n\t\t\tcurrentSize: activeResize.currentSize,\n\t\t\thandle: activeResize.handle,\n\t\t};\n\t});\n\n\tfunction emit<T>(event: string, detail: T): void {\n\t\tgridElement.dispatchEvent(\n\t\t\tnew CustomEvent(`gridiot:${event}`, {\n\t\t\t\tbubbles: true,\n\t\t\t\tdetail,\n\t\t\t}),\n\t\t);\n\t}\n\n\tfunction startResize(item: HTMLElement, handle: ResizeHandle, e: PointerEvent) {\n\t\tconst colspan =\n\t\t\tparseInt(item.getAttribute('data-gridiot-colspan') || '1', 10) || 1;\n\t\tconst rowspan =\n\t\t\tparseInt(item.getAttribute('data-gridiot-rowspan') || '1', 10) || 1;\n\n\t\tconst style = getComputedStyle(item);\n\t\tconst column = parseInt(style.gridColumnStart, 10) || 1;\n\t\tconst row = parseInt(style.gridRowStart, 10) || 1;\n\n\t\tconst originalSize = { colspan, rowspan };\n\t\tconst startCell = { column, row };\n\t\tconst initialRect = item.getBoundingClientRect();\n\n\t\t// Create size label if enabled\n\t\tlet sizeLabel: HTMLElement | null = null;\n\t\tif (showSizeLabel) {\n\t\t\tsizeLabel = createSizeLabel();\n\t\t\tsizeLabel.textContent = `${colspan}\u00D7${rowspan}`;\n\t\t\titem.appendChild(sizeLabel);\n\t\t}\n\n\t\tactiveResize = {\n\t\t\titem,\n\t\t\tpointerId: e.pointerId,\n\t\t\thandle,\n\t\t\tstartCell,\n\t\t\toriginalSize,\n\t\t\tcurrentCell: { ...startCell },\n\t\t\tcurrentSize: { ...originalSize },\n\t\t\toriginalGridColumn: item.style.gridColumn,\n\t\t\toriginalGridRow: item.style.gridRow,\n\t\t\tsizeLabel,\n\t\t\tinitialRect,\n\t\t\tstartPointerX: e.clientX,\n\t\t\tstartPointerY: e.clientY,\n\t\t\tplaceholder: null, // Will be set below if enabled\n\t\t};\n\n\t\titem.setAttribute('data-gridiot-resizing', '');\n\t\titem.setAttribute('data-gridiot-handle-active', handle);\n\t\titem.removeAttribute('data-gridiot-handle-hover'); // Clear hover state\n\t\titem.setPointerCapture(e.pointerId);\n\n\t\t// Add event listeners to item (pointer capture sends events to this element)\n\t\titem.addEventListener('pointermove', onItemPointerMove);\n\t\titem.addEventListener('pointerup', onItemPointerUp);\n\t\titem.addEventListener('pointercancel', onItemPointerCancel);\n\n\t\t// Emit resize-start BEFORE changing grid styles so originalPositions captures correct layout\n\t\temit<ResizeStartDetail>('resize-start', {\n\t\t\titem,\n\t\t\tcell: startCell,\n\t\t\tcolspan: originalSize.colspan,\n\t\t\trowspan: originalSize.rowspan,\n\t\t\thandle,\n\t\t});\n\n\t\tactiveResize.placeholder = null;\n\n\t\t// Switch to fixed positioning - item follows cursor in viewport coordinates\n\t\t// CSS Grid ignores fixed positioned children, allowing the grid to reflow\n\t\titem.style.position = 'fixed';\n\t\titem.style.left = `${initialRect.left}px`;\n\t\titem.style.top = `${initialRect.top}px`;\n\t\titem.style.width = `${initialRect.width}px`;\n\t\titem.style.height = `${initialRect.height}px`;\n\t\titem.style.zIndex = '100';\n\t\t// Exclude from view transitions during resize\n\t\titem.style.viewTransitionName = 'resizing';\n\t}\n\n\tfunction updateResize(e: PointerEvent) {\n\t\tif (!activeResize) return;\n\n\t\tconst { item, handle, startCell, originalSize, currentCell, currentSize, sizeLabel, initialRect, startPointerX, startPointerY } =\n\t\t\tactiveResize;\n\n\t\tconst gridInfo = core.getGridInfo();\n\n\t\t// Calculate pointer delta\n\t\tconst deltaX = e.clientX - startPointerX;\n\t\tconst deltaY = e.clientY - startPointerY;\n\n\t\t// Calculate new visual dimensions based on handle\n\t\tlet newWidth = initialRect.width;\n\t\tlet newHeight = initialRect.height;\n\t\tlet newLeft = initialRect.left;\n\t\tlet newTop = initialRect.top;\n\n\t\t// Minimum visual size (1 cell)\n\t\tconst minWidth = gridInfo.cellWidth;\n\t\tconst minHeight = gridInfo.cellHeight;\n\t\t// Maximum visual size (clamped by maxSize config)\n\t\tconst maxWidthByConfig = maxSize.colspan * gridInfo.cellWidth + (maxSize.colspan - 1) * gridInfo.gap;\n\t\tconst maxHeightByConfig = maxSize.rowspan * gridInfo.cellHeight + (maxSize.rowspan - 1) * gridInfo.gap;\n\t\t// Maximum visual size (clamped by grid bounds)\n\t\tconst maxWidthByGrid = gridInfo.rect.right - initialRect.left;\n\t\tconst maxHeightByGrid = gridInfo.rect.bottom - initialRect.top;\n\t\tconst maxWidth = Math.min(maxWidthByConfig, maxWidthByGrid);\n\t\tconst maxHeight = Math.min(maxHeightByConfig, maxHeightByGrid);\n\n\t\t// Apply delta based on handle direction\n\t\tif (handle === 'e' || handle === 'se' || handle === 'ne') {\n\t\t\tnewWidth = Math.max(minWidth, Math.min(maxWidth, initialRect.width + deltaX));\n\t\t}\n\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t\t// For left edge, clamp to grid left\n\t\t\tconst maxLeftShift = initialRect.left - gridInfo.rect.left;\n\t\t\tconst maxWidthFromLeft = Math.min(maxWidthByConfig, initialRect.width + maxLeftShift);\n\t\t\tconst widthChange = Math.max(-initialRect.width + minWidth, Math.min(maxWidthFromLeft - initialRect.width, -deltaX));\n\t\t\tnewWidth = initialRect.width + widthChange;\n\t\t\tnewLeft = initialRect.left - widthChange;\n\t\t}\n\t\tif (handle === 's' || handle === 'se' || handle === 'sw') {\n\t\t\tnewHeight = Math.max(minHeight, Math.min(maxHeight, initialRect.height + deltaY));\n\t\t}\n\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t\t// For top edge, clamp to grid top\n\t\t\tconst maxTopShift = initialRect.top - gridInfo.rect.top;\n\t\t\tconst maxHeightFromTop = Math.min(maxHeightByConfig, initialRect.height + maxTopShift);\n\t\t\tconst heightChange = Math.max(-initialRect.height + minHeight, Math.min(maxHeightFromTop - initialRect.height, -deltaY));\n\t\t\tnewHeight = initialRect.height + heightChange;\n\t\t\tnewTop = initialRect.top - heightChange;\n\t\t}\n\n\t\t// Apply smooth visual size (fixed positioning uses viewport coordinates)\n\t\titem.style.left = `${newLeft}px`;\n\t\titem.style.top = `${newTop}px`;\n\t\titem.style.width = `${newWidth}px`;\n\t\titem.style.height = `${newHeight}px`;\n\n\t\t// Calculate projected final grid size (what it will snap to)\n\t\tconst cellPlusGap = gridInfo.cellWidth + gridInfo.gap;\n\t\tconst rowPlusGap = gridInfo.cellHeight + gridInfo.gap;\n\n\t\t// Calculate raw ratios\n\t\tconst rawColspanRatio = (newWidth + gridInfo.gap) / cellPlusGap;\n\t\tconst rawRowspanRatio = (newHeight + gridInfo.gap) / rowPlusGap;\n\n\t\t// Bias calculation for resize direction:\n\t\t// When resizing SE (making bigger), use a lower threshold (0.3 instead of 0.5)\n\t\t// to be more generous about giving the user the larger size\n\t\tconst isGrowingWidth = handle === 'e' || handle === 'se' || handle === 'ne';\n\t\tconst isGrowingHeight = handle === 's' || handle === 'se' || handle === 'sw';\n\n\t\t// Use floor + threshold approach for more predictable snapping\n\t\t// If we're past 30% into the next cell when growing, give the user that cell\n\t\tconst GROW_THRESHOLD = 0.3;\n\t\tconst SHRINK_THRESHOLD = 0.7;\n\n\t\tlet projectedColspan: number;\n\t\tlet projectedRowspan: number;\n\n\t\tif (isGrowingWidth) {\n\t\t\t// When growing: floor, then add 1 if we're past the threshold\n\t\t\tprojectedColspan = Math.floor(rawColspanRatio);\n\t\t\tif (rawColspanRatio - projectedColspan >= GROW_THRESHOLD) {\n\t\t\t\tprojectedColspan += 1;\n\t\t\t}\n\t\t} else {\n\t\t\t// When shrinking: ceil, then subtract 1 if we're below the threshold\n\t\t\tprojectedColspan = Math.ceil(rawColspanRatio);\n\t\t\tif (projectedColspan - rawColspanRatio > (1 - SHRINK_THRESHOLD)) {\n\t\t\t\tprojectedColspan -= 1;\n\t\t\t}\n\t\t}\n\n\t\tif (isGrowingHeight) {\n\t\t\tprojectedRowspan = Math.floor(rawRowspanRatio);\n\t\t\tif (rawRowspanRatio - projectedRowspan >= GROW_THRESHOLD) {\n\t\t\t\tprojectedRowspan += 1;\n\t\t\t}\n\t\t} else {\n\t\t\tprojectedRowspan = Math.ceil(rawRowspanRatio);\n\t\t\tif (projectedRowspan - rawRowspanRatio > (1 - SHRINK_THRESHOLD)) {\n\t\t\t\tprojectedRowspan -= 1;\n\t\t\t}\n\t\t}\n\n\t\t// Apply min/max constraints\n\t\tprojectedColspan = Math.max(minSize.colspan, Math.min(maxSize.colspan, projectedColspan));\n\t\tprojectedRowspan = Math.max(minSize.rowspan, Math.min(maxSize.rowspan, projectedRowspan));\n\n\t\t// Calculate the cell position based on the projected size and anchor corner.\n\t\t// This ensures the anchor corner stays fixed and the cell + size are consistent.\n\t\t// Previously we used calculateNewSize() which computed position from pointer,\n\t\t// but that could mismatch with the visual-based size calculation.\n\t\tlet projectedColumn = startCell.column;\n\t\tlet projectedRow = startCell.row;\n\n\t\t// For handles that move the left edge, calculate column from the right anchor\n\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t\tconst rightEdge = startCell.column + originalSize.colspan - 1;\n\t\t\tprojectedColumn = rightEdge - projectedColspan + 1;\n\t\t}\n\n\t\t// For handles that move the top edge, calculate row from the bottom anchor\n\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t\tconst bottomEdge = startCell.row + originalSize.rowspan - 1;\n\t\t\tprojectedRow = bottomEdge - projectedRowspan + 1;\n\t\t}\n\n\t\t// Update tracking\n\t\tactiveResize.currentSize = { colspan: projectedColspan, rowspan: projectedRowspan };\n\t\tactiveResize.currentCell = { column: projectedColumn, row: projectedRow };\n\n\t\t// Update size label with projected final size\n\t\tif (sizeLabel) {\n\t\t\tsizeLabel.textContent = `${projectedColspan}\u00D7${projectedRowspan}`;\n\t\t}\n\n\t\t// Calculate anchor cell (the corner that stays fixed during resize)\n\t\tlet anchorCell: GridCell;\n\t\tif (handle === 'se' || handle === 's' || handle === 'e') {\n\t\t\t// NW corner is anchor\n\t\t\tanchorCell = { column: startCell.column, row: startCell.row };\n\t\t} else if (handle === 'nw' || handle === 'n' || handle === 'w') {\n\t\t\t// SE corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column + originalSize.colspan - 1,\n\t\t\t\trow: startCell.row + originalSize.rowspan - 1,\n\t\t\t};\n\t\t} else if (handle === 'ne') {\n\t\t\t// SW corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column,\n\t\t\t\trow: startCell.row + originalSize.rowspan - 1,\n\t\t\t};\n\t\t} else {\n\t\t\t// SW handle: NE corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column + originalSize.colspan - 1,\n\t\t\t\trow: startCell.row,\n\t\t\t};\n\t\t}\n\n\t\temit<ResizeMoveDetail>('resize-move', {\n\t\t\titem,\n\t\t\tcell: { column: projectedColumn, row: projectedRow },\n\t\t\tanchorCell,\n\t\t\tstartCell,\n\t\t\tcolspan: projectedColspan,\n\t\t\trowspan: projectedRowspan,\n\t\t\thandle,\n\t\t});\n\t}\n\n\tfunction cleanupResizeListeners(item: HTMLElement, pointerId: number) {\n\t\titem.releasePointerCapture(pointerId);\n\t\titem.removeEventListener('pointermove', onItemPointerMove);\n\t\titem.removeEventListener('pointerup', onItemPointerUp);\n\t\titem.removeEventListener('pointercancel', onItemPointerCancel);\n\t}\n\n\tfunction finishResize() {\n\t\tif (!activeResize) return;\n\n\t\tconst { item, pointerId, currentSize, currentCell, originalSize, sizeLabel, initialRect, placeholder } = activeResize;\n\n\t\t// Remove placeholder if it exists\n\t\tif (placeholder) {\n\t\t\tplaceholder.remove();\n\t\t}\n\n\t\t// Clean up item event listeners\n\t\tcleanupResizeListeners(item, pointerId);\n\n\t\t// FLIP: Capture current visual position (First)\n\t\tconst firstRect = item.getBoundingClientRect();\n\n\t\t// Update data attributes to reflect new size\n\t\titem.setAttribute('data-gridiot-colspan', String(currentSize.colspan));\n\t\titem.setAttribute('data-gridiot-rowspan', String(currentSize.rowspan));\n\n\t\t// Remove size label before animations\n\t\tif (sizeLabel) {\n\t\t\tsizeLabel.remove();\n\t\t}\n\n\t\temit<ResizeEndDetail>('resize-end', {\n\t\t\titem,\n\t\t\tcell: currentCell,\n\t\t\tcolspan: currentSize.colspan,\n\t\t\trowspan: currentSize.rowspan,\n\t\t});\n\n\t\t// Helper to apply final grid state\n\t\tconst applyFinalState = () => {\n\t\t\t// Clear fixed/absolute positioning\n\t\t\titem.style.position = '';\n\t\t\titem.style.left = '';\n\t\t\titem.style.top = '';\n\t\t\titem.style.width = '';\n\t\t\titem.style.height = '';\n\t\t\titem.style.zIndex = '';\n\n\t\t\t// Set final grid position\n\t\t\titem.style.gridColumn = `${currentCell.column} / span ${currentSize.colspan}`;\n\t\t\titem.style.gridRow = `${currentCell.row} / span ${currentSize.rowspan}`;\n\n\t\t\titem.removeAttribute('data-gridiot-resizing');\n\t\t\titem.removeAttribute('data-gridiot-handle-active');\n\t\t};\n\n\t\t// Exclude from View Transitions during FLIP animation\n\t\titem.style.viewTransitionName = 'none';\n\n\t\t// Apply final state immediately (return to grid flow)\n\t\tapplyFinalState();\n\n\t\t// FLIP: Animate from captured visual position to new grid position\n\t\trequestAnimationFrame(() => {\n\t\t\tconst itemId = item.style.getPropertyValue('--item-id') || item.id || item.dataset.id;\n\n\t\t\tconst animation = animateFLIPWithTracking(item, firstRect, {\n\t\t\t\tincludeScale: true,\n\t\t\t\ttransformOrigin: 'top left',\n\t\t\t\tonFinish: () => {\n\t\t\t\t\t// Explicitly clear any transform that might persist\n\t\t\t\t\titem.style.transform = '';\n\t\t\t\t\t// Clear inline grid styles so layout-styles CSS (with container queries) takes over\n\t\t\t\t\titem.style.gridColumn = '';\n\t\t\t\t\titem.style.gridRow = '';\n\t\t\t\t\t// Restore viewTransitionName so future View Transitions work\n\t\t\t\t\tif (itemId) {\n\t\t\t\t\t\titem.style.viewTransitionName = itemId;\n\t\t\t\t\t} else {\n\t\t\t\t\t\titem.style.viewTransitionName = '';\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// If no animation was needed, ensure cleanup\n\t\t\tif (!animation) {\n\t\t\t\titem.style.transform = '';\n\t\t\t\t// Clear inline grid styles so layout-styles CSS (with container queries) takes over\n\t\t\t\titem.style.gridColumn = '';\n\t\t\t\titem.style.gridRow = '';\n\t\t\t\tif (itemId) {\n\t\t\t\t\titem.style.viewTransitionName = itemId;\n\t\t\t\t} else {\n\t\t\t\t\titem.style.viewTransitionName = '';\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tactiveResize = null;\n\t}\n\n\tfunction cancelResize() {\n\t\tif (!activeResize) return;\n\n\t\tconst { item, pointerId, originalGridColumn, originalGridRow, sizeLabel, placeholder } = activeResize;\n\n\t\t// Clean up item event listeners\n\t\tcleanupResizeListeners(item, pointerId);\n\n\t\t// Remove placeholder if it exists\n\t\tif (placeholder) {\n\t\t\tplaceholder.remove();\n\t\t}\n\n\t\t// Remove size label\n\t\tif (sizeLabel) {\n\t\t\tsizeLabel.remove();\n\t\t}\n\n\t\t// Clear fixed positioning\n\t\titem.style.position = '';\n\t\titem.style.left = '';\n\t\titem.style.top = '';\n\t\titem.style.width = '';\n\t\titem.style.height = '';\n\t\titem.style.zIndex = '';\n\n\t\t// Restore original grid position\n\t\titem.style.gridColumn = originalGridColumn;\n\t\titem.style.gridRow = originalGridRow;\n\n\t\t// Restore view transition name\n\t\tconst itemId = item.style.getPropertyValue('--item-id') || item.id || item.dataset.id;\n\t\tif (itemId) {\n\t\t\titem.style.viewTransitionName = itemId;\n\t\t} else {\n\t\t\titem.style.viewTransitionName = '';\n\t\t}\n\n\t\titem.removeAttribute('data-gridiot-resizing');\n\t\titem.removeAttribute('data-gridiot-handle-active');\n\n\t\temit<ResizeCancelDetail>('resize-cancel', {\n\t\t\titem,\n\t\t});\n\n\t\tactiveResize = null;\n\t}\n\n\t// --- Event handlers ---\n\n\t// Use capture phase to intercept before pointer plugin\n\tconst onPointerDown = (e: PointerEvent) => {\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-gridiot-item]',\n\t\t) as HTMLElement | null;\n\t\tif (!item) return;\n\n\t\tconst handle = detectHandle(e, item, handleSize, handles);\n\t\tif (!handle) return; // Not on handle - let pointer plugin handle drag\n\n\t\t// Stop event from reaching pointer plugin\n\t\te.stopPropagation();\n\t\te.preventDefault();\n\n\t\tstartResize(item, handle, e);\n\t};\n\n\t// Item-specific handlers (added during resize, removed on finish/cancel)\n\tconst onItemPointerMove = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tupdateResize(e);\n\t\t}\n\t};\n\n\tconst onItemPointerUp = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tfinishResize();\n\t\t}\n\t};\n\n\tconst onItemPointerCancel = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tcancelResize();\n\t\t}\n\t};\n\n\t// Grid-level hover handler for cursor changes and handle hover state\n\tconst onPointerMove = (e: PointerEvent) => {\n\t\t// Skip hover handling during active resize\n\t\tif (activeResize) return;\n\n\t\t// Handle hover cursor changes\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-gridiot-item]',\n\t\t) as HTMLElement | null;\n\n\t\tif (item) {\n\t\t\tconst handle = detectHandle(e, item, handleSize, handles);\n\n\t\t\tif (handle !== hoveredHandle || item !== hoveredItem) {\n\t\t\t\t// Clear previous item's hover state\n\t\t\t\tif (hoveredItem && hoveredItem !== item) {\n\t\t\t\t\thoveredItem.style.cursor = '';\n\t\t\t\t\thoveredItem.removeAttribute('data-gridiot-handle-hover');\n\t\t\t\t}\n\n\t\t\t\t// Clear hover attribute if handle changed on same item\n\t\t\t\tif (hoveredItem === item && hoveredHandle && !handle) {\n\t\t\t\t\titem.removeAttribute('data-gridiot-handle-hover');\n\t\t\t\t}\n\n\t\t\t\thoveredItem = item;\n\t\t\t\thoveredHandle = handle;\n\n\t\t\t\t// Set cursor and hover attribute based on handle\n\t\t\t\titem.style.cursor = getCursor(handle) || '';\n\t\t\t\tif (handle) {\n\t\t\t\t\titem.setAttribute('data-gridiot-handle-hover', handle);\n\t\t\t\t} else {\n\t\t\t\t\titem.removeAttribute('data-gridiot-handle-hover');\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (hoveredItem) {\n\t\t\thoveredItem.style.cursor = '';\n\t\t\thoveredItem.removeAttribute('data-gridiot-handle-hover');\n\t\t\thoveredItem = null;\n\t\t\thoveredHandle = null;\n\t\t}\n\t};\n\n\tconst onKeyDown = (e: KeyboardEvent) => {\n\t\tif (e.key === 'Escape' && activeResize) {\n\t\t\tcancelResize();\n\t\t}\n\t};\n\n\t// Register event listeners\n\tgridElement.addEventListener('pointerdown', onPointerDown, { capture: true });\n\tgridElement.addEventListener('pointermove', onPointerMove);\n\tdocument.addEventListener('keydown', onKeyDown);\n\n\t// Public API\n\tfunction setSize(\n\t\titem: HTMLElement,\n\t\tsize: { colspan: number; rowspan: number },\n\t) {\n\t\tconst clampedColspan = Math.max(\n\t\t\tminSize.colspan,\n\t\t\tMath.min(maxSize.colspan, size.colspan),\n\t\t);\n\t\tconst clampedRowspan = Math.max(\n\t\t\tminSize.rowspan,\n\t\t\tMath.min(maxSize.rowspan, size.rowspan),\n\t\t);\n\n\t\tconst style = getComputedStyle(item);\n\t\tconst column = parseInt(style.gridColumnStart, 10) || 1;\n\t\tconst row = parseInt(style.gridRowStart, 10) || 1;\n\n\t\titem.setAttribute('data-gridiot-colspan', String(clampedColspan));\n\t\titem.setAttribute('data-gridiot-rowspan', String(clampedRowspan));\n\t\titem.style.gridColumn = `${column} / span ${clampedColspan}`;\n\t\titem.style.gridRow = `${row} / span ${clampedRowspan}`;\n\n\t\temit<ResizeEndDetail>('resize-end', {\n\t\t\titem,\n\t\t\tcell: { column, row },\n\t\t\tcolspan: clampedColspan,\n\t\t\trowspan: clampedRowspan,\n\t\t});\n\t}\n\n\tfunction destroy() {\n\t\tgridElement.removeEventListener('pointerdown', onPointerDown, {\n\t\t\tcapture: true,\n\t\t});\n\t\tgridElement.removeEventListener('pointermove', onPointerMove);\n\t\tdocument.removeEventListener('keydown', onKeyDown);\n\n\t\tif (activeResize) {\n\t\t\tcancelResize();\n\t\t}\n\t}\n\n\treturn { setSize, destroy };\n}\n\n// Register as a plugin for auto-initialization via init()\nregisterPlugin({\n\tname: 'resize',\n\tinit(core, options?: ResizePluginOptions & { core?: GridiotCore }) {\n\t\tconst instance = attachResize(core.element, {\n\t\t\t...options,\n\t\t\tcore: options?.core ?? core,\n\t\t});\n\t\treturn () => instance.destroy();\n\t},\n});\n\nexport type { ResizeHandle };\n"],
  "mappings": "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",
  "names": []
}
