{"version":3,"file":"resize.js","names":[],"sources":["../engine.ts","../plugins/resize.ts"],"sourcesContent":["import type { GridCell, EggCore, InitOptions, StyleManager } from './types';\nimport { createStateMachine } from './state-machine';\nimport { attachPointer } from './plugins/pointer';\nimport { attachKeyboard } from './plugins/keyboard';\nimport { attachAccessibility } from './plugins/accessibility';\nimport { attachResize } from './plugins/resize';\nimport { attachCamera } from './plugins/camera';\nimport { attachPlaceholder } from './plugins/placeholder';\nimport { attachPushAlgorithm } from './plugins/algorithm-push';\nimport { attachReorderAlgorithm } from './plugins/algorithm-reorder';\nimport { attachResponsive } from './plugins/responsive';\n\n/**\n * Initialize EG Grid on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): EggCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\t// Create centralized state machine\n\tconst stateMachine = createStateMachine();\n\n\t// Track selected element (state machine stores itemId, we need the element)\n\tlet selectedElement: HTMLElement | null = null;\n\n\t// StyleManager: single style element, multiple named layers\n\tconst styleLayers = new Map<string, string>(); // layer name → CSS\n\tconst layerOrder: string[] = []; // insertion order\n\tconst managedStyleElement = styleElement ?? document.createElement('style');\n\tif (!styleElement) {\n\t\tdocument.head.appendChild(managedStyleElement);\n\t\tcleanups.push(() => managedStyleElement.remove());\n\t}\n\n\t// Pre-populate 'base' layer with any existing content (e.g. server-rendered CSS)\n\tconst existingCSS = managedStyleElement.textContent?.trim();\n\tif (existingCSS) {\n\t\tstyleLayers.set('base', existingCSS);\n\t\tlayerOrder.push('base');\n\t}\n\n\tconst styles: StyleManager = {\n\t\tset(layer: string, css: string): void {\n\t\t\tif (!styleLayers.has(layer)) {\n\t\t\t\tlayerOrder.push(layer);\n\t\t\t}\n\t\t\tstyleLayers.set(layer, css);\n\t\t},\n\t\tget(layer: string): string {\n\t\t\treturn styleLayers.get(layer) ?? '';\n\t\t},\n\t\tclear(layer: string): void {\n\t\t\tif (styleLayers.has(layer)) {\n\t\t\t\tstyleLayers.set(layer, '');\n\t\t\t}\n\t\t},\n\t\tcommit(): void {\n\t\t\tconst parts: string[] = [];\n\t\t\tfor (const layer of layerOrder) {\n\t\t\t\tconst css = styleLayers.get(layer);\n\t\t\t\tif (css) parts.push(css);\n\t\t\t}\n\t\t\tmanagedStyleElement.textContent = parts.join('\\n\\n');\n\t\t},\n\t};\n\n\tconst core: EggCore = {\n\t\telement,\n\t\tstateMachine,\n\t\tstyles,\n\t\tcameraScrolling: false,\n\n\t\t// Selection state (backed by state machine)\n\t\tget selectedItem() {\n\t\t\treturn selectedElement;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedElement) return;\n\n\t\t\tconst previousItem = selectedElement;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-egg-selected');\n\t\t\t}\n\n\t\t\t// Update state machine and local element reference\n\t\t\tif (item) {\n\t\t\t\tconst itemId = item.id || item.getAttribute('data-egg-item') || '';\n\t\t\t\tstateMachine.transition({ type: 'SELECT', itemId, element: item });\n\t\t\t\tselectedElement = item;\n\t\t\t\titem.setAttribute('data-egg-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else {\n\t\t\t\tstateMachine.transition({ type: 'DESELECT' });\n\t\t\t\tselectedElement = null;\n\t\t\t\tif (previousItem) {\n\t\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`egg-${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Direct initialization — no registry, no loop\n\tif (options.pointer !== false) {\n\t\tcleanups.push(attachPointer(core));\n\t}\n\tif (options.keyboard !== false) {\n\t\tcleanups.push(attachKeyboard(core));\n\t}\n\tif (options.accessibility !== false) {\n\t\tcleanups.push(attachAccessibility(core));\n\t}\n\n\tif (options.resize !== false) {\n\t\tconst resizeOpts = typeof options.resize === 'object' ? options.resize : {};\n\t\tconst inst = attachResize(element, { ...resizeOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.camera !== false) {\n\t\tconst cameraOpts = typeof options.camera === 'object' ? options.camera : {};\n\t\tconst inst = attachCamera(element, { ...cameraOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.placeholder !== false) {\n\t\tconst placeholderOpts = typeof options.placeholder === 'object' ? options.placeholder : {};\n\t\tconst inst = attachPlaceholder(element, placeholderOpts);\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\t// Algorithm: push (default) or reorder\n\tif (options.algorithm !== false) {\n\t\tconst algoOpts = options.algorithmOptions ?? {};\n\t\tif (options.algorithm === 'reorder') {\n\t\t\tcleanups.push(attachReorderAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t} else {\n\t\t\tcleanups.push(attachPushAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t}\n\t}\n\n\tif (options.responsive) {\n\t\tcleanups.push(attachResponsive(element, options.responsive, core));\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Get the size of an item from its data attributes\n */\nexport function getItemSize(item: HTMLElement): { colspan: number; rowspan: number } {\n\treturn {\n\t\tcolspan: parseInt(item.getAttribute('data-egg-colspan') || '1', 10) || 1,\n\t\trowspan: parseInt(item.getAttribute('data-egg-rowspan') || '1', 10) || 1,\n\t};\n}\n\n/**\n * Attach multiple event listeners and return a cleanup function to remove them all\n */\nexport function listenEvents(\n\telement: EventTarget,\n\tevents: Record<string, EventListenerOrEventListenerObject>,\n): () => void {\n\tfor (const [name, handler] of Object.entries(events)) {\n\t\telement.addEventListener(name, handler);\n\t}\n\treturn () => {\n\t\tfor (const [name, handler] of Object.entries(events)) {\n\t\t\telement.removeEventListener(name, handler);\n\t\t}\n\t};\n}\n","/**\n * Resize plugin for EG Grid\n *\n * Pure input plugin — detects resize gestures on grid item corners/edges\n * and emits resize-start/move/end/cancel events. Does NOT persist layout.\n * A behavior plugin (e.g., Algorithm) listens for resize-end and handles persistence.\n *\n * Usage:\n *   import { attachResize } from 'eg-grid/resize';\n *\n *   const detach = attachResize(gridElement, {\n *     core,                 // EggCore instance (required)\n *     handles: 'corners',   // 'corners' | 'edges' | 'all'\n *     handleSize: 12,\n *     minSize: { colspan: 1, rowspan: 1 },\n *     maxSize: { colspan: 6, rowspan: 6 },\n *   });\n */\n\nimport { getItemSize } from '../engine';\nimport type {\n\tGridCell,\n\tEggCore,\n\tResizeCancelDetail,\n\tResizeEndDetail,\n\tResizeHandle,\n\tResizeMoveDetail,\n\tResizeStartDetail,\n} from '../types';\n\n\nexport interface ResizeOptions {\n\t/** EggCore instance (required) */\n\tcore: EggCore;\n\t/** Which handles to show: 'corners' | 'edges' | 'all' (default: 'corners') */\n\thandles?: 'corners' | 'edges' | 'all';\n\t/** Size of the hit zone for handles in pixels (default: 12) */\n\thandleSize?: number;\n\t/** Minimum size in grid cells (default: { colspan: 1, rowspan: 1 }) */\n\tminSize?: { colspan: number; rowspan: number };\n\t/** Maximum size in grid cells (default: { colspan: 6, rowspan: 6 }) */\n\tmaxSize?: { colspan: number; rowspan: number };\n\t/** Show size label during resize (default: true) */\n\tshowSizeLabel?: boolean;\n}\n\ninterface ActiveResize {\n\titem: HTMLElement;\n\tpointerId: number;\n\thandle: ResizeHandle;\n\t/** Original cell position at start of resize - never changes */\n\tstartCell: GridCell;\n\t/** Original size at start of resize - never changes */\n\toriginalSize: { colspan: number; rowspan: number };\n\t/** Current position (may differ from startCell for NW/NE/SW handles) */\n\tcurrentCell: GridCell;\n\t/** Current size during resize */\n\tcurrentSize: { colspan: number; rowspan: number };\n\tsizeLabel: HTMLElement | null;\n\t/** Initial bounding rect for smooth resize */\n\tinitialRect: DOMRect;\n\t/** Pointer position at start */\n\tstartPointerX: number;\n\tstartPointerY: number;\n}\n\n\n/**\n * Detect which resize handle (if any) is under the pointer\n */\nfunction detectHandle(\n\te: PointerEvent,\n\titem: HTMLElement,\n\tsize: number,\n\tmode: 'corners' | 'edges' | 'all',\n): ResizeHandle | null {\n\tconst rect = item.getBoundingClientRect();\n\tconst x = e.clientX - rect.left;\n\tconst y = e.clientY - rect.top;\n\n\tconst nearLeft = x < size;\n\tconst nearRight = x > rect.width - size;\n\tconst nearTop = y < size;\n\tconst nearBottom = y > rect.height - size;\n\n\t// Corners\n\tif (mode === 'corners' || mode === 'all') {\n\t\tif (nearTop && nearLeft) return 'nw';\n\t\tif (nearTop && nearRight) return 'ne';\n\t\tif (nearBottom && nearLeft) return 'sw';\n\t\tif (nearBottom && nearRight) return 'se';\n\t}\n\n\t// Edges (only if not at corners)\n\tif (mode === 'edges' || mode === 'all') {\n\t\tif (nearTop) return 'n';\n\t\tif (nearBottom) return 's';\n\t\tif (nearLeft) return 'w';\n\t\tif (nearRight) return 'e';\n\t}\n\n\treturn null;\n}\n\nconst CURSOR: Record<string, string> = {\n\tnw: 'nwse-resize', se: 'nwse-resize',\n\tne: 'nesw-resize', sw: 'nesw-resize',\n\tn: 'ns-resize', s: 'ns-resize',\n\te: 'ew-resize', w: 'ew-resize',\n};\n\n/**\n * Create a size label element\n */\nfunction createSizeLabel(): HTMLElement {\n\tconst label = document.createElement('div');\n\tlabel.className = 'egg-resize-label';\n\tlabel.style.cssText = `\n\t\tposition: absolute;\n\t\ttop: 50%;\n\t\tleft: 50%;\n\t\ttransform: translate(-50%, -50%);\n\t\tbackground: rgba(0, 0, 0, 0.8);\n\t\tcolor: white;\n\t\tpadding: 4px 8px;\n\t\tborder-radius: 4px;\n\t\tfont-size: 14px;\n\t\tfont-weight: 600;\n\t\tfont-family: system-ui, sans-serif;\n\t\tpointer-events: none;\n\t\tz-index: 1000;\n\t\twhite-space: nowrap;\n\t`;\n\treturn label;\n}\n\n/**\n * Attach resize functionality to a grid element.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach resize\n */\nexport function attachResize(\n\tgridElement: HTMLElement,\n\toptions: ResizeOptions,\n): { destroy(): void } {\n\tconst {\n\t\tcore,\n\t\thandles = 'corners',\n\t\thandleSize = 12,\n\t\tminSize = { colspan: 1, rowspan: 1 },\n\t\tmaxSize = { colspan: 6, rowspan: 6 },\n\t\tshowSizeLabel = true,\n\t} = options;\n\n\tlet activeResize: ActiveResize | null = null;\n\tlet hoveredItem: HTMLElement | null = null;\n\tlet hoveredHandle: ResizeHandle | null = null;\n\n\tfunction emit<T>(event: string, detail: T): void {\n\t\tgridElement.dispatchEvent(\n\t\t\tnew CustomEvent(`egg-${event}`, {\n\t\t\t\tbubbles: true,\n\t\t\t\tdetail,\n\t\t\t}),\n\t\t);\n\t}\n\n\tfunction startResize(item: HTMLElement, handle: ResizeHandle, e: PointerEvent) {\n\t\tconst { colspan, rowspan } = getItemSize(item);\n\n\t\tconst style = getComputedStyle(item);\n\t\tconst column = parseInt(style.gridColumnStart, 10) || 1;\n\t\tconst row = parseInt(style.gridRowStart, 10) || 1;\n\n\t\tconst originalSize = { colspan, rowspan };\n\t\tconst startCell = { column, row };\n\t\tconst initialRect = item.getBoundingClientRect();\n\n\t\t// Create size label if enabled\n\t\tlet sizeLabel: HTMLElement | null = null;\n\t\tif (showSizeLabel) {\n\t\t\tsizeLabel = createSizeLabel();\n\t\t\tsizeLabel.textContent = `${colspan}×${rowspan}`;\n\t\t\titem.appendChild(sizeLabel);\n\t\t}\n\n\t\tactiveResize = {\n\t\t\titem,\n\t\t\tpointerId: e.pointerId,\n\t\t\thandle,\n\t\t\tstartCell,\n\t\t\toriginalSize,\n\t\t\tcurrentCell: { ...startCell },\n\t\t\tcurrentSize: { ...originalSize },\n\t\t\tsizeLabel,\n\t\t\tinitialRect,\n\t\t\tstartPointerX: e.clientX,\n\t\t\tstartPointerY: e.clientY,\n\t\t};\n\n\t\titem.setAttribute('data-egg-resizing', '');\n\t\titem.setAttribute('data-egg-handle-active', handle);\n\t\titem.removeAttribute('data-egg-handle-hover'); // Clear hover state\n\t\titem.setPointerCapture(e.pointerId);\n\n\t\t// Add event listeners to item (pointer capture sends events to this element)\n\t\titem.addEventListener('pointermove', onItemPointerMove);\n\t\titem.addEventListener('pointerup', onItemPointerUp);\n\t\titem.addEventListener('pointercancel', onItemPointerCancel);\n\n\t\t// Transition state machine to interacting\n\t\tconst itemId = item.id || item.getAttribute('data-egg-item') || '';\n\t\tcore.stateMachine.transition({\n\t\t\ttype: 'START_INTERACTION',\n\t\t\tcontext: { type: 'resize', mode: 'pointer', itemId, element: item, columnCount: core.getGridInfo().columns.length },\n\t\t});\n\n\t\t// Emit resize-start BEFORE changing grid styles so originalPositions captures correct layout\n\t\temit<ResizeStartDetail>('resize-start', {\n\t\t\titem,\n\t\t\tcell: startCell,\n\t\t\tcolspan: originalSize.colspan,\n\t\t\trowspan: originalSize.rowspan,\n\t\t\thandle,\n\t\t\tsource: 'pointer',\n\t\t});\n\n\t\t// Switch to fixed positioning - item follows cursor in viewport coordinates\n\t\t// CSS Grid ignores fixed positioned children, allowing the grid to reflow\n\t\titem.style.position = 'fixed';\n\t\titem.style.left = `${initialRect.left}px`;\n\t\titem.style.top = `${initialRect.top}px`;\n\t\titem.style.width = `${initialRect.width}px`;\n\t\titem.style.height = `${initialRect.height}px`;\n\t\titem.style.zIndex = '100';\n\t\t// Exclude from view transitions during resize\n\t\titem.style.viewTransitionName = 'resizing';\n\t}\n\n\tfunction updateResize(e: PointerEvent) {\n\t\tif (!activeResize) return;\n\n\t\tconst { item, handle, startCell, originalSize, currentCell, currentSize, sizeLabel, initialRect, startPointerX, startPointerY } =\n\t\t\tactiveResize;\n\n\t\tconst gridInfo = core.getGridInfo();\n\n\t\t// Calculate pointer delta\n\t\tconst deltaX = e.clientX - startPointerX;\n\t\tconst deltaY = e.clientY - startPointerY;\n\n\t\t// Calculate new visual dimensions based on handle\n\t\tlet newWidth = initialRect.width;\n\t\tlet newHeight = initialRect.height;\n\t\tlet newLeft = initialRect.left;\n\t\tlet newTop = initialRect.top;\n\n\t\t// Minimum visual size (1 cell)\n\t\tconst minWidth = gridInfo.cellWidth;\n\t\tconst minHeight = gridInfo.cellHeight;\n\t\t// Maximum visual size (clamped by maxSize config)\n\t\tconst maxWidthByConfig = maxSize.colspan * gridInfo.cellWidth + (maxSize.colspan - 1) * gridInfo.gap;\n\t\tconst maxHeightByConfig = maxSize.rowspan * gridInfo.cellHeight + (maxSize.rowspan - 1) * gridInfo.gap;\n\t\t// Maximum visual size (clamped by grid bounds)\n\t\tconst maxWidthByGrid = gridInfo.rect.right - initialRect.left;\n\t\tconst maxHeightByGrid = gridInfo.rect.bottom - initialRect.top;\n\t\tconst maxWidth = Math.min(maxWidthByConfig, maxWidthByGrid);\n\t\tconst maxHeight = Math.min(maxHeightByConfig, maxHeightByGrid);\n\n\t\t// Apply delta based on handle direction\n\t\tif (handle === 'e' || handle === 'se' || handle === 'ne') {\n\t\t\tnewWidth = Math.max(minWidth, Math.min(maxWidth, initialRect.width + deltaX));\n\t\t}\n\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t\t// For left edge, clamp to grid left\n\t\t\tconst maxLeftShift = initialRect.left - gridInfo.rect.left;\n\t\t\tconst maxWidthFromLeft = Math.min(maxWidthByConfig, initialRect.width + maxLeftShift);\n\t\t\tconst widthChange = Math.max(-initialRect.width + minWidth, Math.min(maxWidthFromLeft - initialRect.width, -deltaX));\n\t\t\tnewWidth = initialRect.width + widthChange;\n\t\t\tnewLeft = initialRect.left - widthChange;\n\t\t}\n\t\tif (handle === 's' || handle === 'se' || handle === 'sw') {\n\t\t\tnewHeight = Math.max(minHeight, Math.min(maxHeight, initialRect.height + deltaY));\n\t\t}\n\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t\t// For top edge, clamp to grid top\n\t\t\tconst maxTopShift = initialRect.top - gridInfo.rect.top;\n\t\t\tconst maxHeightFromTop = Math.min(maxHeightByConfig, initialRect.height + maxTopShift);\n\t\t\tconst heightChange = Math.max(-initialRect.height + minHeight, Math.min(maxHeightFromTop - initialRect.height, -deltaY));\n\t\t\tnewHeight = initialRect.height + heightChange;\n\t\t\tnewTop = initialRect.top - heightChange;\n\t\t}\n\n\t\t// Apply smooth visual size (fixed positioning uses viewport coordinates)\n\t\titem.style.left = `${newLeft}px`;\n\t\titem.style.top = `${newTop}px`;\n\t\titem.style.width = `${newWidth}px`;\n\t\titem.style.height = `${newHeight}px`;\n\n\t\t// Calculate projected final grid size (what it will snap to)\n\t\tconst cellPlusGap = gridInfo.cellWidth + gridInfo.gap;\n\t\tconst rowPlusGap = gridInfo.cellHeight + gridInfo.gap;\n\n\t\t// Calculate raw ratios\n\t\tconst rawColspanRatio = (newWidth + gridInfo.gap) / cellPlusGap;\n\t\tconst rawRowspanRatio = (newHeight + gridInfo.gap) / rowPlusGap;\n\n\t\t// Snap when 30% into the next cell (works symmetrically for grow and shrink)\n\t\tconst RESIZE_SNAP = 0.3;\n\t\tlet projectedColspan = Math.floor(rawColspanRatio + (1 - RESIZE_SNAP));\n\t\tlet projectedRowspan = Math.floor(rawRowspanRatio + (1 - RESIZE_SNAP));\n\n\t\t// Apply min/max constraints\n\t\tprojectedColspan = Math.max(minSize.colspan, Math.min(maxSize.colspan, projectedColspan));\n\t\tprojectedRowspan = Math.max(minSize.rowspan, Math.min(maxSize.rowspan, projectedRowspan));\n\n\t\t// Calculate cell position: anchor corner stays fixed, opposite edge moves\n\t\tlet projectedColumn = startCell.column;\n\t\tlet projectedRow = startCell.row;\n\n\t\t// For handles that move the left edge, calculate column from the right anchor\n\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t\tconst rightEdge = startCell.column + originalSize.colspan - 1;\n\t\t\tprojectedColumn = rightEdge - projectedColspan + 1;\n\t\t}\n\n\t\t// For handles that move the top edge, calculate row from the bottom anchor\n\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t\tconst bottomEdge = startCell.row + originalSize.rowspan - 1;\n\t\t\tprojectedRow = bottomEdge - projectedRowspan + 1;\n\t\t}\n\n\t\t// Update tracking\n\t\tactiveResize.currentSize = { colspan: projectedColspan, rowspan: projectedRowspan };\n\t\tactiveResize.currentCell = { column: projectedColumn, row: projectedRow };\n\n\t\t// Update size label with projected final size\n\t\tif (sizeLabel) {\n\t\t\tsizeLabel.textContent = `${projectedColspan}×${projectedRowspan}`;\n\t\t}\n\n\t\t// Calculate anchor cell (the corner that stays fixed during resize)\n\t\tlet anchorCell: GridCell;\n\t\tif (handle === 'se' || handle === 's' || handle === 'e') {\n\t\t\t// NW corner is anchor\n\t\t\tanchorCell = { column: startCell.column, row: startCell.row };\n\t\t} else if (handle === 'nw' || handle === 'n' || handle === 'w') {\n\t\t\t// SE corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column + originalSize.colspan - 1,\n\t\t\t\trow: startCell.row + originalSize.rowspan - 1,\n\t\t\t};\n\t\t} else if (handle === 'ne') {\n\t\t\t// SW corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column,\n\t\t\t\trow: startCell.row + originalSize.rowspan - 1,\n\t\t\t};\n\t\t} else {\n\t\t\t// SW handle: NE corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column + originalSize.colspan - 1,\n\t\t\t\trow: startCell.row,\n\t\t\t};\n\t\t}\n\n\t\temit<ResizeMoveDetail>('resize-move', {\n\t\t\titem,\n\t\t\tcell: { column: projectedColumn, row: projectedRow },\n\t\t\tanchorCell,\n\t\t\tstartCell,\n\t\t\tcolspan: projectedColspan,\n\t\t\trowspan: projectedRowspan,\n\t\t\thandle,\n\t\t\tsource: 'pointer',\n\t\t});\n\t}\n\n\tfunction cleanupResizeListeners(item: HTMLElement, pointerId: number) {\n\t\titem.releasePointerCapture(pointerId);\n\t\titem.removeEventListener('pointermove', onItemPointerMove);\n\t\titem.removeEventListener('pointerup', onItemPointerUp);\n\t\titem.removeEventListener('pointercancel', onItemPointerCancel);\n\t}\n\n\tfunction resetItem(item: HTMLElement, pointerId: number, sizeLabel: HTMLElement | null) {\n\t\tcleanupResizeListeners(item, pointerId);\n\t\tif (sizeLabel) sizeLabel.remove();\n\t\titem.style.position = '';\n\t\titem.style.left = '';\n\t\titem.style.top = '';\n\t\titem.style.width = '';\n\t\titem.style.height = '';\n\t\titem.style.zIndex = '';\n\t\tconst itemId = item.style.getPropertyValue('--item-id') || item.dataset.eggItem || item.id || item.dataset.id;\n\t\titem.style.viewTransitionName = itemId || '';\n\t\titem.removeAttribute('data-egg-resizing');\n\t\titem.removeAttribute('data-egg-handle-active');\n\t}\n\n\tfunction finishResize() {\n\t\tif (!activeResize) return;\n\t\tconst { item, pointerId, currentSize, currentCell, sizeLabel } = activeResize;\n\t\titem.setAttribute('data-egg-colspan', String(currentSize.colspan));\n\t\titem.setAttribute('data-egg-rowspan', String(currentSize.rowspan));\n\t\tcore.stateMachine.transition({ type: 'COMMIT_INTERACTION' });\n\t\temit<ResizeEndDetail>('resize-end', {\n\t\t\titem, cell: currentCell,\n\t\t\tcolspan: currentSize.colspan, rowspan: currentSize.rowspan,\n\t\t\tsource: 'pointer',\n\t\t});\n\t\tresetItem(item, pointerId, sizeLabel);\n\t\tactiveResize = null;\n\t\tcore.stateMachine.transition({ type: 'FINISH_COMMIT' });\n\t}\n\n\tfunction cancelResize() {\n\t\tif (!activeResize) return;\n\t\tconst { item, pointerId, sizeLabel } = activeResize;\n\t\temit<ResizeCancelDetail>('resize-cancel', { item, source: 'pointer' });\n\t\tcore.stateMachine.transition({ type: 'CANCEL_INTERACTION' });\n\t\tresetItem(item, pointerId, sizeLabel);\n\t\tactiveResize = null;\n\t}\n\n\t// --- Event handlers ---\n\n\t// Use capture phase to intercept before pointer plugin\n\tconst onPointerDown = (e: PointerEvent) => {\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-egg-item]',\n\t\t) as HTMLElement | null;\n\t\tif (!item) return;\n\n\t\tconst handle = detectHandle(e, item, handleSize, handles);\n\t\tif (!handle) return; // Not on handle - let pointer plugin handle drag\n\n\t\t// Stop event from reaching pointer plugin\n\t\te.stopPropagation();\n\t\te.preventDefault();\n\n\t\t// Select the item (resize captures before pointer plugin, so pointer's select never fires)\n\t\tcore.select(item);\n\n\t\tstartResize(item, handle, e);\n\t};\n\n\t// Item-specific handlers (added during resize, removed on finish/cancel)\n\tconst onItemPointerMove = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tupdateResize(e);\n\t\t}\n\t};\n\n\tconst onItemPointerUp = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tfinishResize();\n\t\t}\n\t};\n\n\tconst onItemPointerCancel = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tcancelResize();\n\t\t}\n\t};\n\n\t// Grid-level hover handler for cursor changes and handle hover state\n\tconst onPointerMove = (e: PointerEvent) => {\n\t\t// Skip hover handling during active resize\n\t\tif (activeResize) return;\n\n\t\t// Handle hover cursor changes\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-egg-item]',\n\t\t) as HTMLElement | null;\n\n\t\tif (item) {\n\t\t\tconst handle = detectHandle(e, item, handleSize, handles);\n\n\t\t\tif (handle !== hoveredHandle || item !== hoveredItem) {\n\t\t\t\t// Clear previous item's hover state\n\t\t\t\tif (hoveredItem && hoveredItem !== item) {\n\t\t\t\t\thoveredItem.style.cursor = '';\n\t\t\t\t\thoveredItem.removeAttribute('data-egg-handle-hover');\n\t\t\t\t}\n\n\t\t\t\t// Clear hover attribute if handle changed on same item\n\t\t\t\tif (hoveredItem === item && hoveredHandle && !handle) {\n\t\t\t\t\titem.removeAttribute('data-egg-handle-hover');\n\t\t\t\t}\n\n\t\t\t\thoveredItem = item;\n\t\t\t\thoveredHandle = handle;\n\n\t\t\t\t// Set cursor and hover attribute based on handle\n\t\t\t\titem.style.cursor = (handle ? CURSOR[handle] : '') || '';\n\t\t\t\tif (handle) {\n\t\t\t\t\titem.setAttribute('data-egg-handle-hover', handle);\n\t\t\t\t} else {\n\t\t\t\t\titem.removeAttribute('data-egg-handle-hover');\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (hoveredItem) {\n\t\t\thoveredItem.style.cursor = '';\n\t\t\thoveredItem.removeAttribute('data-egg-handle-hover');\n\t\t\thoveredItem = null;\n\t\t\thoveredHandle = null;\n\t\t}\n\t};\n\n\tconst onKeyDown = (e: KeyboardEvent) => {\n\t\tif (e.key === 'Escape' && activeResize) {\n\t\t\tcancelResize();\n\t\t}\n\t};\n\n\t// Register event listeners\n\tgridElement.addEventListener('pointerdown', onPointerDown, { capture: true });\n\tgridElement.addEventListener('pointermove', onPointerMove);\n\tdocument.addEventListener('keydown', onKeyDown);\n\n\tfunction destroy() {\n\t\tgridElement.removeEventListener('pointerdown', onPointerDown, {\n\t\t\tcapture: true,\n\t\t});\n\t\tgridElement.removeEventListener('pointermove', onPointerMove);\n\t\tdocument.removeEventListener('keydown', onKeyDown);\n\n\t\tif (activeResize) {\n\t\t\tcancelResize();\n\t\t}\n\t}\n\n\treturn { destroy };\n}\n\nexport type { ResizeHandle };\n"],"mappings":"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"}