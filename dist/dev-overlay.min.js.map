{"version":3,"file":"dev-overlay.min.js","names":[],"sources":["../src/eg-grid.ts","../src/plugins/dev-overlay.ts"],"sourcesContent":["// EG Grid — zero-dependency CSS Grid drag-and-drop\n// Copy this file into your project and tweak as needed.\n// Optionally import { createLayoutModel } from './layout-model' for responsive breakpoint support.\n\n// ── Types ──────────────────────────────────────────────────────────────────────\n\ntype GridCell = { column: number; row: number }\ntype ItemRect = { id: string; column: number; row: number; width: number; height: number }\ntype ResizeHandle = 'nw' | 'ne' | 'sw' | 'se' | 'n' | 's' | 'e' | 'w'\n\ninterface EggCore {\n\telement: HTMLElement\n\tphase: 'idle' | 'selected' | 'interacting'\n\tinteraction: { type: 'drag' | 'resize'; mode: 'pointer' | 'keyboard'; itemId: string; element: HTMLElement; columnCount: number } | null\n\tselectedItem: HTMLElement | null\n\tcameraScrolling: boolean\n\tselect(item: HTMLElement | null): void\n\tdeselect(): void\n\tgetCellFromPoint(x: number, y: number): GridCell | null\n\tgetGridInfo(): { rect: DOMRect; columns: number[]; rows: number[]; gap: number; cellWidth: number; cellHeight: number }\n\temit(event: string, detail: any): void\n\tcommitStyles(): void\n\tbaseCSS: string\n\tpreviewCSS: string\n\tdestroy(): void\n}\n\ninterface InitOptions {\n\talgorithm?: 'push' | 'reorder' | false\n\tcompaction?: boolean\n\tresize?: { handles?: 'corners' | 'edges' | 'all'; handleSize?: number; minSize?: { colspan: number; rowspan: number }; maxSize?: { colspan: number; rowspan: number }; showSizeLabel?: boolean } | false\n\tcamera?: { edgeSize?: number; scrollSpeed?: number; scrollMargin?: number; settleDelay?: number } | false\n\tplaceholder?: { className?: string } | false\n\taccessibility?: false\n\tpointer?: false\n\tkeyboard?: false\n\tresponsive?: { layoutModel: ResponsiveLayoutModel; cellSize?: number; gap?: number }\n\tlayoutModel?: ResponsiveLayoutModel\n\tstyleElement?: HTMLStyleElement\n}\n\n// The responsive layout model interface — see layout-model.ts for implementation\ninterface ResponsiveLayoutModel {\n\treadonly maxColumns: number\n\treadonly currentColumnCount: number\n\tgetLayoutForColumns(columnCount: number): Map<string, { column: number; row: number }>\n\tsaveLayout(columnCount: number, positions: Map<string, { column: number; row: number }>): void\n\tupdateItemSize(itemId: string, size: { width: number; height: number }): void\n\tsetCurrentColumnCount(columnCount: number): void\n\tgenerateAllBreakpointCSS(options: { cellSize: number; gap: number; gridSelector?: string }): string\n\tsubscribe(callback: () => void): () => void\n}\n\n// ── Grid Measurement ───────────────────────────────────────────────────────────\n\nfunction parseGridTemplate(template: string): number[] {\n\treturn template.split(' ').filter(Boolean).map(v => parseFloat(v) || 0)\n}\n\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet acc = 0\n\tconst halfGap = gap / 2\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tif (pos <= acc + tracks[i]! + halfGap) return i + 1\n\t\tacc += tracks[i]! + gap\n\t}\n\treturn tracks.length || 1\n}\n\nfunction getItemCell(item: HTMLElement): GridCell {\n\tconst s = getComputedStyle(item)\n\treturn { column: parseInt(s.gridColumnStart, 10) || 1, row: parseInt(s.gridRowStart, 10) || 1 }\n}\n\nfunction getItemSize(item: HTMLElement): { colspan: number; rowspan: number } {\n\treturn {\n\t\tcolspan: parseInt(item.getAttribute('data-egg-colspan') || '1', 10) || 1,\n\t\trowspan: parseInt(item.getAttribute('data-egg-rowspan') || '1', 10) || 1,\n\t}\n}\n\nfunction getItemId(el: HTMLElement): string {\n\treturn el.dataset.eggItem || el.dataset.id || el.id || ''\n}\n\n// ── Layout Algorithms ──────────────────────────────────────────────────────────\n\n// Shared\n\nfunction layoutToCSS(items: ItemRect[], opts: { selectorPrefix?: string; selectorSuffix?: string; excludeId?: string; maxColumns?: number } = {}): string {\n\tconst { selectorPrefix = '[data-egg-item=\"', selectorSuffix = '\"]', excludeId, maxColumns } = opts\n\tconst rules: string[] = []\n\tfor (const item of items) {\n\t\tif (item.id === excludeId) continue\n\t\tconst w = maxColumns ? Math.min(item.width, maxColumns) : item.width\n\t\tconst c = maxColumns ? Math.max(1, Math.min(item.column, maxColumns - w + 1)) : item.column\n\t\trules.push(`${selectorPrefix}${item.id}${selectorSuffix} { grid-column: ${c} / span ${w}; grid-row: ${item.row} / span ${item.height}; }`)\n\t}\n\treturn rules.join('\\n')\n}\n\nfunction readItemsFromDOM(container: HTMLElement): ItemRect[] {\n\treturn Array.from(container.querySelectorAll('[data-egg-item]')).map(el => {\n\t\tconst element = el as HTMLElement\n\t\tconst style = getComputedStyle(element)\n\t\treturn {\n\t\t\tid: getItemId(element),\n\t\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t\t\twidth: parseInt(element.getAttribute('data-egg-colspan') || '1', 10) || 1,\n\t\t\theight: parseInt(element.getAttribute('data-egg-rowspan') || '1', 10) || 1,\n\t\t}\n\t})\n}\n\n// Push algorithm\n\nfunction itemsOverlap(a: ItemRect, b: ItemRect): boolean {\n\treturn !(a.column + a.width <= b.column || b.column + b.width <= a.column || a.row + a.height <= b.row || b.row + b.height <= a.row)\n}\n\nfunction pushDown(items: ItemRect[], moved: ItemRect, movedId: string, depth = 0): void {\n\tif (depth > 50) return\n\tconst colliders = items\n\t\t.filter(it => it.id !== movedId && it.id !== moved.id && itemsOverlap(moved, it))\n\t\t.sort((a, b) => b.row - a.row || a.column - b.column)\n\tfor (const c of colliders) {\n\t\tconst newRow = moved.row + moved.height\n\t\tif (c.row < newRow) {\n\t\t\tc.row = newRow\n\t\t\tpushDown(items, c, movedId, depth + 1)\n\t\t}\n\t}\n}\n\nfunction compactUp(items: ItemRect[], excludeId: string): void {\n\tconst sorted = [...items].filter(it => it.id !== excludeId).sort((a, b) => a.row - b.row || a.column - b.column)\n\tfor (const item of sorted) {\n\t\tlet iter = 0\n\t\twhile (item.row > 1 && iter++ < 100) {\n\t\t\titem.row -= 1\n\t\t\tif (items.some(o => o.id !== item.id && itemsOverlap(item, o))) { item.row += 1; break }\n\t\t}\n\t}\n}\n\nfunction calculatePushLayout(items: ItemRect[], movedId: string, targetCell: GridCell, compact = true): ItemRect[] {\n\tconst result = items.map(i => ({ ...i }))\n\tconst moved = result.find(i => i.id === movedId)\n\tif (!moved) return result\n\tmoved.column = targetCell.column\n\tmoved.row = targetCell.row\n\tpushDown(result, moved, movedId)\n\tif (compact) compactUp(result, movedId)\n\treturn result\n}\n\n// Reorder algorithm\n\nfunction reflowItems(items: ItemRect[], columns: number): ItemRect[] {\n\tconst occupied = new Set<string>()\n\tconst result: ItemRect[] = []\n\tfor (const item of items) {\n\t\tconst w = Math.min(item.width, columns)\n\t\tlet placed = false\n\t\tfor (let row = 1; !placed; row++) {\n\t\t\tfor (let col = 1; col <= columns; col++) {\n\t\t\t\tlet fits = col + w - 1 <= columns\n\t\t\t\tif (fits) {\n\t\t\t\t\tfor (let r = row; r < row + item.height && fits; r++)\n\t\t\t\t\t\tfor (let c = col; c < col + w && fits; c++)\n\t\t\t\t\t\t\tif (occupied.has(`${c},${r}`)) fits = false\n\t\t\t\t}\n\t\t\t\tif (fits) {\n\t\t\t\t\tfor (let r = row; r < row + item.height; r++)\n\t\t\t\t\t\tfor (let c = col; c < col + w; c++)\n\t\t\t\t\t\t\toccupied.add(`${c},${r}`)\n\t\t\t\t\tresult.push({ ...item, column: col, row, width: w })\n\t\t\t\t\tplaced = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (row > 100) { result.push({ ...item, column: 1, row, width: w }); placed = true }\n\t\t}\n\t}\n\treturn result\n}\n\nfunction calculateReorderLayout(items: ItemRect[], movedId: string, targetCell: GridCell, columns: number): ItemRect[] {\n\tconst all = items.map(i => ({ ...i }))\n\tconst ordered = [...all].sort((a, b) => a.row - b.row || a.column - b.column)\n\tconst moved = ordered.find(i => i.id === movedId)\n\tif (!moved) return reflowItems(ordered, columns)\n\tconst remaining = ordered.filter(i => i.id !== movedId)\n\tconst reflowed = reflowItems(remaining, columns)\n\tlet insertIdx = reflowed.length\n\tfor (let i = 0; i < reflowed.length; i++) {\n\t\tconst r = reflowed[i]\n\t\tif (r.row > targetCell.row || (r.row === targetCell.row && r.column >= targetCell.column)) { insertIdx = i; break }\n\t}\n\treturn reflowItems([...remaining.slice(0, insertIdx), moved, ...remaining.slice(insertIdx)], columns)\n}\n\n// ── init() ─────────────────────────────────────────────────────────────────────\n\nexport function init(element: HTMLElement, options: InitOptions = {}): EggCore {\n\tconst cleanups: (() => void)[] = []\n\tconst styleEl = options.styleElement ?? document.createElement('style')\n\tif (!options.styleElement) { document.head.appendChild(styleEl); cleanups.push(() => styleEl.remove()) }\n\n\tconst existingCSS = styleEl.textContent?.trim() || ''\n\tlet selectedElement: HTMLElement | null = null\n\n\tconst core: EggCore = {\n\t\telement,\n\t\tphase: 'idle',\n\t\tinteraction: null,\n\t\tcameraScrolling: false,\n\t\tbaseCSS: existingCSS,\n\t\tpreviewCSS: '',\n\n\t\tget selectedItem() { return selectedElement },\n\t\tset selectedItem(item) { this.select(item) },\n\n\t\tselect(item) {\n\t\t\tif (item === selectedElement) return\n\t\t\tconst prev = selectedElement\n\t\t\tif (prev) prev.removeAttribute('data-egg-selected')\n\t\t\tif (item) {\n\t\t\t\tthis.phase = this.phase === 'idle' ? 'selected' : this.phase\n\t\t\t\tselectedElement = item\n\t\t\t\titem.setAttribute('data-egg-selected', '')\n\t\t\t\tthis.emit('select', { item })\n\t\t\t} else {\n\t\t\t\tif (this.phase === 'selected') this.phase = 'idle'\n\t\t\t\tselectedElement = null\n\t\t\t\tif (prev) this.emit('deselect', { item: prev })\n\t\t\t}\n\t\t},\n\n\t\tdeselect() { this.select(null) },\n\n\t\tgetCellFromPoint(x, y) {\n\t\t\tconst rect = element.getBoundingClientRect()\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) return null\n\t\t\tconst s = getComputedStyle(element)\n\t\t\tconst cols = parseGridTemplate(s.gridTemplateColumns)\n\t\t\tconst rows = parseGridTemplate(s.gridTemplateRows)\n\t\t\tconst cGap = parseFloat(s.columnGap) || 0\n\t\t\tconst rGap = parseFloat(s.rowGap) || 0\n\t\t\treturn {\n\t\t\t\tcolumn: getGridIndex(x - rect.left + element.scrollLeft, cols, cGap),\n\t\t\t\trow: getGridIndex(y - rect.top + element.scrollTop, rows, rGap),\n\t\t\t}\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect()\n\t\t\tconst s = getComputedStyle(element)\n\t\t\tconst columns = parseGridTemplate(s.gridTemplateColumns)\n\t\t\tconst rows = parseGridTemplate(s.gridTemplateRows)\n\t\t\tconst gap = parseFloat(s.columnGap) || 0\n\t\t\treturn { rect, columns, rows, gap, cellWidth: columns[0] || 0, cellHeight: rows[0] || 0 }\n\t\t},\n\n\t\temit(event, detail) {\n\t\t\telement.dispatchEvent(new CustomEvent(`egg-${event}`, { bubbles: true, detail }))\n\t\t},\n\n\t\tcommitStyles() {\n\t\t\tstyleEl.textContent = [this.baseCSS, this.previewCSS].filter(Boolean).join('\\n\\n')\n\t\t},\n\n\t\tdestroy() { cleanups.forEach(fn => fn()) },\n\t}\n\n\t// ── Pointer ────────────────────────────────────────────────────────────────\n\n\tif (options.pointer !== false) {\n\t\tconst DRAG_THRESHOLD = 5\n\t\tconst PREDICTION_THRESHOLD = 30\n\t\tconst PREDICTION_LEAD = 0.5\n\t\tconst HYSTERESIS = 0.4\n\t\tconst TARGET_DEBOUNCE = 40\n\n\t\tlet pending: { item: HTMLElement; pointerId: number; startX: number; startY: number; rect: DOMRect; startCell: GridCell; colspan: number; rowspan: number } | null = null\n\t\tlet drag: { item: HTMLElement; pointerId: number; offsetX: number; offsetY: number; initialRect: DOMRect; startCell: GridCell; lastCell: GridCell; lastChangeTime: number; colspan: number; rowspan: number; dragStartX: number; dragStartY: number } | null = null\n\n\t\tfunction startDrag(p: NonNullable<typeof pending>, e: PointerEvent) {\n\t\t\tconst { item, pointerId, rect, startCell, colspan, rowspan } = p\n\t\t\tdrag = {\n\t\t\t\titem, pointerId, offsetX: e.clientX - rect.left, offsetY: e.clientY - rect.top,\n\t\t\t\tinitialRect: rect, startCell, lastCell: startCell, lastChangeTime: 0, colspan, rowspan,\n\t\t\t\tdragStartX: e.clientX, dragStartY: e.clientY,\n\t\t\t}\n\t\t\titem.setAttribute('data-egg-dragging', '')\n\t\t\tdocument.body.classList.add('is-dragging')\n\t\t\tconst itemId = getItemId(item)\n\t\t\tcore.phase = 'interacting'\n\t\t\tcore.interaction = { type: 'drag', mode: 'pointer', itemId, element: item, columnCount: core.getGridInfo().columns.length }\n\t\t\tcore.emit('drag-start', { item, cell: startCell, colspan, rowspan, source: 'pointer' })\n\t\t\titem.style.position = 'fixed'\n\t\t\titem.style.left = `${rect.left}px`\n\t\t\titem.style.top = `${rect.top}px`\n\t\t\titem.style.width = `${rect.width}px`\n\t\t\titem.style.height = `${rect.height}px`\n\t\t\titem.style.zIndex = '100'\n\t\t\tpending = null\n\t\t}\n\n\t\tconst onPointerMove = (e: PointerEvent) => {\n\t\t\tif (pending && !drag) {\n\t\t\t\tconst dx = e.clientX - pending.startX, dy = e.clientY - pending.startY\n\t\t\t\tif (Math.sqrt(dx * dx + dy * dy) >= DRAG_THRESHOLD) startDrag(pending, e)\n\t\t\t\telse return\n\t\t\t}\n\t\t\tif (!drag) return\n\t\t\tconst { item, offsetX, offsetY, initialRect, colspan, rowspan } = drag\n\t\t\tconst newLeft = e.clientX - offsetX, newTop = e.clientY - offsetY\n\t\t\titem.style.left = `${newLeft}px`\n\t\t\titem.style.top = `${newTop}px`\n\n\t\t\tlet cx = newLeft + initialRect.width / 2, cy = newTop + initialRect.height / 2\n\t\t\tconst gi = core.getGridInfo()\n\t\t\tconst cdx = e.clientX - drag.dragStartX, cdy = e.clientY - drag.dragStartY\n\t\t\tif (Math.abs(cdx) > PREDICTION_THRESHOLD) cx += Math.sign(cdx) * PREDICTION_LEAD * (gi.cellWidth + gi.gap)\n\t\t\tif (Math.abs(cdy) > PREDICTION_THRESHOLD) cy += Math.sign(cdy) * PREDICTION_LEAD * (gi.cellHeight + gi.gap)\n\n\t\t\tconst rawCell = core.getCellFromPoint(cx, cy)\n\t\t\tif (!rawCell) return\n\t\t\tconst maxCol = Math.max(1, gi.columns.length - colspan + 1)\n\t\t\tconst maxRow = Math.max(1, gi.rows.length - rowspan + 1)\n\t\t\tconst cell = { column: Math.max(1, Math.min(maxCol, rawCell.column)), row: Math.max(1, Math.min(maxRow, rawCell.row)) }\n\n\t\t\tconst now = performance.now()\n\t\t\tif (now - drag.lastChangeTime < TARGET_DEBOUNCE) return\n\t\t\tif (cell.column === drag.lastCell.column && cell.row === drag.lastCell.row) return\n\n\t\t\t// Hysteresis\n\t\t\tconst cellW = gi.cellWidth + gi.gap, cellH = gi.cellHeight + gi.gap\n\t\t\tconst ccx = gi.rect.left + (drag.lastCell.column - 1) * cellW + gi.cellWidth / 2\n\t\t\tconst ccy = gi.rect.top + (drag.lastCell.row - 1) * cellH + gi.cellHeight / 2\n\t\t\tconst offX = (cx - ccx) / cellW, offY = (cy - ccy) / cellH\n\t\t\tconst alignedX = (cell.column > drag.lastCell.column) === (offX > 0)\n\t\t\tconst alignedY = (cell.row > drag.lastCell.row) === (offY > 0)\n\t\t\tif (Math.abs(offX) < (alignedX ? 0.5 : 0.5 + HYSTERESIS) && Math.abs(offY) < (alignedY ? 0.5 : 0.5 + HYSTERESIS)) return\n\n\t\t\tdrag.lastCell = cell\n\t\t\tdrag.lastChangeTime = now\n\t\t\tcore.emit('drag-move', { item, cell, x: e.clientX, y: e.clientY, colspan, rowspan, source: 'pointer' })\n\t\t}\n\n\t\tconst cleanupDrag = () => {\n\t\t\tif (drag) {\n\t\t\t\tconst { item, pointerId } = drag\n\t\t\t\titem.removeAttribute('data-egg-dragging')\n\t\t\t\tdocument.body.classList.remove('is-dragging')\n\t\t\t\titem.style.position = ''; item.style.left = ''; item.style.top = ''\n\t\t\t\titem.style.width = ''; item.style.height = ''; item.style.zIndex = ''\n\t\t\t\titem.releasePointerCapture(pointerId)\n\t\t\t\titem.removeEventListener('pointermove', onPointerMove)\n\t\t\t\titem.removeEventListener('pointerup', onPointerUp)\n\t\t\t\titem.removeEventListener('pointercancel', onPointerCancel)\n\t\t\t\tdrag = null\n\t\t\t}\n\t\t\tif (pending) {\n\t\t\t\tpending.item.releasePointerCapture(pending.pointerId)\n\t\t\t\tpending.item.removeEventListener('pointermove', onPointerMove)\n\t\t\t\tpending.item.removeEventListener('pointerup', onPointerUp)\n\t\t\t\tpending.item.removeEventListener('pointercancel', onPointerCancel)\n\t\t\t\tpending = null\n\t\t\t}\n\t\t}\n\n\t\tconst onPointerUp = (e: PointerEvent) => {\n\t\t\tif (pending && !drag) { cleanupDrag(); return }\n\t\t\tif (!drag) return\n\n\t\t\tconst { item, initialRect, colspan, rowspan, lastCell, offsetX, offsetY, dragStartX, dragStartY } = drag\n\t\t\tconst gi = core.getGridInfo()\n\t\t\tconst cdx = e.clientX - dragStartX, cdy = e.clientY - dragStartY\n\t\t\tconst nL = e.clientX - offsetX, nT = e.clientY - offsetY\n\t\t\tlet ecx = nL + initialRect.width / 2, ecy = nT + initialRect.height / 2\n\t\t\tif (Math.abs(cdx) > PREDICTION_THRESHOLD) ecx += Math.sign(cdx) * PREDICTION_LEAD * (gi.cellWidth + gi.gap)\n\t\t\tif (Math.abs(cdy) > PREDICTION_THRESHOLD) ecy += Math.sign(cdy) * PREDICTION_LEAD * (gi.cellHeight + gi.gap)\n\n\t\t\tconst rawCell = core.getCellFromPoint(ecx, ecy)\n\t\t\tconst firstRect = item.getBoundingClientRect()\n\n\t\t\tlet dropCell = lastCell\n\t\t\tif (rawCell) {\n\t\t\t\tconst maxCol = Math.max(1, gi.columns.length - colspan + 1)\n\t\t\t\tconst maxRow = Math.max(1, gi.rows.length - rowspan + 1)\n\t\t\t\tdropCell = { column: Math.max(1, Math.min(maxCol, rawCell.column)), row: Math.max(1, Math.min(maxRow, rawCell.row)) }\n\t\t\t}\n\n\t\t\tcore.emit('drag-end', { item, cell: dropCell, colspan, rowspan, source: 'pointer' })\n\t\t\tcleanupDrag()\n\t\t\tcore.phase = 'selected'\n\t\t\tcore.interaction = null\n\n\t\t\t// Inline FLIP animation\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tconst lastRect = item.getBoundingClientRect()\n\t\t\t\tconst dx = firstRect.left - lastRect.left, dy = firstRect.top - lastRect.top\n\t\t\t\tif (Math.abs(dx) > 1 || Math.abs(dy) > 1) {\n\t\t\t\t\titem.style.viewTransitionName = 'none'\n\t\t\t\t\titem.setAttribute('data-egg-dropping', '')\n\t\t\t\t\tconst anim = item.animate(\n\t\t\t\t\t\t[{ transform: `translate(${dx}px, ${dy}px)` }, { transform: 'none' }],\n\t\t\t\t\t\t{ duration: 200, easing: 'cubic-bezier(0.2, 0, 0, 1)' },\n\t\t\t\t\t)\n\t\t\t\t\tanim.onfinish = () => {\n\t\t\t\t\t\titem.removeAttribute('data-egg-dropping')\n\t\t\t\t\t\tconst id = getItemId(item)\n\t\t\t\t\t\titem.style.viewTransitionName = id || ''\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tconst onPointerCancel = () => {\n\t\t\tif (drag) {\n\t\t\t\tcore.emit('drag-cancel', { item: drag.item, source: 'pointer' })\n\t\t\t\tcore.phase = 'selected'\n\t\t\t\tcore.interaction = null\n\t\t\t}\n\t\t\tcleanupDrag()\n\t\t}\n\n\t\tconst onPointerDown = (e: PointerEvent) => {\n\t\t\tconst item = (e.target as HTMLElement).closest('[data-egg-item]') as HTMLElement | null\n\t\t\tif (!item) return\n\t\t\tcore.select(item)\n\t\t\te.preventDefault()\n\t\t\tconst rect = item.getBoundingClientRect()\n\t\t\tpending = { item, pointerId: e.pointerId, startX: e.clientX, startY: e.clientY, rect, startCell: getItemCell(item), ...getItemSize(item) }\n\t\t\titem.setPointerCapture(e.pointerId)\n\t\t\titem.addEventListener('pointermove', onPointerMove)\n\t\t\titem.addEventListener('pointerup', onPointerUp)\n\t\t\titem.addEventListener('pointercancel', onPointerCancel)\n\t\t}\n\n\t\tconst onDocPointerDown = (e: PointerEvent) => {\n\t\t\tif (element.contains(e.target as Node) || drag) return\n\t\t\tcore.deselect()\n\t\t}\n\n\t\telement.addEventListener('pointerdown', onPointerDown)\n\t\tdocument.addEventListener('pointerdown', onDocPointerDown)\n\t\tcleanups.push(() => { element.removeEventListener('pointerdown', onPointerDown); document.removeEventListener('pointerdown', onDocPointerDown); cleanupDrag() })\n\t}\n\n\t// ── Resize ─────────────────────────────────────────────────────────────────\n\n\tif (options.resize !== false) {\n\t\tconst resizeOpts = typeof options.resize === 'object' ? options.resize : {}\n\t\tconst handles = resizeOpts.handles ?? 'corners'\n\t\tconst handleSize = resizeOpts.handleSize ?? 12\n\t\tconst minSize = resizeOpts.minSize ?? { colspan: 1, rowspan: 1 }\n\t\tconst maxSize = resizeOpts.maxSize ?? { colspan: 6, rowspan: 6 }\n\t\tconst showSizeLabel = resizeOpts.showSizeLabel ?? true\n\n\t\tconst CURSOR: Record<string, string> = { nw: 'nwse-resize', se: 'nwse-resize', ne: 'nesw-resize', sw: 'nesw-resize', n: 'ns-resize', s: 'ns-resize', e: 'ew-resize', w: 'ew-resize' }\n\n\t\tlet active: {\n\t\t\titem: HTMLElement; pointerId: number; handle: ResizeHandle; startCell: GridCell\n\t\t\torigSize: { colspan: number; rowspan: number }; curCell: GridCell; curSize: { colspan: number; rowspan: number }\n\t\t\tsizeLabel: HTMLElement | null; initRect: DOMRect; startX: number; startY: number\n\t\t} | null = null\n\t\tlet hoveredItem: HTMLElement | null = null\n\t\tlet hoveredHandle: ResizeHandle | null = null\n\n\t\tfunction detectHandle(e: PointerEvent, item: HTMLElement): ResizeHandle | null {\n\t\t\tconst r = item.getBoundingClientRect()\n\t\t\tconst x = e.clientX - r.left, y = e.clientY - r.top\n\t\t\tconst nL = x < handleSize, nR = x > r.width - handleSize, nT = y < handleSize, nB = y > r.height - handleSize\n\t\t\tif (handles === 'corners' || handles === 'all') {\n\t\t\t\tif (nT && nL) return 'nw'; if (nT && nR) return 'ne'; if (nB && nL) return 'sw'; if (nB && nR) return 'se'\n\t\t\t}\n\t\t\tif (handles === 'edges' || handles === 'all') {\n\t\t\t\tif (nT) return 'n'; if (nB) return 's'; if (nL) return 'w'; if (nR) return 'e'\n\t\t\t}\n\t\t\treturn null\n\t\t}\n\n\t\tfunction resetResizeItem(item: HTMLElement, pointerId: number, label: HTMLElement | null) {\n\t\t\titem.releasePointerCapture(pointerId)\n\t\t\titem.removeEventListener('pointermove', onResizePointerMove)\n\t\t\titem.removeEventListener('pointerup', onResizePointerUp)\n\t\t\titem.removeEventListener('pointercancel', onResizePointerCancel)\n\t\t\tif (label) label.remove()\n\t\t\titem.style.position = ''; item.style.left = ''; item.style.top = ''\n\t\t\titem.style.width = ''; item.style.height = ''; item.style.zIndex = ''\n\t\t\tconst id = getItemId(item)\n\t\t\titem.style.viewTransitionName = id || ''\n\t\t\titem.removeAttribute('data-egg-resizing')\n\t\t\titem.removeAttribute('data-egg-handle-active')\n\t\t}\n\n\t\tconst onResizePointerMove = (e: PointerEvent) => {\n\t\t\tif (!active || e.pointerId !== active.pointerId) return\n\t\t\tconst { item, handle, startCell, origSize, initRect, startX, startY, sizeLabel } = active\n\t\t\tconst gi = core.getGridInfo()\n\t\t\tconst dx = e.clientX - startX, dy = e.clientY - startY\n\n\t\t\tlet nW = initRect.width, nH = initRect.height, nL = initRect.left, nT = initRect.top\n\t\t\tconst minW = gi.cellWidth, minH = gi.cellHeight\n\t\t\tconst maxW = Math.min(maxSize.colspan * gi.cellWidth + (maxSize.colspan - 1) * gi.gap, gi.rect.right - initRect.left)\n\t\t\tconst maxH = Math.min(maxSize.rowspan * gi.cellHeight + (maxSize.rowspan - 1) * gi.gap, gi.rect.bottom - initRect.top)\n\n\t\t\tif (handle === 'e' || handle === 'se' || handle === 'ne') nW = Math.max(minW, Math.min(maxW, initRect.width + dx))\n\t\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t\t\tconst maxLS = initRect.left - gi.rect.left\n\t\t\t\tconst maxWL = Math.min(maxSize.colspan * gi.cellWidth + (maxSize.colspan - 1) * gi.gap, initRect.width + maxLS)\n\t\t\t\tconst wc = Math.max(-initRect.width + minW, Math.min(maxWL - initRect.width, -dx))\n\t\t\t\tnW = initRect.width + wc; nL = initRect.left - wc\n\t\t\t}\n\t\t\tif (handle === 's' || handle === 'se' || handle === 'sw') nH = Math.max(minH, Math.min(maxH, initRect.height + dy))\n\t\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t\t\tconst maxTS = initRect.top - gi.rect.top\n\t\t\t\tconst maxHL = Math.min(maxSize.rowspan * gi.cellHeight + (maxSize.rowspan - 1) * gi.gap, initRect.height + maxTS)\n\t\t\t\tconst hc = Math.max(-initRect.height + minH, Math.min(maxHL - initRect.height, -dy))\n\t\t\t\tnH = initRect.height + hc; nT = initRect.top - hc\n\t\t\t}\n\t\t\titem.style.left = `${nL}px`; item.style.top = `${nT}px`\n\t\t\titem.style.width = `${nW}px`; item.style.height = `${nH}px`\n\n\t\t\tconst cpg = gi.cellWidth + gi.gap, rpg = gi.cellHeight + gi.gap\n\t\t\tconst SNAP = 0.3\n\t\t\tlet pCS = Math.max(minSize.colspan, Math.min(maxSize.colspan, Math.floor((nW + gi.gap) / cpg + (1 - SNAP))))\n\t\t\tlet pRS = Math.max(minSize.rowspan, Math.min(maxSize.rowspan, Math.floor((nH + gi.gap) / rpg + (1 - SNAP))))\n\t\t\tlet pCol = startCell.column, pRow = startCell.row\n\t\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') pCol = startCell.column + origSize.colspan - pCS\n\t\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') pRow = startCell.row + origSize.rowspan - pRS\n\n\t\t\tactive.curSize = { colspan: pCS, rowspan: pRS }\n\t\t\tactive.curCell = { column: pCol, row: pRow }\n\t\t\tif (sizeLabel) sizeLabel.textContent = `${pCS}\\u00d7${pRS}`\n\n\t\t\tlet anchorCell: GridCell\n\t\t\tif (handle === 'se' || handle === 's' || handle === 'e') anchorCell = { column: startCell.column, row: startCell.row }\n\t\t\telse if (handle === 'nw' || handle === 'n' || handle === 'w') anchorCell = { column: startCell.column + origSize.colspan - 1, row: startCell.row + origSize.rowspan - 1 }\n\t\t\telse if (handle === 'ne') anchorCell = { column: startCell.column, row: startCell.row + origSize.rowspan - 1 }\n\t\t\telse anchorCell = { column: startCell.column + origSize.colspan - 1, row: startCell.row }\n\n\t\t\tcore.emit('resize-move', { item, cell: { column: pCol, row: pRow }, anchorCell, startCell, colspan: pCS, rowspan: pRS, handle, source: 'pointer' })\n\t\t}\n\n\t\tconst onResizePointerUp = (e: PointerEvent) => {\n\t\t\tif (!active || e.pointerId !== active.pointerId) return\n\t\t\tconst { item, pointerId, curSize, curCell, sizeLabel } = active\n\t\t\titem.setAttribute('data-egg-colspan', String(curSize.colspan))\n\t\t\titem.setAttribute('data-egg-rowspan', String(curSize.rowspan))\n\t\t\tcore.emit('resize-end', { item, cell: curCell, colspan: curSize.colspan, rowspan: curSize.rowspan, source: 'pointer' })\n\t\t\tresetResizeItem(item, pointerId, sizeLabel)\n\t\t\tactive = null\n\t\t\tcore.phase = 'selected'\n\t\t\tcore.interaction = null\n\t\t}\n\n\t\tconst onResizePointerCancel = (e: PointerEvent) => {\n\t\t\tif (!active || e.pointerId !== active.pointerId) return\n\t\t\tcore.emit('resize-cancel', { item: active.item, source: 'pointer' })\n\t\t\tresetResizeItem(active.item, active.pointerId, active.sizeLabel)\n\t\t\tactive = null\n\t\t\tcore.phase = 'selected'\n\t\t\tcore.interaction = null\n\t\t}\n\n\t\tconst onResizeDown = (e: PointerEvent) => {\n\t\t\tconst item = (e.target as HTMLElement).closest('[data-egg-item]') as HTMLElement | null\n\t\t\tif (!item) return\n\t\t\tconst handle = detectHandle(e, item)\n\t\t\tif (!handle) return\n\t\t\te.stopPropagation(); e.preventDefault()\n\t\t\tcore.select(item)\n\t\t\tconst { colspan, rowspan } = getItemSize(item)\n\t\t\tconst s = getComputedStyle(item)\n\t\t\tconst startCell = { column: parseInt(s.gridColumnStart, 10) || 1, row: parseInt(s.gridRowStart, 10) || 1 }\n\t\t\tconst initRect = item.getBoundingClientRect()\n\t\t\tlet sizeLabel: HTMLElement | null = null\n\t\t\tif (showSizeLabel) {\n\t\t\t\tsizeLabel = document.createElement('div')\n\t\t\t\tsizeLabel.className = 'egg-resize-label'\n\t\t\t\tsizeLabel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.8);color:white;padding:4px 8px;border-radius:4px;font-size:14px;font-weight:600;font-family:system-ui,sans-serif;pointer-events:none;z-index:1000;white-space:nowrap'\n\t\t\t\tsizeLabel.textContent = `${colspan}\\u00d7${rowspan}`\n\t\t\t\titem.appendChild(sizeLabel)\n\t\t\t}\n\t\t\tactive = { item, pointerId: e.pointerId, handle, startCell, origSize: { colspan, rowspan }, curCell: { ...startCell }, curSize: { colspan, rowspan }, sizeLabel, initRect, startX: e.clientX, startY: e.clientY }\n\t\t\titem.setAttribute('data-egg-resizing', ''); item.setAttribute('data-egg-handle-active', handle); item.removeAttribute('data-egg-handle-hover')\n\t\t\titem.setPointerCapture(e.pointerId)\n\t\t\titem.addEventListener('pointermove', onResizePointerMove)\n\t\t\titem.addEventListener('pointerup', onResizePointerUp)\n\t\t\titem.addEventListener('pointercancel', onResizePointerCancel)\n\t\t\tcore.phase = 'interacting'\n\t\t\tcore.interaction = { type: 'resize', mode: 'pointer', itemId: getItemId(item), element: item, columnCount: core.getGridInfo().columns.length }\n\t\t\tcore.emit('resize-start', { item, cell: startCell, colspan, rowspan, handle, source: 'pointer' })\n\t\t\titem.style.position = 'fixed'; item.style.left = `${initRect.left}px`; item.style.top = `${initRect.top}px`\n\t\t\titem.style.width = `${initRect.width}px`; item.style.height = `${initRect.height}px`; item.style.zIndex = '100'\n\t\t\titem.style.viewTransitionName = 'resizing'\n\t\t}\n\n\t\tconst onResizeHover = (e: PointerEvent) => {\n\t\t\tif (active) return\n\t\t\tconst item = (e.target as HTMLElement).closest('[data-egg-item]') as HTMLElement | null\n\t\t\tif (item) {\n\t\t\t\tconst h = detectHandle(e, item)\n\t\t\t\tif (h !== hoveredHandle || item !== hoveredItem) {\n\t\t\t\t\tif (hoveredItem && hoveredItem !== item) { hoveredItem.style.cursor = ''; hoveredItem.removeAttribute('data-egg-handle-hover') }\n\t\t\t\t\tif (hoveredItem === item && hoveredHandle && !h) item.removeAttribute('data-egg-handle-hover')\n\t\t\t\t\thoveredItem = item; hoveredHandle = h\n\t\t\t\t\titem.style.cursor = (h ? CURSOR[h] : '') || ''\n\t\t\t\t\tif (h) item.setAttribute('data-egg-handle-hover', h); else item.removeAttribute('data-egg-handle-hover')\n\t\t\t\t}\n\t\t\t} else if (hoveredItem) { hoveredItem.style.cursor = ''; hoveredItem.removeAttribute('data-egg-handle-hover'); hoveredItem = null; hoveredHandle = null }\n\t\t}\n\n\t\tconst onResizeEsc = (e: KeyboardEvent) => { if (e.key === 'Escape' && active) { onResizePointerCancel(new PointerEvent('pointercancel', { pointerId: active.pointerId })) } }\n\n\t\telement.addEventListener('pointerdown', onResizeDown, { capture: true })\n\t\telement.addEventListener('pointermove', onResizeHover)\n\t\tdocument.addEventListener('keydown', onResizeEsc)\n\t\tcleanups.push(() => { element.removeEventListener('pointerdown', onResizeDown, { capture: true }); element.removeEventListener('pointermove', onResizeHover); document.removeEventListener('keydown', onResizeEsc) })\n\t}\n\n\t// ── Keyboard ───────────────────────────────────────────────────────────────\n\n\tif (options.keyboard !== false) {\n\t\tlet kbMode = false\n\t\tlet kbTargetCell: GridCell | null = null\n\t\tlet pendingVtnRestore: { item: HTMLElement; tid: number } | null = null\n\n\t\tconst KEY_DIR: Record<string, 'up' | 'down' | 'left' | 'right'> = { ArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right', k: 'up', K: 'up', j: 'down', J: 'down', h: 'left', H: 'left', l: 'right', L: 'right' }\n\t\tconst CODE_DIR: Record<string, 'up' | 'down' | 'left' | 'right'> = { KeyK: 'up', KeyJ: 'down', KeyH: 'left', KeyL: 'right' }\n\t\tconst getDir = (key: string, code: string) => KEY_DIR[key] ?? CODE_DIR[code] ?? null\n\n\t\tconst isHolding = () => core.phase === 'interacting' && core.interaction?.type === 'drag' && core.interaction.mode === 'keyboard'\n\t\tconst getHeldItem = () => isHolding() ? core.interaction!.element : null\n\n\t\tconst getAdjacentCell = (cell: GridCell, dir: string, amt = 1): GridCell => {\n\t\t\tif (dir === 'up') return { ...cell, row: Math.max(1, cell.row - amt) }\n\t\t\tif (dir === 'down') return { ...cell, row: cell.row + amt }\n\t\t\tif (dir === 'left') return { ...cell, column: Math.max(1, cell.column - amt) }\n\t\t\treturn { ...cell, column: cell.column + amt }\n\t\t}\n\n\t\tconst findItemInDir = (from: GridCell, dir: string, exclude: HTMLElement): HTMLElement | null => {\n\t\t\tconst items = Array.from(element.querySelectorAll('[data-egg-item]')) as HTMLElement[]\n\t\t\tlet best: HTMLElement | null = null, bestDist = Infinity\n\t\t\tfor (const item of items) {\n\t\t\t\tif (item === exclude) continue\n\t\t\t\tconst c = getItemCell(item)\n\t\t\t\tlet inDir = false, dist = 0\n\t\t\t\tif (dir === 'up') { inDir = c.row < from.row; dist = from.row - c.row + Math.abs(c.column - from.column) * 0.1 }\n\t\t\t\telse if (dir === 'down') { inDir = c.row > from.row; dist = c.row - from.row + Math.abs(c.column - from.column) * 0.1 }\n\t\t\t\telse if (dir === 'left') { inDir = c.column < from.column; dist = from.column - c.column + Math.abs(c.row - from.row) * 0.1 }\n\t\t\t\telse { inDir = c.column > from.column; dist = c.column - from.column + Math.abs(c.row - from.row) * 0.1 }\n\t\t\t\tif (inDir && dist < bestDist) { bestDist = dist; best = item }\n\t\t\t}\n\t\t\treturn best\n\t\t}\n\n\t\tconst onKeyDown = (e: KeyboardEvent) => {\n\t\t\tif (e.key === 'G' && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {\n\t\t\t\te.preventDefault()\n\t\t\t\tkbMode = !kbMode\n\t\t\t\tif (kbMode) {\n\t\t\t\t\telement.setAttribute('data-egg-keyboard-mode', '')\n\t\t\t\t\tif (!core.selectedItem) { const f = element.querySelector('[data-egg-item]') as HTMLElement | null; if (f) core.select(f) }\n\t\t\t\t} else element.removeAttribute('data-egg-keyboard-mode')\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst focused = document.activeElement as HTMLElement | null\n\t\t\tif (!kbMode && !(focused && element.contains(focused)) && !core.selectedItem) return\n\t\t\tconst sel = core.selectedItem\n\t\t\tconst dir = getDir(e.key, e.code)\n\n\t\t\tif (e.key === 'Escape') {\n\t\t\t\te.preventDefault()\n\t\t\t\tconst held = getHeldItem()\n\t\t\t\tif (held) { held.removeAttribute('data-egg-dragging'); core.emit('drag-cancel', { item: held, source: 'keyboard' }); core.phase = 'selected'; core.interaction = null; kbTargetCell = null }\n\t\t\t\telse if (sel) core.deselect()\n\t\t\t\tif (kbMode) { kbMode = false; element.removeAttribute('data-egg-keyboard-mode') }\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (e.key === 'Enter' || e.key === ' ') {\n\t\t\t\tif (!sel) return; e.preventDefault()\n\t\t\t\tconst held = getHeldItem()\n\t\t\t\tif (held) {\n\t\t\t\t\tconst tc = kbTargetCell ?? getItemCell(held), sz = getItemSize(held)\n\t\t\t\t\theld.removeAttribute('data-egg-dragging')\n\t\t\t\t\tcore.emit('drag-end', { item: held, cell: tc, colspan: sz.colspan, rowspan: sz.rowspan, source: 'keyboard' })\n\t\t\t\t\tcore.phase = 'selected'; core.interaction = null; kbTargetCell = null\n\t\t\t\t} else {\n\t\t\t\t\tconst itemId = getItemId(sel), sz = getItemSize(sel), sc = getItemCell(sel)\n\t\t\t\t\tcore.phase = 'interacting'\n\t\t\t\t\tcore.interaction = { type: 'drag', mode: 'keyboard', itemId, element: sel, columnCount: core.getGridInfo().columns.length }\n\t\t\t\t\tkbTargetCell = sc\n\t\t\t\t\tsel.setAttribute('data-egg-dragging', '')\n\t\t\t\t\tcore.emit('drag-start', { item: sel, cell: sc, colspan: sz.colspan, rowspan: sz.rowspan, source: 'keyboard' })\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (!dir) return\n\t\t\te.preventDefault()\n\n\t\t\tif (e.altKey && !e.ctrlKey && !e.shiftKey && sel) {\n\t\t\t\tconst adj = findItemInDir(getItemCell(sel), dir, sel)\n\t\t\t\tif (adj) core.select(adj)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (!sel) return\n\n\t\t\tconst cc = getItemCell(sel), sz = getItemSize(sel), gi = core.getGridInfo()\n\n\t\t\t// Shift+nav: resize\n\t\t\tif (e.shiftKey && !e.ctrlKey && !e.altKey) {\n\t\t\t\tlet nCS = sz.colspan, nRS = sz.rowspan\n\t\t\t\tif (dir === 'right') nCS = Math.min(sz.colspan + 1, gi.columns.length - cc.column + 1)\n\t\t\t\telse if (dir === 'left') nCS = Math.max(1, sz.colspan - 1)\n\t\t\t\telse if (dir === 'down') nRS = sz.rowspan + 1\n\t\t\t\telse nRS = Math.max(1, sz.rowspan - 1)\n\t\t\t\tif (nCS === sz.colspan && nRS === sz.rowspan) return\n\n\t\t\t\tif (pendingVtnRestore) { clearTimeout(pendingVtnRestore.tid); pendingVtnRestore.item.style.removeProperty('view-transition-name'); pendingVtnRestore = null }\n\t\t\t\tconst handle = dir === 'right' || dir === 'down' ? 'se' : dir === 'left' ? 'w' : 'n'\n\t\t\t\tcore.phase = 'interacting'\n\t\t\t\tcore.interaction = { type: 'resize', mode: 'keyboard', itemId: getItemId(sel), element: sel, columnCount: gi.columns.length }\n\t\t\t\t;(sel.style as any).viewTransitionName = 'resizing'\n\t\t\t\tcore.emit('resize-start', { item: sel, cell: cc, colspan: sz.colspan, rowspan: sz.rowspan, handle })\n\t\t\t\tsel.setAttribute('data-egg-colspan', String(nCS))\n\t\t\t\tsel.setAttribute('data-egg-rowspan', String(nRS))\n\t\t\t\tcore.emit('resize-end', { item: sel, cell: cc, colspan: nCS, rowspan: nRS })\n\t\t\t\tcore.phase = 'selected'; core.interaction = null\n\t\t\t\tconst itemToRestore = sel\n\t\t\t\tconst tid = window.setTimeout(() => { itemToRestore.style.removeProperty('view-transition-name'); if (pendingVtnRestore?.item === itemToRestore) pendingVtnRestore = null }, 250)\n\t\t\t\tpendingVtnRestore = { item: itemToRestore, tid }\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlet amt = 1\n\t\t\tif (e.ctrlKey || e.metaKey) amt = (dir === 'up' || dir === 'down') ? sz.rowspan : sz.colspan\n\t\t\tconst rawCell = getAdjacentCell(cc, dir, amt)\n\t\t\tconst maxCol = Math.max(1, gi.columns.length - sz.colspan + 1)\n\t\t\tconst maxRow = Math.max(1, gi.rows.length - sz.rowspan + 1)\n\t\t\tconst tc = { column: Math.max(1, Math.min(maxCol, rawCell.column)), row: Math.max(1, Math.min(maxRow, rawCell.row)) }\n\t\t\tif (tc.column === cc.column && tc.row === cc.row) return\n\n\t\t\tconst held = getHeldItem()\n\t\t\tif (held) {\n\t\t\t\tkbTargetCell = tc\n\t\t\t\tcore.emit('drag-move', { item: held, cell: tc, x: 0, y: 0, colspan: sz.colspan, rowspan: sz.rowspan, source: 'keyboard' })\n\t\t\t} else {\n\t\t\t\tcore.emit('drag-start', { item: sel, cell: cc, colspan: sz.colspan, rowspan: sz.rowspan, source: 'keyboard' })\n\t\t\t\tcore.emit('drag-end', { item: sel, cell: tc, colspan: sz.colspan, rowspan: sz.rowspan, source: 'keyboard' })\n\t\t\t}\n\t\t}\n\n\t\tdocument.addEventListener('keydown', onKeyDown)\n\t\tcleanups.push(() => { document.removeEventListener('keydown', onKeyDown); element.removeAttribute('data-egg-keyboard-mode') })\n\t}\n\n\t// ── Algorithm Harness (unified drag + resize) ──────────────────────────────\n\n\tif (options.algorithm !== false) {\n\t\tconst algoType = options.algorithm ?? 'push'\n\t\tconst compact = options.compaction ?? true\n\t\tconst layoutModel = options.responsive?.layoutModel ?? options.layoutModel\n\n\t\tfunction getColumnCount(): number {\n\t\t\tconst s = getComputedStyle(element)\n\t\t\treturn Math.max(1, s.gridTemplateColumns.split(' ').filter(Boolean).length)\n\t\t}\n\n\t\t// Unified interaction state\n\t\tlet ix: {\n\t\t\ttype: 'drag' | 'resize'\n\t\t\titemId: string; element: HTMLElement; source: string\n\t\t\tcolumnCount: number\n\t\t\toriginals: Map<string, ItemRect>\n\t\t\tpendingCell: GridCell | null\n\t\t\tlastResize: { cell: GridCell; colspan: number; rowspan: number } | null\n\t\t\tlayout: ItemRect[] | null\n\t\t\tversion: number\n\t\t} | null = null\n\t\tlet layoutVersion = 0\n\n\t\tfunction calcLayout(items: ItemRect[], movedId: string, cell: GridCell, cols: number, colspan?: number, rowspan?: number): ItemRect[] {\n\t\t\tif (ix?.type === 'resize' && colspan != null && rowspan != null) {\n\t\t\t\t// Update the resized item in-place before calculating\n\t\t\t\tconst updated = items.map(i => i.id === movedId ? { ...i, column: cell.column, row: cell.row, width: colspan, height: rowspan } : i)\n\t\t\t\tif (algoType === 'reorder') {\n\t\t\t\t\tconst ordered = [...updated].sort((a, b) => a.row - b.row || a.column - b.column)\n\t\t\t\t\treturn reflowItems(ordered, cols)\n\t\t\t\t}\n\t\t\t\treturn calculatePushLayout(updated, movedId, cell, compact)\n\t\t\t}\n\t\t\tif (algoType === 'reorder') return calculateReorderLayout(items, movedId, cell, cols)\n\t\t\treturn calculatePushLayout(items, movedId, cell, compact)\n\t\t}\n\n\t\tfunction getItemsWithOriginals(excludeId: string | null, originals: Map<string, ItemRect>): ItemRect[] {\n\t\t\treturn readItemsFromDOM(element).map(item => {\n\t\t\t\tconst orig = originals.get(item.id)\n\t\t\t\tif (orig && item.id !== excludeId) return { ...item, column: orig.column, row: orig.row }\n\t\t\t\treturn item\n\t\t\t})\n\t\t}\n\n\t\tfunction getResizeItems(originals: Map<string, ItemRect>, resizedId: string, cell: GridCell, colspan: number, rowspan: number): ItemRect[] {\n\t\t\tconst items: ItemRect[] = []\n\t\t\tfor (const [id, o] of originals) {\n\t\t\t\tif (id === resizedId) items.push({ id, column: cell.column, row: cell.row, width: colspan, height: rowspan })\n\t\t\t\telse items.push({ ...o })\n\t\t\t}\n\t\t\treturn items\n\t\t}\n\n\t\tfunction applyLayout(layout: ItemRect[], excludeId: string | null, useVT: boolean, onApplied?: () => void) {\n\t\t\tconst v = ++layoutVersion\n\t\t\tif (ix) { ix.layout = layout; ix.version = v }\n\n\t\t\tconst doApply = () => {\n\t\t\t\tif (v !== layoutVersion) return\n\t\t\t\tcore.previewCSS = layoutToCSS(layout, { excludeId: excludeId ?? undefined, maxColumns: ix?.columnCount })\n\t\t\t\tcore.commitStyles()\n\t\t\t\tconst els = element.querySelectorAll('[data-egg-item]')\n\t\t\t\tfor (const el of els) {\n\t\t\t\t\tconst e = el as HTMLElement\n\t\t\t\t\tconst id = getItemId(e)\n\t\t\t\t\tif (id !== excludeId && e.style.viewTransitionName !== 'none') {\n\t\t\t\t\t\te.style.gridColumn = ''; e.style.gridRow = ''\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tonApplied?.()\n\t\t\t}\n\n\t\t\tif (useVT && 'startViewTransition' in document) {\n\t\t\t\tif (ix?.type === 'drag' && ix.element) ix.element.style.viewTransitionName = 'dragging'\n\t\t\t\t;(document as any).startViewTransition(doApply)\n\t\t\t} else doApply()\n\t\t}\n\n\t\tfunction saveAndClear(layout: ItemRect[], cols: number, afterSave?: () => void) {\n\t\t\tif (!layoutModel || !cols) return\n\t\t\tconst positions = new Map<string, { column: number; row: number }>()\n\t\t\tfor (const item of layout) positions.set(item.id, { column: item.column, row: item.row })\n\t\t\tlayoutModel.saveLayout(cols, positions)\n\t\t\tafterSave?.()\n\t\t\tcore.previewCSS = ''\n\t\t\tcore.commitStyles()\n\t\t\tcore.emit('layout-change', { items: layout, columnCount: cols })\n\t\t}\n\n\t\t// Event handlers\n\t\tconst onStart = (e: Event) => {\n\t\t\tconst detail = (e as CustomEvent).detail\n\t\t\tconst isDrag = e.type === 'egg-drag-start'\n\t\t\tconst itemId = getItemId(detail.item)\n\t\t\tconst items = readItemsFromDOM(element)\n\t\t\tconst originals = new Map<string, ItemRect>()\n\t\t\tfor (const i of items) originals.set(i.id, { ...i })\n\n\t\t\tix = {\n\t\t\t\ttype: isDrag ? 'drag' : 'resize', itemId, element: detail.item, source: detail.source,\n\t\t\t\tcolumnCount: getColumnCount(), originals, pendingCell: null, lastResize: null, layout: null, version: 0,\n\t\t\t}\n\n\t\t\t// Clear inline styles so CSS injection takes effect\n\t\t\tconst els = element.querySelectorAll('[data-egg-item]')\n\t\t\tfor (const el of els) {\n\t\t\t\tconst e = el as HTMLElement\n\t\t\t\tif (e !== detail.item) { e.style.gridColumn = ''; e.style.gridRow = '' }\n\t\t\t}\n\t\t\tcore.previewCSS = layoutToCSS(items, { maxColumns: ix.columnCount })\n\t\t\tcore.commitStyles()\n\t\t}\n\n\t\tconst onMove = (e: Event) => {\n\t\t\tif (!ix) return\n\t\t\tconst detail = (e as CustomEvent).detail\n\n\t\t\tif (ix.type === 'drag') {\n\t\t\t\tif (core.cameraScrolling) { ix.pendingCell = detail.cell; return }\n\t\t\t\tix.pendingCell = null\n\t\t\t\tconst items = getItemsWithOriginals(ix.itemId, ix.originals)\n\t\t\t\tconst layout = calcLayout(items, ix.itemId, detail.cell, ix.columnCount)\n\t\t\t\tapplyLayout(layout, ix.itemId, true)\n\n\t\t\t\t// Reorder: emit drop-preview for placeholder\n\t\t\t\tif (algoType === 'reorder') {\n\t\t\t\t\tconst landing = layout.find(i => i.id === ix!.itemId)\n\t\t\t\t\tif (landing) {\n\t\t\t\t\t\tconst pd = { cell: { column: landing.column, row: landing.row }, colspan: landing.width, rowspan: landing.height }\n\t\t\t\t\t\tqueueMicrotask(() => element.dispatchEvent(new CustomEvent('egg-drop-preview', { detail: pd, bubbles: true })))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Resize move — deduplicate\n\t\t\t\tconst { cell, colspan, rowspan } = detail\n\t\t\t\tif (ix.lastResize && ix.lastResize.cell.column === cell.column && ix.lastResize.cell.row === cell.row && ix.lastResize.colspan === colspan && ix.lastResize.rowspan === rowspan) return\n\t\t\t\tix.lastResize = { cell: { ...cell }, colspan, rowspan }\n\t\t\t\tconst items = getResizeItems(ix.originals, ix.itemId, cell, colspan, rowspan)\n\t\t\t\tconst layout = calcLayout(items, ix.itemId, cell, ix.columnCount, colspan, rowspan)\n\t\t\t\tapplyLayout(layout, ix.itemId, true)\n\t\t\t}\n\t\t}\n\n\t\tconst onEnd = (e: Event) => {\n\t\t\tif (!ix) return\n\t\t\tconst detail = (e as CustomEvent).detail\n\t\t\tconst savedIx = ix\n\n\t\t\tif (savedIx.element.style.viewTransitionName === 'dragging') savedIx.element.style.viewTransitionName = ''\n\t\t\tconst useVT = savedIx.source !== 'pointer'\n\n\t\t\tlet finalLayout: ItemRect[]\n\t\t\tif (savedIx.type === 'drag') {\n\t\t\t\tconst items = getItemsWithOriginals(savedIx.itemId, savedIx.originals)\n\t\t\t\tfinalLayout = calcLayout(items, savedIx.itemId, detail.cell, savedIx.columnCount)\n\t\t\t} else {\n\t\t\t\tconst items = getResizeItems(savedIx.originals, savedIx.itemId, detail.cell, detail.colspan, detail.rowspan)\n\t\t\t\tfinalLayout = calcLayout(items, savedIx.itemId, detail.cell, savedIx.columnCount, detail.colspan, detail.rowspan)\n\t\t\t}\n\n\t\t\tconst savedCols = savedIx.columnCount\n\t\t\tconst isResize = savedIx.type === 'resize'\n\t\t\tconst savedItemId = savedIx.itemId\n\n\t\t\tapplyLayout(finalLayout, null, useVT, () =>\n\t\t\t\tsaveAndClear(finalLayout, savedCols, isResize ? () => layoutModel?.updateItemSize(savedItemId, { width: detail.colspan, height: detail.rowspan }) : undefined),\n\t\t\t)\n\t\t\tix = null\n\t\t}\n\n\t\tconst onCancel = () => {\n\t\t\tif (!ix) return\n\t\t\tconst restoreLayout = Array.from(ix.originals.values())\n\t\t\tconst restore = () => applyLayout(restoreLayout, null, false)\n\t\t\tif ('startViewTransition' in document) (document as any).startViewTransition(restore)\n\t\t\telse restore()\n\t\t\tix = null\n\t\t}\n\n\t\tconst onCameraSettled = () => {\n\t\t\tif (!ix || ix.type !== 'drag') return\n\t\t\tlet cell = ix.pendingCell\n\t\t\tif (!cell && ix.element) {\n\t\t\t\tconst r = ix.element.getBoundingClientRect()\n\t\t\t\tcell = core.getCellFromPoint(r.left + r.width / 2, r.top + r.height / 2)\n\t\t\t}\n\t\t\tif (!cell) return\n\t\t\tix.pendingCell = null\n\t\t\tconst items = getItemsWithOriginals(ix.itemId, ix.originals)\n\t\t\tconst layout = calcLayout(items, ix.itemId, cell, ix.columnCount)\n\t\t\tapplyLayout(layout, ix.itemId, true)\n\t\t\tif (algoType === 'reorder') {\n\t\t\t\tconst landing = layout.find(i => i.id === ix!.itemId)\n\t\t\t\tif (landing) {\n\t\t\t\t\tconst pd = { cell: { column: landing.column, row: landing.row }, colspan: landing.width, rowspan: landing.height }\n\t\t\t\t\tqueueMicrotask(() => element.dispatchEvent(new CustomEvent('egg-drop-preview', { detail: pd, bubbles: true })))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst events: Record<string, EventListener> = {\n\t\t\t'egg-drag-start': onStart, 'egg-drag-move': onMove, 'egg-drag-end': onEnd, 'egg-drag-cancel': onCancel,\n\t\t\t'egg-resize-start': onStart, 'egg-resize-move': onMove, 'egg-resize-end': onEnd, 'egg-resize-cancel': onCancel,\n\t\t\t'egg-camera-settled': onCameraSettled,\n\t\t}\n\t\tfor (const [name, handler] of Object.entries(events)) element.addEventListener(name, handler)\n\t\tcleanups.push(() => { for (const [name, handler] of Object.entries(events)) element.removeEventListener(name, handler) })\n\t}\n\n\t// ── Camera ─────────────────────────────────────────────────────────────────\n\n\tif (options.camera !== false) {\n\t\tconst camOpts = typeof options.camera === 'object' ? options.camera : {}\n\t\tconst edgeSize = camOpts.edgeSize ?? 60\n\t\tconst scrollSpeed = camOpts.scrollSpeed ?? 15\n\t\tconst settleDelay = camOpts.settleDelay ?? 150\n\n\t\tlet scrollContainer: HTMLElement | Window = window\n\t\tlet p = element.parentElement\n\t\twhile (p) {\n\t\t\tconst s = getComputedStyle(p)\n\t\t\tif (s.overflowY === 'auto' || s.overflowY === 'scroll' || s.overflowX === 'auto' || s.overflowX === 'scroll') { scrollContainer = p; break }\n\t\t\tp = p.parentElement\n\t\t}\n\n\t\tlet isDragging = false, dragSrc: string | null = null\n\t\tlet lastPX = 0, lastPY = 0\n\t\tlet rafId: number | null = null, settleId: ReturnType<typeof setTimeout> | null = null\n\t\tlet wasScrolling = false\n\n\t\tfunction setScrolling(active: boolean) {\n\t\t\tif (active) {\n\t\t\t\tcore.cameraScrolling = true\n\t\t\t\tif (settleId) { clearTimeout(settleId); settleId = null }\n\t\t\t} else {\n\t\t\t\tif (settleId) clearTimeout(settleId)\n\t\t\t\tsettleId = setTimeout(() => {\n\t\t\t\t\tcore.cameraScrolling = false; settleId = null\n\t\t\t\t\telement.dispatchEvent(new CustomEvent('egg-camera-settled', { bubbles: true }))\n\t\t\t\t}, settleDelay)\n\t\t\t}\n\t\t}\n\n\t\tfunction scrollLoop() {\n\t\t\tif (!isDragging) { rafId = null; if (wasScrolling) { setScrolling(false); wasScrolling = false }; return }\n\t\t\tconst vp = scrollContainer === window\n\t\t\t\t? { top: 0, left: 0, width: window.innerWidth, height: window.innerHeight }\n\t\t\t\t: (() => { const r = (scrollContainer as HTMLElement).getBoundingClientRect(); return { top: r.top, left: r.left, width: r.width, height: r.height } })()\n\t\t\tconst rx = lastPX - vp.left, ry = lastPY - vp.top\n\t\t\tlet vx = 0, vy = 0\n\t\t\tif (rx < edgeSize) vx = -scrollSpeed * (1 - rx / edgeSize)\n\t\t\telse if (rx > vp.width - edgeSize) vx = scrollSpeed * (1 - (vp.width - rx) / edgeSize)\n\t\t\tif (ry < edgeSize) vy = -scrollSpeed * (1 - ry / edgeSize)\n\t\t\telse if (ry > vp.height - edgeSize) vy = scrollSpeed * (1 - (vp.height - ry) / edgeSize)\n\n\t\t\tif (vx || vy) {\n\t\t\t\tif (!wasScrolling) setScrolling(true)\n\t\t\t\twasScrolling = true\n\t\t\t\tif (scrollContainer === window) window.scrollBy(vx, vy)\n\t\t\t\telse { (scrollContainer as HTMLElement).scrollLeft += vx; (scrollContainer as HTMLElement).scrollTop += vy }\n\t\t\t} else if (wasScrolling) { setScrolling(false); wasScrolling = false }\n\t\t\trafId = requestAnimationFrame(scrollLoop)\n\t\t}\n\n\t\tconst onCamPtrMove = (e: PointerEvent) => { if (!isDragging) return; lastPX = e.clientX; lastPY = e.clientY; if (rafId === null) rafId = requestAnimationFrame(scrollLoop) }\n\t\tconst stopLoop = () => { if (rafId !== null) { cancelAnimationFrame(rafId); rafId = null }; setScrolling(false) }\n\n\t\tconst camEvents: Record<string, EventListener> = {\n\t\t\t'egg-drag-start': ((e: CustomEvent) => { isDragging = true; dragSrc = e.detail.source; if (dragSrc === 'pointer') window.addEventListener('pointermove', onCamPtrMove) }) as EventListener,\n\t\t\t'egg-drag-move': ((e: CustomEvent) => { if (e.detail.source === 'pointer') { lastPX = e.detail.x; lastPY = e.detail.y } else requestAnimationFrame(() => e.detail.item.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' })) }) as EventListener,\n\t\t\t'egg-drag-end': ((e: CustomEvent) => { const wp = dragSrc === 'pointer'; isDragging = false; dragSrc = null; stopLoop(); if (wp) window.removeEventListener('pointermove', onCamPtrMove); if (!wp) setTimeout(() => requestAnimationFrame(() => e.detail.item.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' })), 100) }) as EventListener,\n\t\t\t'egg-drag-cancel': (() => { const wp = dragSrc === 'pointer'; isDragging = false; dragSrc = null; stopLoop(); if (wp) window.removeEventListener('pointermove', onCamPtrMove) }) as EventListener,\n\t\t\t'egg-select': ((e: CustomEvent) => { if (!isDragging) e.detail.item.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' }) }) as EventListener,\n\t\t}\n\t\tfor (const [name, handler] of Object.entries(camEvents)) element.addEventListener(name, handler)\n\t\tcleanups.push(() => { stopLoop(); for (const [name, handler] of Object.entries(camEvents)) element.removeEventListener(name, handler) })\n\t}\n\n\t// ── Placeholder ────────────────────────────────────────────────────────────\n\n\tif (options.placeholder !== false) {\n\t\tconst phOpts = typeof options.placeholder === 'object' ? options.placeholder : {}\n\t\tconst className = phOpts.className ?? 'egg-placeholder'\n\t\tlet ph: HTMLElement | null = null\n\n\t\tfunction createPH() { if (ph) return; ph = document.createElement('div'); ph.className = className; ph.style.pointerEvents = 'none'; ph.style.viewTransitionName = 'none'; element.appendChild(ph) }\n\t\tfunction updatePH(c: number, r: number, cs: number, rs: number) { if (!ph) return; ph.style.gridColumn = `${c} / span ${cs}`; ph.style.gridRow = `${r} / span ${rs}` }\n\t\tfunction removePH() { if (ph) { ph.remove(); ph = null } }\n\n\t\tconst phEvents: Record<string, EventListener> = {\n\t\t\t'egg-drag-start': ((e: CustomEvent) => { createPH(); updatePH(e.detail.cell.column, e.detail.cell.row, e.detail.colspan, e.detail.rowspan) }) as EventListener,\n\t\t\t'egg-drag-move': ((e: CustomEvent) => { updatePH(e.detail.cell.column, e.detail.cell.row, e.detail.colspan, e.detail.rowspan) }) as EventListener,\n\t\t\t'egg-drop-preview': ((e: CustomEvent) => { updatePH(e.detail.cell.column, e.detail.cell.row, e.detail.colspan, e.detail.rowspan) }) as EventListener,\n\t\t\t'egg-drag-end': (() => removePH()) as EventListener,\n\t\t\t'egg-drag-cancel': (() => removePH()) as EventListener,\n\t\t\t'egg-resize-start': ((e: CustomEvent) => { createPH(); updatePH(e.detail.cell.column, e.detail.cell.row, e.detail.colspan, e.detail.rowspan) }) as EventListener,\n\t\t\t'egg-resize-move': ((e: CustomEvent) => { updatePH(e.detail.cell.column, e.detail.cell.row, e.detail.colspan, e.detail.rowspan) }) as EventListener,\n\t\t\t'egg-resize-end': (() => removePH()) as EventListener,\n\t\t\t'egg-resize-cancel': (() => removePH()) as EventListener,\n\t\t}\n\t\tfor (const [name, handler] of Object.entries(phEvents)) element.addEventListener(name, handler)\n\t\tdocument.addEventListener('pointerup', () => requestAnimationFrame(() => { if (ph && !document.querySelector('[data-egg-dragging]') && !document.querySelector('[data-egg-resizing]')) removePH() }))\n\t\tcleanups.push(() => { removePH(); for (const [name, handler] of Object.entries(phEvents)) element.removeEventListener(name, handler) })\n\t}\n\n\t// ── Accessibility ──────────────────────────────────────────────────────────\n\n\tif (options.accessibility !== false) {\n\t\tconst live = document.createElement('div')\n\t\tlive.setAttribute('aria-live', 'assertive'); live.setAttribute('aria-atomic', 'true')\n\t\tObject.assign(live.style, { position: 'absolute', width: '1px', height: '1px', padding: '0', margin: '-1px', overflow: 'hidden', clip: 'rect(0,0,0,0)', whiteSpace: 'nowrap', border: '0' })\n\t\telement.appendChild(live)\n\t\tlet lastA11yCell: GridCell | null = null, lastA11ySize: { colspan: number; rowspan: number } | null = null\n\n\t\tfunction announce(msg: string) { live.textContent = ''; requestAnimationFrame(() => { live.textContent = msg }) }\n\t\tfunction label(item: HTMLElement) { return item.getAttribute('data-egg-label') || item.getAttribute('aria-label') || item.id || 'Item' }\n\t\tfunction pos(cell: GridCell) { return `row ${cell.row}, column ${cell.column}` }\n\t\tfunction tpl(item: HTMLElement, event: string, vars: Record<string, string>, fallback: string): string {\n\t\t\tconst t = item.getAttribute(`data-egg-announce-${event}`) || element.getAttribute(`data-egg-announce-${event}`)\n\t\t\treturn t ? t.replace(/\\{(\\w+)\\}/g, (_, k) => vars[k] ?? '') : fallback\n\t\t}\n\n\t\tconst a11yEvents: Record<string, EventListener> = {\n\t\t\t'egg-drag-start': ((e: CustomEvent) => { lastA11yCell = e.detail.cell; const l = label(e.detail.item), p = pos(e.detail.cell); announce(tpl(e.detail.item, 'grab', { label: l, row: String(e.detail.cell.row), column: String(e.detail.cell.column) }, `${l} grabbed. Position ${p}. Use arrow keys to move, Enter to drop, Escape to cancel.`)) }) as EventListener,\n\t\t\t'egg-drag-move': ((e: CustomEvent) => { const c = e.detail.cell; if (lastA11yCell && c.row === lastA11yCell.row && c.column === lastA11yCell.column) return; lastA11yCell = c; announce(tpl(e.detail.item, 'move', { label: label(e.detail.item), row: String(c.row), column: String(c.column) }, `Moved to ${pos(c)}.`)) }) as EventListener,\n\t\t\t'egg-drag-end': ((e: CustomEvent) => { lastA11yCell = null; const l = label(e.detail.item), p = pos(e.detail.cell); announce(tpl(e.detail.item, 'drop', { label: l, row: String(e.detail.cell.row), column: String(e.detail.cell.column) }, `${l} dropped at ${p}.`)) }) as EventListener,\n\t\t\t'egg-drag-cancel': ((e: CustomEvent) => { lastA11yCell = null; announce(tpl(e.detail.item, 'cancel', { label: label(e.detail.item) }, `${label(e.detail.item)} drag cancelled.`)) }) as EventListener,\n\t\t\t'egg-resize-start': ((e: CustomEvent) => { lastA11ySize = { colspan: e.detail.colspan, rowspan: e.detail.rowspan }; const sz = `${e.detail.colspan} columns by ${e.detail.rowspan} rows`; announce(tpl(e.detail.item, 'resize-start', { label: label(e.detail.item), colspan: String(e.detail.colspan), rowspan: String(e.detail.rowspan) }, `${label(e.detail.item)} resize started. Size ${sz}.`)) }) as EventListener,\n\t\t\t'egg-resize-move': ((e: CustomEvent) => { if (lastA11ySize && e.detail.colspan === lastA11ySize.colspan && e.detail.rowspan === lastA11ySize.rowspan) return; lastA11ySize = { colspan: e.detail.colspan, rowspan: e.detail.rowspan }; announce(tpl(e.detail.item, 'resize-move', { label: label(e.detail.item), colspan: String(e.detail.colspan), rowspan: String(e.detail.rowspan) }, `Resized to ${e.detail.colspan} columns by ${e.detail.rowspan} rows.`)) }) as EventListener,\n\t\t\t'egg-resize-end': ((e: CustomEvent) => { lastA11ySize = null; const sz = `${e.detail.colspan} columns by ${e.detail.rowspan} rows`; announce(tpl(e.detail.item, 'resize-end', { label: label(e.detail.item), colspan: String(e.detail.colspan), rowspan: String(e.detail.rowspan), row: String(e.detail.cell.row), column: String(e.detail.cell.column) }, `${label(e.detail.item)} resized to ${sz} at ${pos(e.detail.cell)}.`)) }) as EventListener,\n\t\t\t'egg-resize-cancel': ((e: CustomEvent) => { lastA11ySize = null; announce(tpl(e.detail.item, 'resize-cancel', { label: label(e.detail.item) }, `${label(e.detail.item)} resize cancelled.`)) }) as EventListener,\n\t\t}\n\t\tfor (const [name, handler] of Object.entries(a11yEvents)) element.addEventListener(name, handler)\n\t\tcleanups.push(() => { live.remove(); for (const [name, handler] of Object.entries(a11yEvents)) element.removeEventListener(name, handler) })\n\t}\n\n\t// ── Responsive ─────────────────────────────────────────────────────────────\n\n\tif (options.responsive) {\n\t\tconst { layoutModel } = options.responsive\n\t\tlet cellSize = options.responsive.cellSize\n\t\tlet gap = options.responsive.gap\n\n\t\tfunction inferMetrics() {\n\t\t\tif (cellSize !== undefined && gap !== undefined) return\n\t\t\tconst s = getComputedStyle(element)\n\t\t\tif (gap === undefined) gap = parseFloat(s.columnGap) || parseFloat(s.gap) || 16\n\t\t\tif (cellSize === undefined) { const ar = parseFloat(s.gridAutoRows); cellSize = ar > 0 ? ar : parseFloat(s.gridTemplateColumns.split(' ')[0] ?? '184') || 184 }\n\t\t}\n\n\t\tfunction injectCSS() {\n\t\t\tinferMetrics()\n\t\t\tconst gridSelector = element.id ? `#${element.id}` : element.className ? `.${element.className.split(' ')[0]}` : '.grid'\n\t\t\tcore.baseCSS = layoutModel.generateAllBreakpointCSS({ cellSize: cellSize!, gap: gap!, gridSelector })\n\t\t\tcore.commitStyles()\n\t\t}\n\n\t\tif (!core.baseCSS.trim()) injectCSS()\n\t\tconst unsub = layoutModel.subscribe(() => injectCSS())\n\n\t\tlet lastColCount = layoutModel.currentColumnCount\n\t\tconst ro = new ResizeObserver(() => {\n\t\t\tconst s = getComputedStyle(element)\n\t\t\tconst newCount = Math.max(1, s.gridTemplateColumns.split(' ').filter(Boolean).length)\n\t\t\tif (newCount !== lastColCount) {\n\t\t\t\tconst prev = lastColCount; lastColCount = newCount\n\t\t\t\tlayoutModel.setCurrentColumnCount(newCount)\n\t\t\t\telement.dispatchEvent(new CustomEvent('egg-column-count-change', { bubbles: true, detail: { previousCount: prev, currentCount: newCount } }))\n\t\t\t}\n\t\t})\n\t\tro.observe(element)\n\t\tcleanups.push(() => { ro.disconnect(); unsub() })\n\t}\n\n\t// Snapshot initial layout from inline styles → CSS, then clear inline styles\n\t// so CSS injection controls layout from here on. Skip if responsive plugin\n\t// already injected CSS (it writes to baseCSS).\n\tif (!options.responsive && !core.baseCSS) {\n\t\tconst items = readItemsFromDOM(element)\n\t\tcore.baseCSS = layoutToCSS(items)\n\t\tcore.commitStyles()\n\t\telement.querySelectorAll('[data-egg-item]').forEach(el => {\n\t\t\t(el as HTMLElement).style.removeProperty('grid-column');\n\t\t\t(el as HTMLElement).style.removeProperty('grid-row')\n\t\t})\n\t}\n\n\treturn core\n}\n\n// ── Exports ────────────────────────────────────────────────────────────────────\n\nexport { getItemCell, getItemSize, getItemId, layoutToCSS, readItemsFromDOM }\nexport { calculatePushLayout, itemsOverlap, pushDown, compactUp }\nexport { calculateReorderLayout, reflowItems }\nexport type { GridCell, ItemRect, ResizeHandle, EggCore, InitOptions, ResponsiveLayoutModel }\n","/**\n * Development overlay plugin for EG Grid\n *\n * Provides a toggleable panel with:\n * - Debug tab: Grid info, item positions, event log\n * - Config tab: Algorithm options, plugin toggles\n *\n * Toggle with Shift+D (or programmatically)\n */\n\nimport { getItemCell } from '../eg-grid';\nimport type { EggCore } from '../eg-grid';\n\ntype GridInfo = ReturnType<EggCore['getGridInfo']>;\n\nexport interface DevOverlayOptions {\n\t/** Initial tab to show ('debug' | 'config') */\n\tinitialTab?: 'debug' | 'config';\n\t/** Keyboard shortcut to toggle (default: 'D' with Shift) */\n\ttoggleKey?: string;\n\t/** Initial visibility */\n\tvisible?: boolean;\n\t/** EggCore instance for provider access */\n\tcore?: EggCore;\n}\n\nexport interface ConfigOption {\n\tkey: string;\n\tlabel: string;\n\ttype: 'boolean' | 'select' | 'action';\n\tvalue?: boolean | string;\n\toptions?: string[]; // For select type\n\tonChange?: (value: boolean | string) => void;\n\tonAction?: () => void; // For action type\n}\n\ninterface EventLogEntry {\n\ttime: number;\n\ttype: string;\n\tdetail: string;\n}\n\nconst STYLES = `\n.egg-dev-overlay {\n\tposition: fixed;\n\tbottom: 16px;\n\tright: 16px;\n\twidth: 320px;\n\tmax-height: 400px;\n\tbackground: rgba(0, 0, 0, 0.95);\n\tcolor: #fff;\n\tfont-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;\n\tfont-size: 12px;\n\tborder-radius: 8px;\n\tbox-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);\n\tz-index: 1000;\n\tdisplay: flex;\n\tflex-direction: column;\n\toverflow: hidden;\n\tview-transition-name: dev-overlay;\n}\n\n.egg-dev-overlay[hidden] {\n\tdisplay: none;\n}\n\n.egg-dev-tabs {\n\tdisplay: flex;\n\tborder-bottom: 1px solid #333;\n\tflex-shrink: 0;\n}\n\n.egg-dev-tab {\n\tflex: 1;\n\tpadding: 8px 12px;\n\tbackground: transparent;\n\tborder: none;\n\tcolor: #888;\n\tcursor: pointer;\n\tfont-family: inherit;\n\tfont-size: 11px;\n\ttext-transform: uppercase;\n\tletter-spacing: 0.5px;\n}\n\n.egg-dev-tab:hover {\n\tcolor: #ccc;\n}\n\n.egg-dev-tab[data-active=\"true\"] {\n\tcolor: #fff;\n\tbackground: #222;\n}\n\n.egg-dev-content {\n\tflex: 1;\n\toverflow-y: auto;\n\tpadding: 12px;\n}\n\n.egg-dev-section {\n\tmargin-bottom: 12px;\n}\n\n.egg-dev-section:last-child {\n\tmargin-bottom: 0;\n}\n\n.egg-dev-section-title {\n\tcolor: #888;\n\tfont-size: 10px;\n\ttext-transform: uppercase;\n\tletter-spacing: 0.5px;\n\tmargin-bottom: 6px;\n}\n\n.egg-dev-grid-info {\n\tdisplay: grid;\n\tgrid-template-columns: 1fr 1fr;\n\tgap: 4px;\n}\n\n.egg-dev-info-item {\n\tdisplay: flex;\n\tjustify-content: space-between;\n}\n\n.egg-dev-info-label {\n\tcolor: #888;\n}\n\n.egg-dev-info-value {\n\tcolor: #4ade80;\n}\n\n.egg-dev-items-list {\n\tmax-height: 120px;\n\toverflow-y: auto;\n}\n\n.egg-dev-item-row {\n\tdisplay: flex;\n\tjustify-content: space-between;\n\tpadding: 2px 0;\n\tborder-bottom: 1px solid #222;\n}\n\n.egg-dev-item-id {\n\tcolor: #60a5fa;\n}\n\n.egg-dev-item-pos {\n\tcolor: #888;\n}\n\n.egg-dev-event-log {\n\tmax-height: 150px;\n\toverflow-y: auto;\n}\n\n.egg-dev-event {\n\tpadding: 2px 0;\n\tborder-bottom: 1px solid #222;\n\tdisplay: flex;\n\tgap: 8px;\n}\n\n.egg-dev-event-time {\n\tcolor: #666;\n\tflex-shrink: 0;\n}\n\n.egg-dev-event-type {\n\tcolor: #f472b6;\n\tflex-shrink: 0;\n}\n\n.egg-dev-event-detail {\n\tcolor: #888;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\twhite-space: nowrap;\n}\n\n.egg-dev-config-row {\n\tdisplay: flex;\n\tjustify-content: space-between;\n\talign-items: center;\n\tpadding: 6px 0;\n\tborder-bottom: 1px solid #222;\n}\n\n.egg-dev-config-label {\n\tcolor: #ccc;\n}\n\n.egg-dev-toggle {\n\tposition: relative;\n\twidth: 36px;\n\theight: 20px;\n\tbackground: #444;\n\tborder-radius: 10px;\n\tcursor: pointer;\n\ttransition: background 0.2s;\n}\n\n.egg-dev-toggle[data-checked=\"true\"] {\n\tbackground: #4ade80;\n}\n\n.egg-dev-toggle::after {\n\tcontent: '';\n\tposition: absolute;\n\ttop: 2px;\n\tleft: 2px;\n\twidth: 16px;\n\theight: 16px;\n\tbackground: #fff;\n\tborder-radius: 50%;\n\ttransition: transform 0.2s;\n}\n\n.egg-dev-toggle[data-checked=\"true\"]::after {\n\ttransform: translateX(16px);\n}\n\n.egg-dev-select {\n\tbackground: #333;\n\tcolor: #fff;\n\tborder: 1px solid #444;\n\tborder-radius: 4px;\n\tpadding: 4px 8px;\n\tfont-family: inherit;\n\tfont-size: 12px;\n}\n\n.egg-dev-close {\n\tposition: absolute;\n\ttop: 8px;\n\tright: 8px;\n\tbackground: transparent;\n\tborder: none;\n\tcolor: #666;\n\tcursor: pointer;\n\tfont-size: 16px;\n\tline-height: 1;\n\tpadding: 4px;\n}\n\n.egg-dev-close:hover {\n\tcolor: #fff;\n}\n\n.egg-dev-hint {\n\tcolor: #666;\n\tfont-size: 10px;\n\ttext-align: center;\n\tpadding: 8px;\n\tborder-top: 1px solid #222;\n}\n\n.egg-dev-action-btn {\n\tbackground: #333;\n\tcolor: #fff;\n\tborder: 1px solid #444;\n\tborder-radius: 4px;\n\tpadding: 6px 12px;\n\tfont-family: inherit;\n\tfont-size: 12px;\n\tcursor: pointer;\n\ttransition: background 0.2s;\n}\n\n.egg-dev-action-btn:hover {\n\tbackground: #444;\n}\n\n.egg-dev-action-btn:active {\n\tbackground: #555;\n}\n\n.egg-dev-status {\n\tcolor: #888;\n\tfont-size: 11px;\n\tmargin-top: 4px;\n}\n`;\n\n/**\n * Attach the dev overlay to a grid element\n */\nexport function attachDevOverlay(\n\tgridElement: HTMLElement,\n\toptions: DevOverlayOptions = {},\n): { toggle: () => void; show: () => void; hide: () => void; registerOption: (option: ConfigOption) => void; destroy: () => void } {\n\tconst { initialTab = 'debug', toggleKey = 'D', visible = false, core } = options;\n\n\t// Inject styles\n\tlet styleElement = document.getElementById('egg-dev-overlay-styles') as HTMLStyleElement | null;\n\tif (!styleElement) {\n\t\tstyleElement = document.createElement('style');\n\t\tstyleElement.id = 'egg-dev-overlay-styles';\n\t\tstyleElement.textContent = STYLES;\n\t\tdocument.head.appendChild(styleElement);\n\t}\n\n\t// State\n\tlet currentTab = initialTab;\n\tlet isVisible = visible;\n\tconst eventLog: EventLogEntry[] = [];\n\tconst configOptions: ConfigOption[] = [];\n\tconst startTime = performance.now();\n\n\t// Create overlay element\n\tconst overlay = document.createElement('div');\n\toverlay.className = 'egg-dev-overlay';\n\toverlay.hidden = !isVisible;\n\n\tfunction formatTime(time: number): string {\n\t\tconst elapsed = ((time - startTime) / 1000).toFixed(1);\n\t\treturn `${elapsed}s`;\n\t}\n\n\tfunction render() {\n\t\tconst gridInfo = core?.getGridInfo();\n\t\tconst items = Array.from(gridElement.querySelectorAll('[data-egg-item]')) as HTMLElement[];\n\n\t\toverlay.innerHTML = `\n\t\t\t<button class=\"egg-dev-close\">&times;</button>\n\t\t\t<div class=\"egg-dev-tabs\">\n\t\t\t\t<button class=\"egg-dev-tab\" data-tab=\"debug\" data-active=\"${currentTab === 'debug'}\">Debug</button>\n\t\t\t\t<button class=\"egg-dev-tab\" data-tab=\"config\" data-active=\"${currentTab === 'config'}\">Config</button>\n\t\t\t</div>\n\t\t\t<div class=\"egg-dev-content\">\n\t\t\t\t${currentTab === 'debug' ? renderDebugTab(gridInfo, items) : renderConfigTab()}\n\t\t\t</div>\n\t\t\t<div class=\"egg-dev-hint\">Shift+${toggleKey} to toggle</div>\n\t\t`;\n\n\t\t// Attach event listeners\n\t\toverlay.querySelector('.egg-dev-close')?.addEventListener('click', hide);\n\n\t\toverlay.querySelectorAll('.egg-dev-tab').forEach(tab => {\n\t\t\ttab.addEventListener('click', () => {\n\t\t\t\tcurrentTab = (tab as HTMLElement).dataset.tab as 'debug' | 'config';\n\t\t\t\trender();\n\t\t\t});\n\t\t});\n\n\t\t// Config toggles\n\t\toverlay.querySelectorAll('.egg-dev-toggle').forEach(toggle => {\n\t\t\ttoggle.addEventListener('click', () => {\n\t\t\t\tconst key = (toggle as HTMLElement).dataset.key;\n\t\t\t\tconst option = configOptions.find(o => o.key === key);\n\t\t\t\tif (option && option.type === 'boolean') {\n\t\t\t\t\toption.value = !option.value;\n\t\t\t\t\toption.onChange(option.value);\n\t\t\t\t\trender();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\t// Config selects\n\t\toverlay.querySelectorAll('.egg-dev-select').forEach(select => {\n\t\t\tselect.addEventListener('change', (e) => {\n\t\t\t\tconst key = (select as HTMLElement).dataset.key;\n\t\t\t\tconst option = configOptions.find(o => o.key === key);\n\t\t\t\tif (option && option.type === 'select' && option.onChange) {\n\t\t\t\t\toption.value = (e.target as HTMLSelectElement).value;\n\t\t\t\t\toption.onChange(option.value);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\t// Action buttons\n\t\toverlay.querySelectorAll('.egg-dev-action-btn').forEach(btn => {\n\t\t\tbtn.addEventListener('click', () => {\n\t\t\t\tconst key = (btn as HTMLElement).dataset.key;\n\t\t\t\tconst option = configOptions.find(o => o.key === key);\n\t\t\t\tif (option && option.type === 'action' && option.onAction) {\n\t\t\t\t\toption.onAction();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tfunction renderDebugTab(gridInfo: GridInfo | undefined, items: HTMLElement[]): string {\n\t\tif (!gridInfo) return '<div class=\"egg-dev-section\">No core available</div>';\n\t\t// Query core state\n\t\tconst dragging = core?.phase === 'interacting' && core?.interaction?.type === 'drag';\n\t\tconst resizing = core?.phase === 'interacting' && core?.interaction?.type === 'resize';\n\t\tconst interaction = core?.interaction;\n\n\t\treturn `\n\t\t\t${core ? `\n\t\t\t<div class=\"egg-dev-section\">\n\t\t\t\t<div class=\"egg-dev-section-title\">State</div>\n\t\t\t\t<div class=\"egg-dev-grid-info\">\n\t\t\t\t\t<div class=\"egg-dev-info-item\">\n\t\t\t\t\t\t<span class=\"egg-dev-info-label\">phase</span>\n\t\t\t\t\t\t<span class=\"egg-dev-info-value\">${core?.phase ?? 'unknown'}</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"egg-dev-info-item\">\n\t\t\t\t\t\t<span class=\"egg-dev-info-label\">interaction</span>\n\t\t\t\t\t\t<span class=\"egg-dev-info-value\">${dragging ? 'dragging' : resizing ? 'resizing' : 'none'}${interaction ? ` (${interaction.mode})` : ''}</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t${interaction ? `\n\t\t\t\t\t<div class=\"egg-dev-info-item\">\n\t\t\t\t\t\t<span class=\"egg-dev-info-label\">item</span>\n\t\t\t\t\t\t<span class=\"egg-dev-info-value\">${interaction.itemId || '?'}</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t` : ''}\n\t\t\t\t\t<div class=\"egg-dev-info-item\">\n\t\t\t\t\t\t<span class=\"egg-dev-info-label\">selected</span>\n\t\t\t\t\t\t<span class=\"egg-dev-info-value\">${core?.selectedItem?.dataset?.eggItem ?? core?.selectedItem?.id ?? 'none'}</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t` : ''}\n\t\t\t<div class=\"egg-dev-section\">\n\t\t\t\t<div class=\"egg-dev-section-title\">Grid Info</div>\n\t\t\t\t<div class=\"egg-dev-grid-info\">\n\t\t\t\t\t<div class=\"egg-dev-info-item\">\n\t\t\t\t\t\t<span class=\"egg-dev-info-label\">Columns</span>\n\t\t\t\t\t\t<span class=\"egg-dev-info-value\">${gridInfo.columns.length}</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"egg-dev-info-item\">\n\t\t\t\t\t\t<span class=\"egg-dev-info-label\">Rows</span>\n\t\t\t\t\t\t<span class=\"egg-dev-info-value\">${gridInfo.rows.length}</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"egg-dev-info-item\">\n\t\t\t\t\t\t<span class=\"egg-dev-info-label\">Cell W</span>\n\t\t\t\t\t\t<span class=\"egg-dev-info-value\">${Math.round(gridInfo.cellWidth)}px</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"egg-dev-info-item\">\n\t\t\t\t\t\t<span class=\"egg-dev-info-label\">Cell H</span>\n\t\t\t\t\t\t<span class=\"egg-dev-info-value\">${Math.round(gridInfo.cellHeight)}px</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"egg-dev-info-item\">\n\t\t\t\t\t\t<span class=\"egg-dev-info-label\">Gap</span>\n\t\t\t\t\t\t<span class=\"egg-dev-info-value\">${gridInfo.gap}px</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"egg-dev-info-item\">\n\t\t\t\t\t\t<span class=\"egg-dev-info-label\">Items</span>\n\t\t\t\t\t\t<span class=\"egg-dev-info-value\">${items.length}</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"egg-dev-section\">\n\t\t\t\t<div class=\"egg-dev-section-title\">Items</div>\n\t\t\t\t<div class=\"egg-dev-items-list\">\n\t\t\t\t\t${items.map(item => {\n\t\t\t\t\t\tconst cell = getItemCell(item);\n\t\t\t\t\t\tconst id = item.dataset.eggItem || item.dataset.id || item.id || '?';\n\t\t\t\t\t\tconst colspan = item.getAttribute('data-egg-colspan') || '1';\n\t\t\t\t\t\tconst rowspan = item.getAttribute('data-egg-rowspan') || '1';\n\t\t\t\t\t\treturn `\n\t\t\t\t\t\t\t<div class=\"egg-dev-item-row\">\n\t\t\t\t\t\t\t\t<span class=\"egg-dev-item-id\">${id}</span>\n\t\t\t\t\t\t\t\t<span class=\"egg-dev-item-pos\">col ${cell.column}, row ${cell.row} (${colspan}×${rowspan})</span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t`;\n\t\t\t\t\t}).join('')}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"egg-dev-section\">\n\t\t\t\t<div class=\"egg-dev-section-title\">Event Log</div>\n\t\t\t\t<div class=\"egg-dev-event-log\">\n\t\t\t\t\t${eventLog.length === 0 ? '<div style=\"color: #666\">No events yet</div>' : ''}\n\t\t\t\t\t${eventLog.slice(-20).reverse().map(entry => `\n\t\t\t\t\t\t<div class=\"egg-dev-event\">\n\t\t\t\t\t\t\t<span class=\"egg-dev-event-time\">${formatTime(entry.time)}</span>\n\t\t\t\t\t\t\t<span class=\"egg-dev-event-type\">${entry.type}</span>\n\t\t\t\t\t\t\t<span class=\"egg-dev-event-detail\">${entry.detail}</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t`).join('')}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t`;\n\t}\n\n\tfunction renderConfigTab(): string {\n\t\tif (configOptions.length === 0) {\n\t\t\treturn `<div style=\"color: #666; text-align: center; padding: 20px;\">No config options registered.<br><br>Use registerOption() to add options.</div>`;\n\t\t}\n\n\t\tconst toggles = configOptions.filter(o => o.type === 'boolean');\n\t\tconst selects = configOptions.filter(o => o.type === 'select');\n\t\tconst actions = configOptions.filter(o => o.type === 'action');\n\n\t\treturn `\n\t\t\t<div class=\"egg-dev-section\">\n\t\t\t\t<div class=\"egg-dev-section-title\">Options</div>\n\t\t\t\t${toggles.map(option => `\n\t\t\t\t\t<div class=\"egg-dev-config-row\">\n\t\t\t\t\t\t<span class=\"egg-dev-config-label\">${option.label}</span>\n\t\t\t\t\t\t<div class=\"egg-dev-toggle\" data-key=\"${option.key}\" data-checked=\"${option.value}\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t`).join('')}\n\t\t\t\t${selects.map(option => `\n\t\t\t\t\t<div class=\"egg-dev-config-row\">\n\t\t\t\t\t\t<span class=\"egg-dev-config-label\">${option.label}</span>\n\t\t\t\t\t\t<select class=\"egg-dev-select\" data-key=\"${option.key}\">\n\t\t\t\t\t\t\t${(option.options || []).map(opt => `<option value=\"${opt}\"${opt === option.value ? ' selected' : ''}>${opt}</option>`).join('')}\n\t\t\t\t\t\t</select>\n\t\t\t\t\t</div>\n\t\t\t\t`).join('')}\n\t\t\t</div>\n\t\t\t${actions.length > 0 ? `\n\t\t\t\t<div class=\"egg-dev-section\">\n\t\t\t\t\t<div class=\"egg-dev-section-title\">Actions</div>\n\t\t\t\t\t${actions.map(option => `\n\t\t\t\t\t\t<div class=\"egg-dev-config-row\">\n\t\t\t\t\t\t\t<span class=\"egg-dev-config-label\">${option.label}</span>\n\t\t\t\t\t\t\t<button class=\"egg-dev-action-btn\" data-key=\"${option.key}\">Run</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t`).join('')}\n\t\t\t\t</div>\n\t\t\t` : ''}\n\t\t`;\n\t}\n\n\tfunction logEvent(type: string, detail: string) {\n\t\teventLog.push({ time: performance.now(), type, detail });\n\t\tif (eventLog.length > 100) {\n\t\t\teventLog.shift();\n\t\t}\n\t\tif (isVisible && currentTab === 'debug') {\n\t\t\trender();\n\t\t}\n\t}\n\n\tfunction show() {\n\t\tisVisible = true;\n\t\toverlay.hidden = false;\n\t\trender();\n\t}\n\n\tfunction hide() {\n\t\tisVisible = false;\n\t\toverlay.hidden = true;\n\t}\n\n\tfunction toggle() {\n\t\tif (isVisible) {\n\t\t\thide();\n\t\t} else {\n\t\t\tshow();\n\t\t}\n\t}\n\n\tfunction registerOption(option: ConfigOption) {\n\t\tconst existing = configOptions.findIndex(o => o.key === option.key);\n\t\tif (existing >= 0) {\n\t\t\tconfigOptions[existing] = option;\n\t\t} else {\n\t\t\tconfigOptions.push(option);\n\t\t}\n\t\tif (isVisible) {\n\t\t\trender();\n\t\t}\n\t}\n\n\t// Event listeners for logging\n\tconst onDragStart = (e: Event) => {\n\t\tconst detail = (e as CustomEvent).detail;\n\t\tconst id = detail.item?.dataset?.eggItem || detail.item?.dataset?.id || detail.item?.id || '?';\n\t\tlogEvent('drag-start', `${id} at (${detail.cell.column}, ${detail.cell.row})`);\n\t};\n\n\tconst onDragMove = (e: Event) => {\n\t\tconst detail = (e as CustomEvent).detail;\n\t\tconst id = detail.item?.dataset?.eggItem || detail.item?.dataset?.id || detail.item?.id || '?';\n\t\tlogEvent('drag-move', `${id} → (${detail.cell.column}, ${detail.cell.row})`);\n\t};\n\n\tconst onDragEnd = (e: Event) => {\n\t\tconst detail = (e as CustomEvent).detail;\n\t\tconst id = detail.item?.dataset?.eggItem || detail.item?.dataset?.id || detail.item?.id || '?';\n\t\tlogEvent('drag-end', `${id} at (${detail.cell.column}, ${detail.cell.row})`);\n\t};\n\n\tconst onDragCancel = (e: Event) => {\n\t\tconst detail = (e as CustomEvent).detail;\n\t\tconst id = detail.item?.dataset?.eggItem || detail.item?.dataset?.id || detail.item?.id || '?';\n\t\tlogEvent('drag-cancel', id);\n\t};\n\n\tconst onSelect = (e: Event) => {\n\t\tconst detail = (e as CustomEvent).detail;\n\t\tconst id = detail.item?.dataset?.eggItem || detail.item?.dataset?.id || detail.item?.id || '?';\n\t\tlogEvent('select', id);\n\t};\n\n\tconst onDeselect = (e: Event) => {\n\t\tconst detail = (e as CustomEvent).detail;\n\t\tconst id = detail.item?.dataset?.eggItem || detail.item?.dataset?.id || detail.item?.id || 'none';\n\t\tlogEvent('deselect', id);\n\t};\n\n\tconst onKeyDown = (e: KeyboardEvent) => {\n\t\tif (e.key === toggleKey && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {\n\t\t\te.preventDefault();\n\t\t\ttoggle();\n\t\t}\n\t};\n\n\t// Attach listeners\n\tgridElement.addEventListener('egg-drag-start', onDragStart);\n\tgridElement.addEventListener('egg-drag-move', onDragMove);\n\tgridElement.addEventListener('egg-drag-end', onDragEnd);\n\tgridElement.addEventListener('egg-drag-cancel', onDragCancel);\n\tgridElement.addEventListener('egg-select', onSelect);\n\tgridElement.addEventListener('egg-deselect', onDeselect);\n\tdocument.addEventListener('keydown', onKeyDown);\n\n\t// Add to DOM\n\tdocument.body.appendChild(overlay);\n\trender();\n\n\tfunction destroy() {\n\t\tgridElement.removeEventListener('egg-drag-start', onDragStart);\n\t\tgridElement.removeEventListener('egg-drag-move', onDragMove);\n\t\tgridElement.removeEventListener('egg-drag-end', onDragEnd);\n\t\tgridElement.removeEventListener('egg-drag-cancel', onDragCancel);\n\t\tgridElement.removeEventListener('egg-select', onSelect);\n\t\tgridElement.removeEventListener('egg-deselect', onDeselect);\n\t\tdocument.removeEventListener('keydown', onKeyDown);\n\t\toverlay.remove();\n\t}\n\n\treturn { toggle, show, hide, registerOption, destroy };\n}\n"],"mappings":"AAqEA,SAAS,EAAY,EAA6B,CACjD,IAAM,EAAI,iBAAiB,EAAK,CAChC,MAAO,CAAE,OAAQ,SAAS,EAAE,gBAAiB,GAAG,EAAI,EAAG,IAAK,SAAS,EAAE,aAAc,GAAG,EAAI,EAAG,CC7BhG,IAAM,EAAS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAyPf,SAAgB,EACf,EACA,EAA6B,EAAE,CACmG,CAClI,GAAM,CAAE,aAAa,QAAS,YAAY,IAAK,UAAU,GAAO,QAAS,EAGrE,EAAe,SAAS,eAAe,yBAAyB,CAC/D,IACJ,EAAe,SAAS,cAAc,QAAQ,CAC9C,EAAa,GAAK,yBAClB,EAAa,YAAc,EAC3B,SAAS,KAAK,YAAY,EAAa,EAIxC,IAAI,EAAa,EACb,EAAY,EACV,EAA4B,EAAE,CAC9B,EAAgC,EAAE,CAClC,EAAY,YAAY,KAAK,CAG7B,EAAU,SAAS,cAAc,MAAM,CAC7C,EAAQ,UAAY,kBACpB,EAAQ,OAAS,CAAC,EAElB,SAAS,EAAW,EAAsB,CAEzC,MAAO,KADW,EAAO,GAAa,KAAM,QAAQ,EAAE,CACpC,GAGnB,SAAS,GAAS,CACjB,IAAM,EAAW,GAAM,aAAa,CAC9B,EAAQ,MAAM,KAAK,EAAY,iBAAiB,kBAAkB,CAAC,CAEzE,EAAQ,UAAY;;;gEAG0C,IAAe,QAAQ;iEACtB,IAAe,SAAS;;;MAGnF,IAAe,QAAU,EAAe,EAAU,EAAM,CAAG,GAAiB,CAAC;;qCAE9C,EAAU;IAI7C,EAAQ,cAAc,iBAAiB,EAAE,iBAAiB,QAAS,EAAK,CAExE,EAAQ,iBAAiB,eAAe,CAAC,QAAQ,GAAO,CACvD,EAAI,iBAAiB,YAAe,CACnC,EAAc,EAAoB,QAAQ,IAC1C,GAAQ,EACP,EACD,CAGF,EAAQ,iBAAiB,kBAAkB,CAAC,QAAQ,GAAU,CAC7D,EAAO,iBAAiB,YAAe,CACtC,IAAM,EAAO,EAAuB,QAAQ,IACtC,EAAS,EAAc,KAAK,GAAK,EAAE,MAAQ,EAAI,CACjD,GAAU,EAAO,OAAS,YAC7B,EAAO,MAAQ,CAAC,EAAO,MACvB,EAAO,SAAS,EAAO,MAAM,CAC7B,GAAQ,GAER,EACD,CAGF,EAAQ,iBAAiB,kBAAkB,CAAC,QAAQ,GAAU,CAC7D,EAAO,iBAAiB,SAAW,GAAM,CACxC,IAAM,EAAO,EAAuB,QAAQ,IACtC,EAAS,EAAc,KAAK,GAAK,EAAE,MAAQ,EAAI,CACjD,GAAU,EAAO,OAAS,UAAY,EAAO,WAChD,EAAO,MAAS,EAAE,OAA6B,MAC/C,EAAO,SAAS,EAAO,MAAM,GAE7B,EACD,CAGF,EAAQ,iBAAiB,sBAAsB,CAAC,QAAQ,GAAO,CAC9D,EAAI,iBAAiB,YAAe,CACnC,IAAM,EAAO,EAAoB,QAAQ,IACnC,EAAS,EAAc,KAAK,GAAK,EAAE,MAAQ,EAAI,CACjD,GAAU,EAAO,OAAS,UAAY,EAAO,UAChD,EAAO,UAAU,EAEjB,EACD,CAGH,SAAS,EAAe,EAAgC,EAA8B,CACrF,GAAI,CAAC,EAAU,MAAO,uDAEtB,IAAM,EAAW,GAAM,QAAU,eAAiB,GAAM,aAAa,OAAS,OACxE,EAAW,GAAM,QAAU,eAAiB,GAAM,aAAa,OAAS,SACxE,EAAc,GAAM,YAE1B,MAAO;KACJ,EAAO;;;;;;yCAM6B,GAAM,OAAS,UAAU;;;;yCAIzB,EAAW,WAAa,EAAW,WAAa,SAAS,EAAc,KAAK,EAAY,KAAK,GAAK,GAAG;;OAEvI,EAAc;;;yCAGoB,EAAY,QAAU,IAAI;;OAE1D,GAAG;;;yCAG6B,GAAM,cAAc,SAAS,SAAW,GAAM,cAAc,IAAM,OAAO;;;;KAI3G,GAAG;;;;;;yCAM+B,EAAS,QAAQ,OAAO;;;;yCAIxB,EAAS,KAAK,OAAO;;;;yCAIrB,KAAK,MAAM,EAAS,UAAU,CAAC;;;;yCAI/B,KAAK,MAAM,EAAS,WAAW,CAAC;;;;yCAIhC,EAAS,IAAI;;;;yCAIb,EAAM,OAAO;;;;;;;OAO/C,EAAM,IAAI,GAAQ,CACnB,IAAM,EAAO,EAAY,EAAK,CACxB,EAAK,EAAK,QAAQ,SAAW,EAAK,QAAQ,IAAM,EAAK,IAAM,IAC3D,EAAU,EAAK,aAAa,mBAAmB,EAAI,IACnD,EAAU,EAAK,aAAa,mBAAmB,EAAI,IACzD,MAAO;;wCAE2B,EAAG;6CACE,EAAK,OAAO,QAAQ,EAAK,IAAI,IAAI,EAAQ,GAAG,EAAQ;;SAG1F,CAAC,KAAK,GAAG,CAAC;;;;;;OAMV,EAAS,SAAW,EAAI,+CAAiD,GAAG;OAC5E,EAAS,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,GAAS;;0CAER,EAAW,EAAM,KAAK,CAAC;0CACvB,EAAM,KAAK;4CACT,EAAM,OAAO;;OAElD,CAAC,KAAK,GAAG,CAAC;;;IAMhB,SAAS,GAA0B,CAClC,GAAI,EAAc,SAAW,EAC5B,MAAO,+IAGR,IAAM,EAAU,EAAc,OAAO,GAAK,EAAE,OAAS,UAAU,CACzD,EAAU,EAAc,OAAO,GAAK,EAAE,OAAS,SAAS,CACxD,EAAU,EAAc,OAAO,GAAK,EAAE,OAAS,SAAS,CAE9D,MAAO;;;MAGH,EAAQ,IAAI,GAAU;;2CAEe,EAAO,MAAM;8CACV,EAAO,IAAI,kBAAkB,EAAO,MAAM;;MAElF,CAAC,KAAK,GAAG,CAAC;MACV,EAAQ,IAAI,GAAU;;2CAEe,EAAO,MAAM;iDACP,EAAO,IAAI;UAClD,EAAO,SAAW,EAAE,EAAE,IAAI,GAAO,kBAAkB,EAAI,GAAG,IAAQ,EAAO,MAAQ,YAAc,GAAG,GAAG,EAAI,WAAW,CAAC,KAAK,GAAG,CAAC;;;MAGlI,CAAC,KAAK,GAAG,CAAC;;KAEX,EAAQ,OAAS,EAAI;;;OAGnB,EAAQ,IAAI,GAAU;;4CAEe,EAAO,MAAM;sDACH,EAAO,IAAI;;OAE1D,CAAC,KAAK,GAAG,CAAC;;KAEV,GAAG;IAIT,SAAS,EAAS,EAAc,EAAgB,CAC/C,EAAS,KAAK,CAAE,KAAM,YAAY,KAAK,CAAE,OAAM,SAAQ,CAAC,CACpD,EAAS,OAAS,KACrB,EAAS,OAAO,CAEb,GAAa,IAAe,SAC/B,GAAQ,CAIV,SAAS,GAAO,CACf,EAAY,GACZ,EAAQ,OAAS,GACjB,GAAQ,CAGT,SAAS,GAAO,CACf,EAAY,GACZ,EAAQ,OAAS,GAGlB,SAAS,GAAS,CACb,EACH,GAAM,CAEN,GAAM,CAIR,SAAS,EAAe,EAAsB,CAC7C,IAAM,EAAW,EAAc,UAAU,GAAK,EAAE,MAAQ,EAAO,IAAI,CAC/D,GAAY,EACf,EAAc,GAAY,EAE1B,EAAc,KAAK,EAAO,CAEvB,GACH,GAAQ,CAKV,IAAM,EAAe,GAAa,CACjC,IAAM,EAAU,EAAkB,OAElC,EAAS,aAAc,GADZ,EAAO,MAAM,SAAS,SAAW,EAAO,MAAM,SAAS,IAAM,EAAO,MAAM,IAAM,IAC9D,OAAO,EAAO,KAAK,OAAO,IAAI,EAAO,KAAK,IAAI,GAAG,EAGzE,EAAc,GAAa,CAChC,IAAM,EAAU,EAAkB,OAElC,EAAS,YAAa,GADX,EAAO,MAAM,SAAS,SAAW,EAAO,MAAM,SAAS,IAAM,EAAO,MAAM,IAAM,IAC/D,MAAM,EAAO,KAAK,OAAO,IAAI,EAAO,KAAK,IAAI,GAAG,EAGvE,EAAa,GAAa,CAC/B,IAAM,EAAU,EAAkB,OAElC,EAAS,WAAY,GADV,EAAO,MAAM,SAAS,SAAW,EAAO,MAAM,SAAS,IAAM,EAAO,MAAM,IAAM,IAChE,OAAO,EAAO,KAAK,OAAO,IAAI,EAAO,KAAK,IAAI,GAAG,EAGvE,EAAgB,GAAa,CAClC,IAAM,EAAU,EAAkB,OAElC,EAAS,cADE,EAAO,MAAM,SAAS,SAAW,EAAO,MAAM,SAAS,IAAM,EAAO,MAAM,IAAM,IAChE,EAGtB,EAAY,GAAa,CAC9B,IAAM,EAAU,EAAkB,OAElC,EAAS,SADE,EAAO,MAAM,SAAS,SAAW,EAAO,MAAM,SAAS,IAAM,EAAO,MAAM,IAAM,IACrE,EAGjB,EAAc,GAAa,CAChC,IAAM,EAAU,EAAkB,OAElC,EAAS,WADE,EAAO,MAAM,SAAS,SAAW,EAAO,MAAM,SAAS,IAAM,EAAO,MAAM,IAAM,OACnE,EAGnB,EAAa,GAAqB,CACnC,EAAE,MAAQ,GAAa,EAAE,UAAY,CAAC,EAAE,SAAW,CAAC,EAAE,QAAU,CAAC,EAAE,UACtE,EAAE,gBAAgB,CAClB,GAAQ,GAKV,EAAY,iBAAiB,iBAAkB,EAAY,CAC3D,EAAY,iBAAiB,gBAAiB,EAAW,CACzD,EAAY,iBAAiB,eAAgB,EAAU,CACvD,EAAY,iBAAiB,kBAAmB,EAAa,CAC7D,EAAY,iBAAiB,aAAc,EAAS,CACpD,EAAY,iBAAiB,eAAgB,EAAW,CACxD,SAAS,iBAAiB,UAAW,EAAU,CAG/C,SAAS,KAAK,YAAY,EAAQ,CAClC,GAAQ,CAER,SAAS,GAAU,CAClB,EAAY,oBAAoB,iBAAkB,EAAY,CAC9D,EAAY,oBAAoB,gBAAiB,EAAW,CAC5D,EAAY,oBAAoB,eAAgB,EAAU,CAC1D,EAAY,oBAAoB,kBAAmB,EAAa,CAChE,EAAY,oBAAoB,aAAc,EAAS,CACvD,EAAY,oBAAoB,eAAgB,EAAW,CAC3D,SAAS,oBAAoB,UAAW,EAAU,CAClD,EAAQ,QAAQ,CAGjB,MAAO,CAAE,SAAQ,OAAM,OAAM,iBAAgB,UAAS"}