{"version":3,"file":"resize.min.js","names":[],"sources":["../engine.ts","../plugins/resize.ts"],"sourcesContent":["import type { GridCell, EggCore, InitOptions, StyleManager } from './types';\nimport { createStateMachine } from './state-machine';\nimport { attachPointer } from './plugins/pointer';\nimport { attachKeyboard } from './plugins/keyboard';\nimport { attachAccessibility } from './plugins/accessibility';\nimport { attachResize } from './plugins/resize';\nimport { attachCamera } from './plugins/camera';\nimport { attachPlaceholder } from './plugins/placeholder';\nimport { attachPushAlgorithm } from './plugins/algorithm-push';\nimport { attachReorderAlgorithm } from './plugins/algorithm-reorder';\nimport { attachResponsive } from './plugins/responsive';\n\n/**\n * Initialize EG Grid on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): EggCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\t// Create centralized state machine\n\tconst stateMachine = createStateMachine();\n\n\t// Track selected element (state machine stores itemId, we need the element)\n\tlet selectedElement: HTMLElement | null = null;\n\n\t// StyleManager: single style element, multiple named layers\n\tconst styleLayers = new Map<string, string>(); // layer name → CSS\n\tconst layerOrder: string[] = []; // insertion order\n\tconst managedStyleElement = styleElement ?? document.createElement('style');\n\tif (!styleElement) {\n\t\tdocument.head.appendChild(managedStyleElement);\n\t\tcleanups.push(() => managedStyleElement.remove());\n\t}\n\n\t// Pre-populate 'base' layer with any existing content (e.g. server-rendered CSS)\n\tconst existingCSS = managedStyleElement.textContent?.trim();\n\tif (existingCSS) {\n\t\tstyleLayers.set('base', existingCSS);\n\t\tlayerOrder.push('base');\n\t}\n\n\tconst styles: StyleManager = {\n\t\tset(layer: string, css: string): void {\n\t\t\tif (!styleLayers.has(layer)) {\n\t\t\t\tlayerOrder.push(layer);\n\t\t\t}\n\t\t\tstyleLayers.set(layer, css);\n\t\t},\n\t\tget(layer: string): string {\n\t\t\treturn styleLayers.get(layer) ?? '';\n\t\t},\n\t\tclear(layer: string): void {\n\t\t\tif (styleLayers.has(layer)) {\n\t\t\t\tstyleLayers.set(layer, '');\n\t\t\t}\n\t\t},\n\t\tcommit(): void {\n\t\t\tconst parts: string[] = [];\n\t\t\tfor (const layer of layerOrder) {\n\t\t\t\tconst css = styleLayers.get(layer);\n\t\t\t\tif (css) parts.push(css);\n\t\t\t}\n\t\t\tmanagedStyleElement.textContent = parts.join('\\n\\n');\n\t\t},\n\t};\n\n\tconst core: EggCore = {\n\t\telement,\n\t\tstateMachine,\n\t\tstyles,\n\t\tcameraScrolling: false,\n\n\t\t// Selection state (backed by state machine)\n\t\tget selectedItem() {\n\t\t\treturn selectedElement;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedElement) return;\n\n\t\t\tconst previousItem = selectedElement;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-egg-selected');\n\t\t\t}\n\n\t\t\t// Update state machine and local element reference\n\t\t\tif (item) {\n\t\t\t\tconst itemId = item.id || item.getAttribute('data-egg-item') || '';\n\t\t\t\tstateMachine.transition({ type: 'SELECT', itemId, element: item });\n\t\t\t\tselectedElement = item;\n\t\t\t\titem.setAttribute('data-egg-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else {\n\t\t\t\tstateMachine.transition({ type: 'DESELECT' });\n\t\t\t\tselectedElement = null;\n\t\t\t\tif (previousItem) {\n\t\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`egg-${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Direct initialization — no registry, no loop\n\tif (options.pointer !== false) {\n\t\tcleanups.push(attachPointer(core));\n\t}\n\tif (options.keyboard !== false) {\n\t\tcleanups.push(attachKeyboard(core));\n\t}\n\tif (options.accessibility !== false) {\n\t\tcleanups.push(attachAccessibility(core));\n\t}\n\n\tif (options.resize !== false) {\n\t\tconst resizeOpts = typeof options.resize === 'object' ? options.resize : {};\n\t\tconst inst = attachResize(element, { ...resizeOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.camera !== false) {\n\t\tconst cameraOpts = typeof options.camera === 'object' ? options.camera : {};\n\t\tconst inst = attachCamera(element, { ...cameraOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.placeholder !== false) {\n\t\tconst placeholderOpts = typeof options.placeholder === 'object' ? options.placeholder : {};\n\t\tconst inst = attachPlaceholder(element, placeholderOpts);\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\t// Algorithm: push (default) or reorder\n\tif (options.algorithm !== false) {\n\t\tconst algoOpts = options.algorithmOptions ?? {};\n\t\tif (options.algorithm === 'reorder') {\n\t\t\tcleanups.push(attachReorderAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t} else {\n\t\t\tcleanups.push(attachPushAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t}\n\t}\n\n\tif (options.responsive) {\n\t\tcleanups.push(attachResponsive(element, options.responsive, core));\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Get the size of an item from its data attributes\n */\nexport function getItemSize(item: HTMLElement): { colspan: number; rowspan: number } {\n\treturn {\n\t\tcolspan: parseInt(item.getAttribute('data-egg-colspan') || '1', 10) || 1,\n\t\trowspan: parseInt(item.getAttribute('data-egg-rowspan') || '1', 10) || 1,\n\t};\n}\n\n/**\n * Attach multiple event listeners and return a cleanup function to remove them all\n */\nexport function listenEvents(\n\telement: EventTarget,\n\tevents: Record<string, EventListenerOrEventListenerObject>,\n): () => void {\n\tfor (const [name, handler] of Object.entries(events)) {\n\t\telement.addEventListener(name, handler);\n\t}\n\treturn () => {\n\t\tfor (const [name, handler] of Object.entries(events)) {\n\t\t\telement.removeEventListener(name, handler);\n\t\t}\n\t};\n}\n","/**\n * Resize plugin for EG Grid\n *\n * Pure input plugin — detects resize gestures on grid item corners/edges\n * and emits resize-start/move/end/cancel events. Does NOT persist layout.\n * A behavior plugin (e.g., Algorithm) listens for resize-end and handles persistence.\n *\n * Usage:\n *   import { attachResize } from 'eg-grid/resize';\n *\n *   const detach = attachResize(gridElement, {\n *     core,                 // EggCore instance (required)\n *     handles: 'corners',   // 'corners' | 'edges' | 'all'\n *     handleSize: 12,\n *     minSize: { colspan: 1, rowspan: 1 },\n *     maxSize: { colspan: 6, rowspan: 6 },\n *   });\n */\n\nimport { getItemSize } from '../engine';\nimport type {\n\tGridCell,\n\tEggCore,\n\tResizeCancelDetail,\n\tResizeEndDetail,\n\tResizeHandle,\n\tResizeMoveDetail,\n\tResizeStartDetail,\n} from '../types';\n\n\nexport interface ResizeOptions {\n\t/** EggCore instance (required) */\n\tcore: EggCore;\n\t/** Which handles to show: 'corners' | 'edges' | 'all' (default: 'corners') */\n\thandles?: 'corners' | 'edges' | 'all';\n\t/** Size of the hit zone for handles in pixels (default: 12) */\n\thandleSize?: number;\n\t/** Minimum size in grid cells (default: { colspan: 1, rowspan: 1 }) */\n\tminSize?: { colspan: number; rowspan: number };\n\t/** Maximum size in grid cells (default: { colspan: 6, rowspan: 6 }) */\n\tmaxSize?: { colspan: number; rowspan: number };\n\t/** Show size label during resize (default: true) */\n\tshowSizeLabel?: boolean;\n}\n\ninterface ActiveResize {\n\titem: HTMLElement;\n\tpointerId: number;\n\thandle: ResizeHandle;\n\t/** Original cell position at start of resize - never changes */\n\tstartCell: GridCell;\n\t/** Original size at start of resize - never changes */\n\toriginalSize: { colspan: number; rowspan: number };\n\t/** Current position (may differ from startCell for NW/NE/SW handles) */\n\tcurrentCell: GridCell;\n\t/** Current size during resize */\n\tcurrentSize: { colspan: number; rowspan: number };\n\tsizeLabel: HTMLElement | null;\n\t/** Initial bounding rect for smooth resize */\n\tinitialRect: DOMRect;\n\t/** Pointer position at start */\n\tstartPointerX: number;\n\tstartPointerY: number;\n}\n\n\n/**\n * Detect which resize handle (if any) is under the pointer\n */\nfunction detectHandle(\n\te: PointerEvent,\n\titem: HTMLElement,\n\tsize: number,\n\tmode: 'corners' | 'edges' | 'all',\n): ResizeHandle | null {\n\tconst rect = item.getBoundingClientRect();\n\tconst x = e.clientX - rect.left;\n\tconst y = e.clientY - rect.top;\n\n\tconst nearLeft = x < size;\n\tconst nearRight = x > rect.width - size;\n\tconst nearTop = y < size;\n\tconst nearBottom = y > rect.height - size;\n\n\t// Corners\n\tif (mode === 'corners' || mode === 'all') {\n\t\tif (nearTop && nearLeft) return 'nw';\n\t\tif (nearTop && nearRight) return 'ne';\n\t\tif (nearBottom && nearLeft) return 'sw';\n\t\tif (nearBottom && nearRight) return 'se';\n\t}\n\n\t// Edges (only if not at corners)\n\tif (mode === 'edges' || mode === 'all') {\n\t\tif (nearTop) return 'n';\n\t\tif (nearBottom) return 's';\n\t\tif (nearLeft) return 'w';\n\t\tif (nearRight) return 'e';\n\t}\n\n\treturn null;\n}\n\nconst CURSOR: Record<string, string> = {\n\tnw: 'nwse-resize', se: 'nwse-resize',\n\tne: 'nesw-resize', sw: 'nesw-resize',\n\tn: 'ns-resize', s: 'ns-resize',\n\te: 'ew-resize', w: 'ew-resize',\n};\n\n/**\n * Create a size label element\n */\nfunction createSizeLabel(): HTMLElement {\n\tconst label = document.createElement('div');\n\tlabel.className = 'egg-resize-label';\n\tlabel.style.cssText = `\n\t\tposition: absolute;\n\t\ttop: 50%;\n\t\tleft: 50%;\n\t\ttransform: translate(-50%, -50%);\n\t\tbackground: rgba(0, 0, 0, 0.8);\n\t\tcolor: white;\n\t\tpadding: 4px 8px;\n\t\tborder-radius: 4px;\n\t\tfont-size: 14px;\n\t\tfont-weight: 600;\n\t\tfont-family: system-ui, sans-serif;\n\t\tpointer-events: none;\n\t\tz-index: 1000;\n\t\twhite-space: nowrap;\n\t`;\n\treturn label;\n}\n\n/**\n * Attach resize functionality to a grid element.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach resize\n */\nexport function attachResize(\n\tgridElement: HTMLElement,\n\toptions: ResizeOptions,\n): { destroy(): void } {\n\tconst {\n\t\tcore,\n\t\thandles = 'corners',\n\t\thandleSize = 12,\n\t\tminSize = { colspan: 1, rowspan: 1 },\n\t\tmaxSize = { colspan: 6, rowspan: 6 },\n\t\tshowSizeLabel = true,\n\t} = options;\n\n\tlet activeResize: ActiveResize | null = null;\n\tlet hoveredItem: HTMLElement | null = null;\n\tlet hoveredHandle: ResizeHandle | null = null;\n\n\tfunction emit<T>(event: string, detail: T): void {\n\t\tgridElement.dispatchEvent(\n\t\t\tnew CustomEvent(`egg-${event}`, {\n\t\t\t\tbubbles: true,\n\t\t\t\tdetail,\n\t\t\t}),\n\t\t);\n\t}\n\n\tfunction startResize(item: HTMLElement, handle: ResizeHandle, e: PointerEvent) {\n\t\tconst { colspan, rowspan } = getItemSize(item);\n\n\t\tconst style = getComputedStyle(item);\n\t\tconst column = parseInt(style.gridColumnStart, 10) || 1;\n\t\tconst row = parseInt(style.gridRowStart, 10) || 1;\n\n\t\tconst originalSize = { colspan, rowspan };\n\t\tconst startCell = { column, row };\n\t\tconst initialRect = item.getBoundingClientRect();\n\n\t\t// Create size label if enabled\n\t\tlet sizeLabel: HTMLElement | null = null;\n\t\tif (showSizeLabel) {\n\t\t\tsizeLabel = createSizeLabel();\n\t\t\tsizeLabel.textContent = `${colspan}×${rowspan}`;\n\t\t\titem.appendChild(sizeLabel);\n\t\t}\n\n\t\tactiveResize = {\n\t\t\titem,\n\t\t\tpointerId: e.pointerId,\n\t\t\thandle,\n\t\t\tstartCell,\n\t\t\toriginalSize,\n\t\t\tcurrentCell: { ...startCell },\n\t\t\tcurrentSize: { ...originalSize },\n\t\t\tsizeLabel,\n\t\t\tinitialRect,\n\t\t\tstartPointerX: e.clientX,\n\t\t\tstartPointerY: e.clientY,\n\t\t};\n\n\t\titem.setAttribute('data-egg-resizing', '');\n\t\titem.setAttribute('data-egg-handle-active', handle);\n\t\titem.removeAttribute('data-egg-handle-hover'); // Clear hover state\n\t\titem.setPointerCapture(e.pointerId);\n\n\t\t// Add event listeners to item (pointer capture sends events to this element)\n\t\titem.addEventListener('pointermove', onItemPointerMove);\n\t\titem.addEventListener('pointerup', onItemPointerUp);\n\t\titem.addEventListener('pointercancel', onItemPointerCancel);\n\n\t\t// Transition state machine to interacting\n\t\tconst itemId = item.id || item.getAttribute('data-egg-item') || '';\n\t\tcore.stateMachine.transition({\n\t\t\ttype: 'START_INTERACTION',\n\t\t\tcontext: { type: 'resize', mode: 'pointer', itemId, element: item, columnCount: core.getGridInfo().columns.length },\n\t\t});\n\n\t\t// Emit resize-start BEFORE changing grid styles so originalPositions captures correct layout\n\t\temit<ResizeStartDetail>('resize-start', {\n\t\t\titem,\n\t\t\tcell: startCell,\n\t\t\tcolspan: originalSize.colspan,\n\t\t\trowspan: originalSize.rowspan,\n\t\t\thandle,\n\t\t\tsource: 'pointer',\n\t\t});\n\n\t\t// Switch to fixed positioning - item follows cursor in viewport coordinates\n\t\t// CSS Grid ignores fixed positioned children, allowing the grid to reflow\n\t\titem.style.position = 'fixed';\n\t\titem.style.left = `${initialRect.left}px`;\n\t\titem.style.top = `${initialRect.top}px`;\n\t\titem.style.width = `${initialRect.width}px`;\n\t\titem.style.height = `${initialRect.height}px`;\n\t\titem.style.zIndex = '100';\n\t\t// Exclude from view transitions during resize\n\t\titem.style.viewTransitionName = 'resizing';\n\t}\n\n\tfunction updateResize(e: PointerEvent) {\n\t\tif (!activeResize) return;\n\n\t\tconst { item, handle, startCell, originalSize, currentCell, currentSize, sizeLabel, initialRect, startPointerX, startPointerY } =\n\t\t\tactiveResize;\n\n\t\tconst gridInfo = core.getGridInfo();\n\n\t\t// Calculate pointer delta\n\t\tconst deltaX = e.clientX - startPointerX;\n\t\tconst deltaY = e.clientY - startPointerY;\n\n\t\t// Calculate new visual dimensions based on handle\n\t\tlet newWidth = initialRect.width;\n\t\tlet newHeight = initialRect.height;\n\t\tlet newLeft = initialRect.left;\n\t\tlet newTop = initialRect.top;\n\n\t\t// Minimum visual size (1 cell)\n\t\tconst minWidth = gridInfo.cellWidth;\n\t\tconst minHeight = gridInfo.cellHeight;\n\t\t// Maximum visual size (clamped by maxSize config)\n\t\tconst maxWidthByConfig = maxSize.colspan * gridInfo.cellWidth + (maxSize.colspan - 1) * gridInfo.gap;\n\t\tconst maxHeightByConfig = maxSize.rowspan * gridInfo.cellHeight + (maxSize.rowspan - 1) * gridInfo.gap;\n\t\t// Maximum visual size (clamped by grid bounds)\n\t\tconst maxWidthByGrid = gridInfo.rect.right - initialRect.left;\n\t\tconst maxHeightByGrid = gridInfo.rect.bottom - initialRect.top;\n\t\tconst maxWidth = Math.min(maxWidthByConfig, maxWidthByGrid);\n\t\tconst maxHeight = Math.min(maxHeightByConfig, maxHeightByGrid);\n\n\t\t// Apply delta based on handle direction\n\t\tif (handle === 'e' || handle === 'se' || handle === 'ne') {\n\t\t\tnewWidth = Math.max(minWidth, Math.min(maxWidth, initialRect.width + deltaX));\n\t\t}\n\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t\t// For left edge, clamp to grid left\n\t\t\tconst maxLeftShift = initialRect.left - gridInfo.rect.left;\n\t\t\tconst maxWidthFromLeft = Math.min(maxWidthByConfig, initialRect.width + maxLeftShift);\n\t\t\tconst widthChange = Math.max(-initialRect.width + minWidth, Math.min(maxWidthFromLeft - initialRect.width, -deltaX));\n\t\t\tnewWidth = initialRect.width + widthChange;\n\t\t\tnewLeft = initialRect.left - widthChange;\n\t\t}\n\t\tif (handle === 's' || handle === 'se' || handle === 'sw') {\n\t\t\tnewHeight = Math.max(minHeight, Math.min(maxHeight, initialRect.height + deltaY));\n\t\t}\n\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t\t// For top edge, clamp to grid top\n\t\t\tconst maxTopShift = initialRect.top - gridInfo.rect.top;\n\t\t\tconst maxHeightFromTop = Math.min(maxHeightByConfig, initialRect.height + maxTopShift);\n\t\t\tconst heightChange = Math.max(-initialRect.height + minHeight, Math.min(maxHeightFromTop - initialRect.height, -deltaY));\n\t\t\tnewHeight = initialRect.height + heightChange;\n\t\t\tnewTop = initialRect.top - heightChange;\n\t\t}\n\n\t\t// Apply smooth visual size (fixed positioning uses viewport coordinates)\n\t\titem.style.left = `${newLeft}px`;\n\t\titem.style.top = `${newTop}px`;\n\t\titem.style.width = `${newWidth}px`;\n\t\titem.style.height = `${newHeight}px`;\n\n\t\t// Calculate projected final grid size (what it will snap to)\n\t\tconst cellPlusGap = gridInfo.cellWidth + gridInfo.gap;\n\t\tconst rowPlusGap = gridInfo.cellHeight + gridInfo.gap;\n\n\t\t// Calculate raw ratios\n\t\tconst rawColspanRatio = (newWidth + gridInfo.gap) / cellPlusGap;\n\t\tconst rawRowspanRatio = (newHeight + gridInfo.gap) / rowPlusGap;\n\n\t\t// Snap when 30% into the next cell (works symmetrically for grow and shrink)\n\t\tconst RESIZE_SNAP = 0.3;\n\t\tlet projectedColspan = Math.floor(rawColspanRatio + (1 - RESIZE_SNAP));\n\t\tlet projectedRowspan = Math.floor(rawRowspanRatio + (1 - RESIZE_SNAP));\n\n\t\t// Apply min/max constraints\n\t\tprojectedColspan = Math.max(minSize.colspan, Math.min(maxSize.colspan, projectedColspan));\n\t\tprojectedRowspan = Math.max(minSize.rowspan, Math.min(maxSize.rowspan, projectedRowspan));\n\n\t\t// Calculate cell position: anchor corner stays fixed, opposite edge moves\n\t\tlet projectedColumn = startCell.column;\n\t\tlet projectedRow = startCell.row;\n\n\t\t// For handles that move the left edge, calculate column from the right anchor\n\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t\tconst rightEdge = startCell.column + originalSize.colspan - 1;\n\t\t\tprojectedColumn = rightEdge - projectedColspan + 1;\n\t\t}\n\n\t\t// For handles that move the top edge, calculate row from the bottom anchor\n\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t\tconst bottomEdge = startCell.row + originalSize.rowspan - 1;\n\t\t\tprojectedRow = bottomEdge - projectedRowspan + 1;\n\t\t}\n\n\t\t// Update tracking\n\t\tactiveResize.currentSize = { colspan: projectedColspan, rowspan: projectedRowspan };\n\t\tactiveResize.currentCell = { column: projectedColumn, row: projectedRow };\n\n\t\t// Update size label with projected final size\n\t\tif (sizeLabel) {\n\t\t\tsizeLabel.textContent = `${projectedColspan}×${projectedRowspan}`;\n\t\t}\n\n\t\t// Calculate anchor cell (the corner that stays fixed during resize)\n\t\tlet anchorCell: GridCell;\n\t\tif (handle === 'se' || handle === 's' || handle === 'e') {\n\t\t\t// NW corner is anchor\n\t\t\tanchorCell = { column: startCell.column, row: startCell.row };\n\t\t} else if (handle === 'nw' || handle === 'n' || handle === 'w') {\n\t\t\t// SE corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column + originalSize.colspan - 1,\n\t\t\t\trow: startCell.row + originalSize.rowspan - 1,\n\t\t\t};\n\t\t} else if (handle === 'ne') {\n\t\t\t// SW corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column,\n\t\t\t\trow: startCell.row + originalSize.rowspan - 1,\n\t\t\t};\n\t\t} else {\n\t\t\t// SW handle: NE corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column + originalSize.colspan - 1,\n\t\t\t\trow: startCell.row,\n\t\t\t};\n\t\t}\n\n\t\temit<ResizeMoveDetail>('resize-move', {\n\t\t\titem,\n\t\t\tcell: { column: projectedColumn, row: projectedRow },\n\t\t\tanchorCell,\n\t\t\tstartCell,\n\t\t\tcolspan: projectedColspan,\n\t\t\trowspan: projectedRowspan,\n\t\t\thandle,\n\t\t\tsource: 'pointer',\n\t\t});\n\t}\n\n\tfunction cleanupResizeListeners(item: HTMLElement, pointerId: number) {\n\t\titem.releasePointerCapture(pointerId);\n\t\titem.removeEventListener('pointermove', onItemPointerMove);\n\t\titem.removeEventListener('pointerup', onItemPointerUp);\n\t\titem.removeEventListener('pointercancel', onItemPointerCancel);\n\t}\n\n\tfunction resetItem(item: HTMLElement, pointerId: number, sizeLabel: HTMLElement | null) {\n\t\tcleanupResizeListeners(item, pointerId);\n\t\tif (sizeLabel) sizeLabel.remove();\n\t\titem.style.position = '';\n\t\titem.style.left = '';\n\t\titem.style.top = '';\n\t\titem.style.width = '';\n\t\titem.style.height = '';\n\t\titem.style.zIndex = '';\n\t\tconst itemId = item.style.getPropertyValue('--item-id') || item.dataset.eggItem || item.id || item.dataset.id;\n\t\titem.style.viewTransitionName = itemId || '';\n\t\titem.removeAttribute('data-egg-resizing');\n\t\titem.removeAttribute('data-egg-handle-active');\n\t}\n\n\tfunction finishResize() {\n\t\tif (!activeResize) return;\n\t\tconst { item, pointerId, currentSize, currentCell, sizeLabel } = activeResize;\n\t\titem.setAttribute('data-egg-colspan', String(currentSize.colspan));\n\t\titem.setAttribute('data-egg-rowspan', String(currentSize.rowspan));\n\t\tcore.stateMachine.transition({ type: 'COMMIT_INTERACTION' });\n\t\temit<ResizeEndDetail>('resize-end', {\n\t\t\titem, cell: currentCell,\n\t\t\tcolspan: currentSize.colspan, rowspan: currentSize.rowspan,\n\t\t\tsource: 'pointer',\n\t\t});\n\t\tresetItem(item, pointerId, sizeLabel);\n\t\tactiveResize = null;\n\t\tcore.stateMachine.transition({ type: 'FINISH_COMMIT' });\n\t}\n\n\tfunction cancelResize() {\n\t\tif (!activeResize) return;\n\t\tconst { item, pointerId, sizeLabel } = activeResize;\n\t\temit<ResizeCancelDetail>('resize-cancel', { item, source: 'pointer' });\n\t\tcore.stateMachine.transition({ type: 'CANCEL_INTERACTION' });\n\t\tresetItem(item, pointerId, sizeLabel);\n\t\tactiveResize = null;\n\t}\n\n\t// --- Event handlers ---\n\n\t// Use capture phase to intercept before pointer plugin\n\tconst onPointerDown = (e: PointerEvent) => {\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-egg-item]',\n\t\t) as HTMLElement | null;\n\t\tif (!item) return;\n\n\t\tconst handle = detectHandle(e, item, handleSize, handles);\n\t\tif (!handle) return; // Not on handle - let pointer plugin handle drag\n\n\t\t// Stop event from reaching pointer plugin\n\t\te.stopPropagation();\n\t\te.preventDefault();\n\n\t\t// Select the item (resize captures before pointer plugin, so pointer's select never fires)\n\t\tcore.select(item);\n\n\t\tstartResize(item, handle, e);\n\t};\n\n\t// Item-specific handlers (added during resize, removed on finish/cancel)\n\tconst onItemPointerMove = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tupdateResize(e);\n\t\t}\n\t};\n\n\tconst onItemPointerUp = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tfinishResize();\n\t\t}\n\t};\n\n\tconst onItemPointerCancel = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tcancelResize();\n\t\t}\n\t};\n\n\t// Grid-level hover handler for cursor changes and handle hover state\n\tconst onPointerMove = (e: PointerEvent) => {\n\t\t// Skip hover handling during active resize\n\t\tif (activeResize) return;\n\n\t\t// Handle hover cursor changes\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-egg-item]',\n\t\t) as HTMLElement | null;\n\n\t\tif (item) {\n\t\t\tconst handle = detectHandle(e, item, handleSize, handles);\n\n\t\t\tif (handle !== hoveredHandle || item !== hoveredItem) {\n\t\t\t\t// Clear previous item's hover state\n\t\t\t\tif (hoveredItem && hoveredItem !== item) {\n\t\t\t\t\thoveredItem.style.cursor = '';\n\t\t\t\t\thoveredItem.removeAttribute('data-egg-handle-hover');\n\t\t\t\t}\n\n\t\t\t\t// Clear hover attribute if handle changed on same item\n\t\t\t\tif (hoveredItem === item && hoveredHandle && !handle) {\n\t\t\t\t\titem.removeAttribute('data-egg-handle-hover');\n\t\t\t\t}\n\n\t\t\t\thoveredItem = item;\n\t\t\t\thoveredHandle = handle;\n\n\t\t\t\t// Set cursor and hover attribute based on handle\n\t\t\t\titem.style.cursor = (handle ? CURSOR[handle] : '') || '';\n\t\t\t\tif (handle) {\n\t\t\t\t\titem.setAttribute('data-egg-handle-hover', handle);\n\t\t\t\t} else {\n\t\t\t\t\titem.removeAttribute('data-egg-handle-hover');\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (hoveredItem) {\n\t\t\thoveredItem.style.cursor = '';\n\t\t\thoveredItem.removeAttribute('data-egg-handle-hover');\n\t\t\thoveredItem = null;\n\t\t\thoveredHandle = null;\n\t\t}\n\t};\n\n\tconst onKeyDown = (e: KeyboardEvent) => {\n\t\tif (e.key === 'Escape' && activeResize) {\n\t\t\tcancelResize();\n\t\t}\n\t};\n\n\t// Register event listeners\n\tgridElement.addEventListener('pointerdown', onPointerDown, { capture: true });\n\tgridElement.addEventListener('pointermove', onPointerMove);\n\tdocument.addEventListener('keydown', onKeyDown);\n\n\tfunction destroy() {\n\t\tgridElement.removeEventListener('pointerdown', onPointerDown, {\n\t\t\tcapture: true,\n\t\t});\n\t\tgridElement.removeEventListener('pointermove', onPointerMove);\n\t\tdocument.removeEventListener('keydown', onKeyDown);\n\n\t\tif (activeResize) {\n\t\t\tcancelResize();\n\t\t}\n\t}\n\n\treturn { destroy };\n}\n\nexport type { ResizeHandle };\n"],"mappings":"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"}