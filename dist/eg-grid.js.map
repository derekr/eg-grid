{"version":3,"file":"eg-grid.js","names":[],"sources":["../src/state-machine.ts","../src/utils/flip.ts","../src/plugins/pointer.ts","../src/plugins/keyboard.ts","../src/plugins/accessibility.ts","../src/plugins/resize.ts","../src/plugins/camera.ts","../src/plugins/placeholder.ts","../src/plugins/algorithm-harness.ts","../src/plugins/algorithm-push.ts","../src/plugins/algorithm-reorder.ts","../src/plugins/responsive.ts","../src/engine.ts","../src/layout-model.ts"],"sourcesContent":["/**\n * Centralized State Machine for EG Grid\n *\n * Single source of truth for interaction state.\n *\n * Key invariants:\n * 1. Only ONE interaction can be active at a time (drag OR resize, not both)\n * 2. Column count is captured at interaction start and immutable during interaction\n * 3. Phases: idle → selected → interacting → committing → selected\n */\n\n// ============================================================================\n// State Types\n// ============================================================================\n\nexport type InteractionMode = 'pointer' | 'keyboard';\n\nexport type InteractionType = 'drag' | 'resize';\n\nexport type EggPhase =\n\t| 'idle'\n\t| 'selected'\n\t| 'interacting'  // Active drag or resize\n\t| 'committing';  // Saving to layout model, clearing preview\n\nexport interface InteractionContext {\n\t/** The type of interaction (drag or resize) */\n\ttype: InteractionType;\n\t/** How the interaction was initiated */\n\tmode: InteractionMode;\n\t/** The item being interacted with */\n\titemId: string;\n\t/** The DOM element being interacted with */\n\telement: HTMLElement;\n\t/** Column count at interaction start (immutable during interaction) */\n\tcolumnCount: number;\n}\n\nexport interface EggState {\n\tphase: EggPhase;\n\tselectedItemId: string | null;\n\tinteraction: InteractionContext | null;\n}\n\n// ============================================================================\n// State Machine\n// ============================================================================\n\nexport type StateTransition =\n\t| { type: 'SELECT'; itemId: string; element: HTMLElement }\n\t| { type: 'DESELECT' }\n\t| { type: 'START_INTERACTION'; context: InteractionContext }\n\t| { type: 'COMMIT_INTERACTION' }\n\t| { type: 'CANCEL_INTERACTION' }\n\t| { type: 'FINISH_COMMIT' };\n\nexport interface EggStateMachine {\n\tgetState(): EggState;\n\ttransition(action: StateTransition): EggState;\n}\n\nfunction reducer(state: EggState, action: StateTransition): EggState {\n\tswitch (action.type) {\n\t\tcase 'SELECT': {\n\t\t\tif (state.phase !== 'idle' && state.phase !== 'selected') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'selected',\n\t\t\t\tselectedItemId: action.itemId,\n\t\t\t};\n\t\t}\n\n\t\tcase 'DESELECT': {\n\t\t\tif (state.phase !== 'selected') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'idle',\n\t\t\t\tselectedItemId: null,\n\t\t\t};\n\t\t}\n\n\t\tcase 'START_INTERACTION': {\n\t\t\tif (state.phase !== 'selected') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'interacting',\n\t\t\t\tinteraction: action.context,\n\t\t\t};\n\t\t}\n\n\t\tcase 'COMMIT_INTERACTION': {\n\t\t\tif (state.phase !== 'interacting') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'committing',\n\t\t\t};\n\t\t}\n\n\t\tcase 'CANCEL_INTERACTION': {\n\t\t\tif (state.phase !== 'interacting') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'selected',\n\t\t\t\tinteraction: null,\n\t\t\t};\n\t\t}\n\n\t\tcase 'FINISH_COMMIT': {\n\t\t\tif (state.phase !== 'committing') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'selected',\n\t\t\t\tinteraction: null,\n\t\t\t};\n\t\t}\n\n\t\tdefault:\n\t\t\treturn state;\n\t}\n}\n\n/**\n * Create a state machine instance\n */\nexport function createStateMachine(): EggStateMachine {\n\tlet state: EggState = {\n\t\tphase: 'idle',\n\t\tselectedItemId: null,\n\t\tinteraction: null,\n\t};\n\n\treturn {\n\t\tgetState() {\n\t\t\treturn state;\n\t\t},\n\n\t\ttransition(action: StateTransition) {\n\t\t\tconst nextState = reducer(state, action);\n\t\t\tif (nextState !== state) {\n\t\t\t\tstate = nextState;\n\t\t\t}\n\t\t\treturn state;\n\t\t},\n\t};\n}\n\nexport function isDragging(state: EggState): boolean {\n\treturn (state.phase === 'interacting' || state.phase === 'committing') && state.interaction?.type === 'drag';\n}\n\nexport function isResizing(state: EggState): boolean {\n\treturn (state.phase === 'interacting' || state.phase === 'committing') && state.interaction?.type === 'resize';\n}\n","/**\n * FLIP Animation Utility\n *\n * Provides shared FLIP (First, Last, Invert, Play) animation utilities\n * used by pointer and resize plugins for smooth position/scale transitions.\n */\n\nexport interface FLIPOptions {\n\tduration?: number;\n\teasing?: string;\n\tonStart?: () => void;\n\tonFinish?: () => void;\n}\n\n/**\n * Animate an element from its previous position/size to its new position/size using FLIP.\n *\n * @param element - The element to animate\n * @param firstRect - The element's bounding rect before the DOM change (the \"First\" in FLIP)\n * @param options - Animation options\n * @returns The Animation object, or null if no animation was needed\n *\n * @example\n * ```ts\n * // Capture position before DOM change\n * const firstRect = element.getBoundingClientRect();\n *\n * // Make DOM changes (e.g., update grid position)\n * element.style.gridColumn = '2 / span 2';\n *\n * // Animate from old position to new\n * requestAnimationFrame(() => {\n *   animateFLIP(element, firstRect);\n * });\n * ```\n */\nexport function animateFLIP(\n\telement: HTMLElement,\n\tfirstRect: DOMRect,\n\toptions: FLIPOptions = {},\n): Animation | null {\n\tconst {\n\t\tduration = 200,\n\t\teasing = 'cubic-bezier(0.2, 0, 0, 1)',\n\t\tonStart,\n\t\tonFinish,\n\t} = options;\n\n\tconst lastRect = element.getBoundingClientRect();\n\tconst deltaX = firstRect.left - lastRect.left;\n\tconst deltaY = firstRect.top - lastRect.top;\n\n\tif (Math.abs(deltaX) <= 1 && Math.abs(deltaY) <= 1) {\n\t\tonFinish?.();\n\t\treturn null;\n\t}\n\n\tonStart?.();\n\n\tconst keyframes: Keyframe[] = [\n\t\t{ transform: `translate(${deltaX}px, ${deltaY}px)` },\n\t\t{ transform: 'translate(0, 0)' },\n\t];\n\n\t// Play the animation\n\tconst animation = element.animate(keyframes, {\n\t\tduration,\n\t\teasing,\n\t});\n\n\tanimation.onfinish = () => onFinish?.();\n\n\treturn animation;\n}\n\n/**\n * Get the item's view transition name from various sources.\n * Checks --item-id CSS property, id attribute, and data-id attribute.\n */\nexport function getItemViewTransitionName(element: HTMLElement): string | null {\n\treturn (\n\t\telement.style.getPropertyValue('--item-id') ||\n\t\telement.dataset.eggItem ||\n\t\telement.id ||\n\t\telement.dataset.id ||\n\t\tnull\n\t);\n}\n\n/**\n * FLIP animation with View Transition exclusion and data attribute tracking.\n */\nexport function animateFLIPWithTracking(\n\telement: HTMLElement,\n\tfirstRect: DOMRect,\n\toptions: FLIPOptions & { attributeName?: string } = {},\n): Animation | null {\n\tconst { attributeName = 'data-egg-dropping', ...flipOptions } = options;\n\n\t// Exclude from View Transitions\n\telement.style.viewTransitionName = 'none';\n\n\tconst animation = animateFLIP(element, firstRect, {\n\t\t...flipOptions,\n\t\tonStart: () => {\n\t\t\telement.setAttribute(attributeName, '');\n\t\t\tflipOptions.onStart?.();\n\t\t},\n\t\tonFinish: () => {\n\t\t\telement.removeAttribute(attributeName);\n\t\t\t// Restore view transition name\n\t\t\tconst itemId = getItemViewTransitionName(element);\n\t\t\tif (itemId) {\n\t\t\t\telement.style.viewTransitionName = itemId;\n\t\t\t}\n\t\t\tflipOptions.onFinish?.();\n\t\t},\n\t});\n\n\t// If no animation was needed, clean up immediately\n\tif (!animation) {\n\t\tconst itemId = getItemViewTransitionName(element);\n\t\tif (itemId) {\n\t\t\telement.style.viewTransitionName = itemId;\n\t\t}\n\t}\n\n\treturn animation;\n}\n","import { getItemCell, getItemSize } from '../engine';\nimport type { GridCell, EggCore } from '../types';\nimport { animateFLIPWithTracking } from '../utils/flip';\n\n// Hysteresis: distance in grid units before changing target cell\nconst HYSTERESIS = 0.4;\n// Minimum time (ms) between target changes to prevent jitter\nconst TARGET_CHANGE_DEBOUNCE = 40;\n// Minimum pixels of movement before starting a drag\nconst DRAG_THRESHOLD = 5;\n// Minimum pixels of cumulative movement before applying predictive offset\nconst PREDICTION_THRESHOLD = 30;\n// Fraction of cell to lead ahead when prediction is active (0.5 = half a cell)\nconst PREDICTION_LEAD = 0.5;\n\ninterface PendingDrag {\n\titem: HTMLElement;\n\tpointerId: number;\n\tstartX: number;\n\tstartY: number;\n\trect: DOMRect;\n\tstartCell: GridCell;\n\tcolspan: number;\n\trowspan: number;\n}\n\ninterface DragState {\n\titem: HTMLElement;\n\tpointerId: number;\n\toffsetX: number;\n\toffsetY: number;\n\tinitialRect: DOMRect;\n\tstartCell: GridCell;\n\tlastCell: GridCell;\n\tlastTargetChangeTime: number;\n\tcolspan: number;\n\trowspan: number;\n\t// For predictive placeholder\n\tdragStartX: number;\n\tdragStartY: number;\n}\n\n/**\n * Attach pointer (mouse/touch) drag handling to a EggCore instance.\n * @returns Cleanup function\n */\nexport function attachPointer(core: EggCore): () => void {\n\tlet pendingDrag: PendingDrag | null = null;\n\tlet dragState: DragState | null = null;\n\n\tconst startDrag = (pending: PendingDrag, e: PointerEvent) => {\n\t\tconst { item, pointerId, rect, startCell, colspan, rowspan } = pending;\n\n\t\tdragState = {\n\t\t\titem,\n\t\t\tpointerId,\n\t\t\toffsetX: e.clientX - rect.left,\n\t\t\toffsetY: e.clientY - rect.top,\n\t\t\tinitialRect: rect,\n\t\t\tstartCell,\n\t\t\tlastCell: startCell,\n\t\t\tlastTargetChangeTime: 0,\n\t\t\tcolspan,\n\t\t\trowspan,\n\t\t\tdragStartX: e.clientX,\n\t\t\tdragStartY: e.clientY,\n\t\t};\n\n\t\titem.setAttribute('data-egg-dragging', '');\n\t\tdocument.body.classList.add('is-dragging');\n\n\t\t// Transition state machine to interacting\n\t\tconst itemId = item.id || item.getAttribute('data-egg-item') || '';\n\t\tcore.stateMachine.transition({\n\t\t\ttype: 'START_INTERACTION',\n\t\t\tcontext: { type: 'drag', mode: 'pointer', itemId, element: item, columnCount: core.getGridInfo().columns.length },\n\t\t});\n\n\t\t// Emit drag-start BEFORE changing grid styles so originalPositions captures correct layout\n\t\tcore.emit('drag-start', { item, cell: startCell, colspan, rowspan, source: 'pointer' as const });\n\n\t\t// Switch to fixed positioning - CSS Grid ignores fixed positioned children\n\t\t// No need to move item out of grid container\n\t\titem.style.position = 'fixed';\n\t\titem.style.left = `${rect.left}px`;\n\t\titem.style.top = `${rect.top}px`;\n\t\titem.style.width = `${rect.width}px`;\n\t\titem.style.height = `${rect.height}px`;\n\t\titem.style.zIndex = '100';\n\n\t\tpendingDrag = null;\n\t};\n\n\tconst onPointerDown = (e: PointerEvent) => {\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-egg-item]',\n\t\t) as HTMLElement | null;\n\t\tif (!item) return;\n\n\t\t// Select the item on click\n\t\tcore.select(item);\n\n\t\t// Prevent text selection during potential drag\n\t\te.preventDefault();\n\n\t\tconst rect = item.getBoundingClientRect();\n\t\tconst startCell = getItemCell(item);\n\t\tconst { colspan, rowspan } = getItemSize(item);\n\n\t\t// Store pending drag state - don't start drag until movement\n\t\tpendingDrag = {\n\t\t\titem,\n\t\t\tpointerId: e.pointerId,\n\t\t\tstartX: e.clientX,\n\t\t\tstartY: e.clientY,\n\t\t\trect,\n\t\t\tstartCell,\n\t\t\tcolspan,\n\t\t\trowspan,\n\t\t};\n\n\t\titem.setPointerCapture(e.pointerId);\n\t\titem.addEventListener('pointermove', onPointerMove);\n\t\titem.addEventListener('pointerup', onPointerUp);\n\t\titem.addEventListener('pointercancel', onPointerCancel);\n\t};\n\n\tconst onPointerMove = (e: PointerEvent) => {\n\t\t// Check if we need to start dragging\n\t\tif (pendingDrag && !dragState) {\n\t\t\tconst dx = e.clientX - pendingDrag.startX;\n\t\t\tconst dy = e.clientY - pendingDrag.startY;\n\t\t\tconst distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\tif (distance >= DRAG_THRESHOLD) {\n\t\t\t\tstartDrag(pendingDrag, e);\n\t\t\t} else {\n\t\t\t\treturn; // Not enough movement yet\n\t\t\t}\n\t\t}\n\n\t\tif (!dragState) return;\n\n\t\tconst { item, offsetX, offsetY, initialRect, colspan, rowspan } = dragState;\n\n\t\t// Move item with cursor\n\t\tconst newLeft = e.clientX - offsetX;\n\t\tconst newTop = e.clientY - offsetY;\n\t\titem.style.left = `${newLeft}px`;\n\t\titem.style.top = `${newTop}px`;\n\n\t\t// Calculate target based on card center (feels more natural for multi-cell items)\n\t\tlet cardCenterX = newLeft + initialRect.width / 2;\n\t\tlet cardCenterY = newTop + initialRect.height / 2;\n\n\t\t// Predictive offset: shift the effective center in the direction of movement\n\t\tconst gridInfo = core.getGridInfo();\n\t\tconst cumulativeDx = e.clientX - dragState.dragStartX;\n\t\tconst cumulativeDy = e.clientY - dragState.dragStartY;\n\n\t\t// Apply prediction offset when movement exceeds threshold\n\t\tif (Math.abs(cumulativeDx) > PREDICTION_THRESHOLD) {\n\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellWidth + gridInfo.gap);\n\t\t\tcardCenterX += Math.sign(cumulativeDx) * leadOffset;\n\t\t}\n\t\tif (Math.abs(cumulativeDy) > PREDICTION_THRESHOLD) {\n\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellHeight + gridInfo.gap);\n\t\t\tcardCenterY += Math.sign(cumulativeDy) * leadOffset;\n\t\t}\n\n\t\tconst rawCell = core.getCellFromPoint(cardCenterX, cardCenterY);\n\t\tif (rawCell) {\n\t\t\t// Clamp cell so item fits within grid bounds\n\t\t\tconst gridInfo = core.getGridInfo();\n\t\t\tconst maxColumn = Math.max(1, gridInfo.columns.length - colspan + 1);\n\t\t\tconst maxRow = Math.max(1, gridInfo.rows.length - rowspan + 1);\n\n\t\t\tconst cell: GridCell = {\n\t\t\t\tcolumn: Math.max(1, Math.min(maxColumn, rawCell.column)),\n\t\t\t\trow: Math.max(1, Math.min(maxRow, rawCell.row)),\n\t\t\t};\n\n\t\t\tconst now = performance.now();\n\t\t\tconst timeSinceLastChange = now - dragState.lastTargetChangeTime;\n\n\t\t\t// Check if cell actually changed\n\t\t\tconst cellChanged =\n\t\t\t\tcell.column !== dragState.lastCell.column ||\n\t\t\t\tcell.row !== dragState.lastCell.row;\n\n\t\t\tif (cellChanged && timeSinceLastChange >= TARGET_CHANGE_DEBOUNCE) {\n\t\t\t\tconst cellWidth = gridInfo.cellWidth + gridInfo.gap;\n\t\t\t\tconst cellHeight = gridInfo.cellHeight + gridInfo.gap;\n\n\t\t\t\t// Current cell center in pixels (CSS Grid is 1-indexed)\n\t\t\t\tconst currentCellCenterX =\n\t\t\t\t\tgridInfo.rect.left +\n\t\t\t\t\t(dragState.lastCell.column - 1) * cellWidth +\n\t\t\t\t\tgridInfo.cellWidth / 2;\n\t\t\t\tconst currentCellCenterY =\n\t\t\t\t\tgridInfo.rect.top +\n\t\t\t\t\t(dragState.lastCell.row - 1) * cellHeight +\n\t\t\t\t\tgridInfo.cellHeight / 2;\n\n\t\t\t\t// Signed distance from card center to current cell center (in grid units)\n\t\t\t\tconst offsetFromCellX = (cardCenterX - currentCellCenterX) / cellWidth;\n\t\t\t\tconst offsetFromCellY = (cardCenterY - currentCellCenterY) / cellHeight;\n\n\t\t\t\t// Direction-aware hysteresis\n\t\t\t\tconst newCellIsRight = cell.column > dragState.lastCell.column;\n\t\t\t\tconst newCellIsBelow = cell.row > dragState.lastCell.row;\n\t\t\t\tconst cardIsRight = offsetFromCellX > 0;\n\t\t\t\tconst cardIsBelow = offsetFromCellY > 0;\n\n\t\t\t\tconst alignedX = (newCellIsRight && cardIsRight) || (!newCellIsRight && !cardIsRight);\n\t\t\t\tconst alignedY = (newCellIsBelow && cardIsBelow) || (!newCellIsBelow && !cardIsBelow);\n\n\t\t\t\tconst thresholdX = alignedX ? 0.5 : 0.5 + HYSTERESIS;\n\t\t\t\tconst thresholdY = alignedY ? 0.5 : 0.5 + HYSTERESIS;\n\n\t\t\t\tconst distX = Math.abs(offsetFromCellX);\n\t\t\t\tconst distY = Math.abs(offsetFromCellY);\n\n\t\t\t\tif (distX < thresholdX && distY < thresholdY) {\n\t\t\t\t\treturn; // Stay in current cell\n\t\t\t\t}\n\n\t\t\t\tdragState.lastCell = cell;\n\t\t\t\tdragState.lastTargetChangeTime = now;\n\t\t\t\tcore.emit('drag-move', { item, cell, x: e.clientX, y: e.clientY, colspan, rowspan, source: 'pointer' as const });\n\t\t\t}\n\t\t}\n\t};\n\n\tconst onPointerUp = (e: PointerEvent) => {\n\t\tconst item = pendingDrag?.item || dragState?.item;\n\t\tif (!item) return;\n\n\t\t// If drag never started, this was just a click - nothing more to do\n\t\tif (pendingDrag && !dragState) {\n\t\t\tcleanupListeners(item, pendingDrag.pointerId);\n\t\t\tpendingDrag = null;\n\t\t\treturn;\n\t\t}\n\n\t\tif (!dragState) return;\n\n\t\tconst { initialRect, colspan, rowspan, lastCell, offsetX, offsetY, dragStartX, dragStartY } = dragState;\n\n\t\t// Calculate drop position with same predictive offset as drag-move\n\t\tconst gridInfo = core.getGridInfo();\n\t\tconst cumulativeDx = e.clientX - dragStartX;\n\t\tconst cumulativeDy = e.clientY - dragStartY;\n\n\t\t// Apply prediction offset to get effective center for cell calculation\n\t\tconst newLeft = e.clientX - offsetX;\n\t\tconst newTop = e.clientY - offsetY;\n\t\tlet effectiveCenterX = newLeft + initialRect.width / 2;\n\t\tlet effectiveCenterY = newTop + initialRect.height / 2;\n\n\t\tif (Math.abs(cumulativeDx) > PREDICTION_THRESHOLD) {\n\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellWidth + gridInfo.gap);\n\t\t\teffectiveCenterX += Math.sign(cumulativeDx) * leadOffset;\n\t\t}\n\t\tif (Math.abs(cumulativeDy) > PREDICTION_THRESHOLD) {\n\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellHeight + gridInfo.gap);\n\t\t\teffectiveCenterY += Math.sign(cumulativeDy) * leadOffset;\n\t\t}\n\n\t\tconst rawCell = core.getCellFromPoint(effectiveCenterX, effectiveCenterY);\n\n\t\t// FLIP: Capture current visual position (First)\n\t\tconst firstRect = item.getBoundingClientRect();\n\n\t\t// Transition to committing before algorithm processes drag-end\n\t\tcore.stateMachine.transition({ type: 'COMMIT_INTERACTION' });\n\n\t\t// Emit event BEFORE cleanup so algorithm can set final position\n\t\tif (rawCell) {\n\t\t\tconst maxColumn = Math.max(1, gridInfo.columns.length - colspan + 1);\n\t\t\tconst maxRow = Math.max(1, gridInfo.rows.length - rowspan + 1);\n\n\t\t\tconst cell: GridCell = {\n\t\t\t\tcolumn: Math.max(1, Math.min(maxColumn, rawCell.column)),\n\t\t\t\trow: Math.max(1, Math.min(maxRow, rawCell.row)),\n\t\t\t};\n\n\t\t\tcore.emit('drag-end', { item, cell, colspan, rowspan, source: 'pointer' as const });\n\t\t} else {\n\t\t\tcore.emit('drag-end', { item, cell: lastCell, colspan, rowspan, source: 'pointer' as const });\n\t\t}\n\n\t\tcleanup();\n\n\t\t// Commit complete\n\t\tcore.stateMachine.transition({ type: 'FINISH_COMMIT' });\n\n\t\t// FLIP: Animate from visual position to final grid position\n\t\trequestAnimationFrame(() => {\n\t\t\tanimateFLIPWithTracking(item, firstRect);\n\t\t});\n\t};\n\n\tconst onPointerCancel = () => {\n\t\tconst item = pendingDrag?.item || dragState?.item;\n\t\tif (!item) return;\n\n\t\tif (dragState) {\n\t\t\tcore.emit('drag-cancel', { item, source: 'pointer' as const });\n\t\t\tcore.stateMachine.transition({ type: 'CANCEL_INTERACTION' });\n\t\t}\n\t\tcleanup();\n\t};\n\n\tconst cleanupListeners = (item: HTMLElement, pointerId: number) => {\n\t\titem.releasePointerCapture(pointerId);\n\t\titem.removeEventListener('pointermove', onPointerMove);\n\t\titem.removeEventListener('pointerup', onPointerUp);\n\t\titem.removeEventListener('pointercancel', onPointerCancel);\n\t};\n\n\tconst cleanup = () => {\n\t\tif (dragState) {\n\t\t\tconst { item, pointerId } = dragState;\n\n\t\t\titem.removeAttribute('data-egg-dragging');\n\t\t\tdocument.body.classList.remove('is-dragging');\n\t\t\titem.style.position = '';\n\t\t\titem.style.left = '';\n\t\t\titem.style.top = '';\n\t\t\titem.style.width = '';\n\t\t\titem.style.height = '';\n\t\t\titem.style.zIndex = '';\n\n\t\t\tcleanupListeners(item, pointerId);\n\t\t\tdragState = null;\n\t\t}\n\n\t\tif (pendingDrag) {\n\t\t\tcleanupListeners(pendingDrag.item, pendingDrag.pointerId);\n\t\t\tpendingDrag = null;\n\t\t}\n\t};\n\n\t// Deselect when clicking outside the grid\n\tconst onDocumentPointerDown = (e: PointerEvent) => {\n\t\tif (core.element.contains(e.target as Node)) return;\n\t\tif (dragState) return;\n\t\tcore.deselect();\n\t};\n\n\tcore.element.addEventListener('pointerdown', onPointerDown);\n\tdocument.addEventListener('pointerdown', onDocumentPointerDown);\n\n\treturn () => {\n\t\tcore.element.removeEventListener('pointerdown', onPointerDown);\n\t\tdocument.removeEventListener('pointerdown', onDocumentPointerDown);\n\t\tcleanup();\n\t};\n}\n","import { getItemCell, getItemSize } from '../engine';\nimport type { GridCell, EggCore } from '../types';\nimport { isDragging } from '../state-machine';\n\n/**\n * Attach keyboard navigation and drag to a EggCore instance.\n * @returns Cleanup function\n */\nexport function attachKeyboard(core: EggCore): () => void {\n\tconst { stateMachine } = core;\n\n\t// Track keyboard mode locally (Shift+G toggle)\n\tlet keyboardModeActive = false;\n\n\t// Track target cell locally during keyboard drag\n\tlet keyboardTargetCell: GridCell | null = null;\n\n\t// Track pending viewTransitionName restoration to avoid race conditions\n\tlet pendingVtnRestore: { item: HTMLElement; timeoutId: number } | null = null;\n\n\t/**\n\t * Helper to get current column count from grid\n\t */\n\tconst getColumnCount = (): number => {\n\t\treturn core.getGridInfo().columns.length;\n\t};\n\n\t/**\n\t * Check if currently holding an item (keyboard drag in progress)\n\t */\n\tconst isHoldingItem = (): boolean => {\n\t\tconst state = stateMachine.getState();\n\t\treturn isDragging(state) && state.interaction?.mode === 'keyboard';\n\t};\n\n\t/**\n\t * Get the held item element from state machine\n\t */\n\tconst getHeldItem = (): HTMLElement | null => {\n\t\tconst state = stateMachine.getState();\n\t\tif (isDragging(state) && state.interaction?.mode === 'keyboard') {\n\t\t\treturn state.interaction.element;\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Get direction from key, supporting both arrows and vim-style hjkl.\n\t * Uses both e.key and e.code to handle Alt+hjkl on Mac (Alt produces special chars).\n\t */\n\tconst KEY_DIR: Record<string, 'up' | 'down' | 'left' | 'right'> = {\n\t\tArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right',\n\t\tk: 'up', K: 'up', j: 'down', J: 'down', h: 'left', H: 'left', l: 'right', L: 'right',\n\t};\n\t// Fallback to code for Alt+hjkl on Mac (Alt produces special characters)\n\tconst CODE_DIR: Record<string, 'up' | 'down' | 'left' | 'right'> = {\n\t\tKeyK: 'up', KeyJ: 'down', KeyH: 'left', KeyL: 'right',\n\t};\n\tconst getDirection = (key: string, code: string) => KEY_DIR[key] ?? CODE_DIR[code] ?? null;\n\n\t/**\n\t * Get adjacent cell in a direction\n\t */\n\tconst getAdjacentCell = (\n\t\tcell: GridCell,\n\t\tdirection: 'up' | 'down' | 'left' | 'right',\n\t\tamount = 1,\n\t): GridCell => {\n\t\tswitch (direction) {\n\t\t\tcase 'up':\n\t\t\t\treturn { ...cell, row: Math.max(1, cell.row - amount) };\n\t\t\tcase 'down':\n\t\t\t\treturn { ...cell, row: cell.row + amount };\n\t\t\tcase 'left':\n\t\t\t\treturn { ...cell, column: Math.max(1, cell.column - amount) };\n\t\t\tcase 'right':\n\t\t\t\treturn { ...cell, column: cell.column + amount };\n\t\t}\n\t};\n\n\t/**\n\t * Find the item at or closest to a cell position in a direction\n\t */\n\tconst findItemInDirection = (\n\t\tfromCell: GridCell,\n\t\tdirection: 'up' | 'down' | 'left' | 'right',\n\t\texcludeItem: HTMLElement,\n\t): HTMLElement | null => {\n\t\tconst items = Array.from(\n\t\t\tcore.element.querySelectorAll('[data-egg-item]'),\n\t\t) as HTMLElement[];\n\n\t\tlet bestItem: HTMLElement | null = null;\n\t\tlet bestDistance = Infinity;\n\n\t\tfor (const item of items) {\n\t\t\tif (item === excludeItem) continue;\n\n\t\t\tconst cell = getItemCell(item);\n\t\t\tlet distance: number;\n\t\t\tlet isInDirection: boolean;\n\n\t\t\tswitch (direction) {\n\t\t\t\tcase 'up':\n\t\t\t\t\tisInDirection = cell.row < fromCell.row;\n\t\t\t\t\tdistance = fromCell.row - cell.row + Math.abs(cell.column - fromCell.column) * 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'down':\n\t\t\t\t\tisInDirection = cell.row > fromCell.row;\n\t\t\t\t\tdistance = cell.row - fromCell.row + Math.abs(cell.column - fromCell.column) * 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'left':\n\t\t\t\t\tisInDirection = cell.column < fromCell.column;\n\t\t\t\t\tdistance = fromCell.column - cell.column + Math.abs(cell.row - fromCell.row) * 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'right':\n\t\t\t\t\tisInDirection = cell.column > fromCell.column;\n\t\t\t\t\tdistance = cell.column - fromCell.column + Math.abs(cell.row - fromCell.row) * 0.1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isInDirection && distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestItem = item;\n\t\t\t}\n\t\t}\n\n\t\treturn bestItem;\n\t};\n\n\tconst onKeyDown = (e: KeyboardEvent) => {\n\t\t// Toggle keyboard mode with Shift+G (G for Grid)\n\t\tif (e.key === 'G' && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {\n\t\t\te.preventDefault();\n\t\t\tkeyboardModeActive = !keyboardModeActive;\n\t\t\tif (keyboardModeActive) {\n\t\t\t\tcore.element.setAttribute('data-egg-keyboard-mode', '');\n\t\t\t\t// If no item is selected, select the first one\n\t\t\t\tif (!core.selectedItem) {\n\t\t\t\t\tconst firstItem = core.element.querySelector('[data-egg-item]') as HTMLElement | null;\n\t\t\t\t\tif (firstItem) {\n\t\t\t\t\t\tcore.select(firstItem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcore.element.removeAttribute('data-egg-keyboard-mode');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// All other keyboard shortcuts require keyboard mode, selected item, or focus inside grid\n\t\tconst focused = document.activeElement as HTMLElement | null;\n\t\tconst focusInGrid = focused && core.element.contains(focused);\n\t\tconst hasSelection = core.selectedItem !== null;\n\t\tif (!keyboardModeActive && !focusInGrid && !hasSelection) return;\n\n\t\tconst selectedItem = core.selectedItem;\n\t\tconst direction = getDirection(e.key, e.code);\n\n\t\t// Cancel drag or deselect with Escape\n\t\tif (e.key === 'Escape') {\n\t\t\te.preventDefault();\n\t\t\tconst heldItem = getHeldItem();\n\t\t\tif (heldItem) {\n\t\t\t\theldItem.removeAttribute('data-egg-dragging');\n\t\t\t\tcore.emit('drag-cancel', { item: heldItem, source: 'keyboard' as const });\n\t\t\t\tstateMachine.transition({ type: 'CANCEL_INTERACTION' });\n\t\t\t\tkeyboardTargetCell = null;\n\t\t\t} else if (selectedItem) {\n\t\t\t\tcore.deselect();\n\t\t\t}\n\t\t\t// Turn off keyboard mode if it's active\n\t\t\tif (keyboardModeActive) {\n\t\t\t\tkeyboardModeActive = false;\n\t\t\t}\n\t\t\tcore.element.removeAttribute('data-egg-keyboard-mode');\n\t\t\treturn;\n\t\t}\n\n\t\t// Pick up / drop with Enter or Space\n\t\tif (e.key === 'Enter' || e.key === ' ') {\n\t\t\tif (!selectedItem) return;\n\t\t\te.preventDefault();\n\n\t\t\tconst heldItem = getHeldItem();\n\t\t\tif (heldItem) {\n\t\t\t\t// Drop the held item - use locally tracked target cell\n\t\t\t\tconst targetCell = keyboardTargetCell ?? getItemCell(heldItem);\n\t\t\t\tconst size = getItemSize(heldItem);\n\t\t\t\theldItem.removeAttribute('data-egg-dragging');\n\t\t\t\tcore.emit('drag-end', { item: heldItem, cell: targetCell, colspan: size.colspan, rowspan: size.rowspan, source: 'keyboard' as const });\n\t\t\t\tstateMachine.transition({ type: 'COMMIT_INTERACTION' });\n\t\t\t\tstateMachine.transition({ type: 'FINISH_COMMIT' });\n\t\t\t\tkeyboardTargetCell = null;\n\t\t\t} else {\n\t\t\t\t// Pick up the selected item\n\t\t\t\tconst itemId = selectedItem.id || selectedItem.getAttribute('data-egg-item') || '';\n\t\t\t\tconst size = getItemSize(selectedItem);\n\t\t\t\tconst startCell = getItemCell(selectedItem);\n\n\t\t\t\t// Start interaction via state machine\n\t\t\t\tstateMachine.transition({\n\t\t\t\t\ttype: 'START_INTERACTION',\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\ttype: 'drag',\n\t\t\t\t\t\tmode: 'keyboard',\n\t\t\t\t\t\titemId,\n\t\t\t\t\t\telement: selectedItem,\n\t\t\t\t\t\tcolumnCount: getColumnCount(),\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tkeyboardTargetCell = startCell;\n\t\t\t\tselectedItem.setAttribute('data-egg-dragging', '');\n\t\t\t\tcore.emit('drag-start', { item: selectedItem, cell: startCell, colspan: size.colspan, rowspan: size.rowspan, source: 'keyboard' as const });\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Navigation keys\n\t\tif (direction) {\n\t\t\te.preventDefault();\n\n\t\t\t// Alt+nav: Select adjacent item\n\t\t\tif (e.altKey && !e.ctrlKey && !e.shiftKey && selectedItem) {\n\t\t\t\tconst fromCell = getItemCell(selectedItem);\n\t\t\t\tconst adjacentItem = findItemInDirection(fromCell, direction, selectedItem);\n\t\t\t\tif (adjacentItem) {\n\t\t\t\t\tcore.select(adjacentItem);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Must have a selected item for other nav actions\n\t\t\tif (!selectedItem) return;\n\n\t\t\tconst currentCell = getItemCell(selectedItem);\n\t\t\tconst itemSize = getItemSize(selectedItem);\n\t\t\tconst gridInfo = core.getGridInfo();\n\n\t\t\t// Shift+nav: Resize item (change colspan/rowspan)\n\t\t\tif (e.shiftKey && !e.ctrlKey && !e.altKey) {\n\t\t\t\tlet newColspan = itemSize.colspan;\n\t\t\t\tlet newRowspan = itemSize.rowspan;\n\n\t\t\t\t// Calculate new size based on direction\n\t\t\t\tswitch (direction) {\n\t\t\t\t\tcase 'right':\n\t\t\t\t\t\tnewColspan = Math.min(itemSize.colspan + 1, gridInfo.columns.length - currentCell.column + 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'left':\n\t\t\t\t\t\tnewColspan = Math.max(1, itemSize.colspan - 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'down':\n\t\t\t\t\t\tnewRowspan = itemSize.rowspan + 1; // No max for rows (grid auto-grows)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'up':\n\t\t\t\t\t\tnewRowspan = Math.max(1, itemSize.rowspan - 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Skip if size didn't change (already at limit)\n\t\t\t\tif (newColspan === itemSize.colspan && newRowspan === itemSize.rowspan) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Cancel any pending viewTransitionName restoration\n\t\t\t\tif (pendingVtnRestore) {\n\t\t\t\t\tclearTimeout(pendingVtnRestore.timeoutId);\n\t\t\t\t\tpendingVtnRestore.item.style.removeProperty('view-transition-name');\n\t\t\t\t\tpendingVtnRestore = null;\n\t\t\t\t}\n\n\t\t\t\tconst itemId = selectedItem.id || selectedItem.getAttribute('data-egg-item') || '';\n\n\t\t\t\t// Start resize interaction via state machine\n\t\t\t\tstateMachine.transition({\n\t\t\t\t\ttype: 'START_INTERACTION',\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\ttype: 'resize',\n\t\t\t\t\t\tmode: 'keyboard',\n\t\t\t\t\t\titemId,\n\t\t\t\t\t\telement: selectedItem,\n\t\t\t\t\t\tcolumnCount: getColumnCount(),\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\t// Mark item as resizing so CSS can disable its View Transition animation\n\t\t\t\t// (matches pointer resize behavior - item snaps, others animate)\n\t\t\t\t(selectedItem.style as any).viewTransitionName = 'resizing';\n\n\t\t\t\t// Emit resize events for algorithm and other plugins to handle\n\t\t\t\t// Use 'se' handle for increases, appropriate edge for decreases\n\t\t\t\tconst handle = direction === 'right' || direction === 'down' ? 'se' :\n\t\t\t\t               direction === 'left' ? 'w' : 'n';\n\n\t\t\t\tcore.emit('resize-start', {\n\t\t\t\t\titem: selectedItem,\n\t\t\t\t\tcell: currentCell,\n\t\t\t\t\tcolspan: itemSize.colspan,\n\t\t\t\t\trowspan: itemSize.rowspan,\n\t\t\t\t\thandle,\n\t\t\t\t});\n\n\t\t\t\t// Update item data attributes (algorithm reads these for size)\n\t\t\t\tselectedItem.setAttribute('data-egg-colspan', String(newColspan));\n\t\t\t\tselectedItem.setAttribute('data-egg-rowspan', String(newRowspan));\n\n\t\t\t\t// Don't set inline grid styles - let algorithm handle layout via CSS rules\n\t\t\t\t// This allows View Transitions to animate other items smoothly\n\n\t\t\t\tcore.emit('resize-end', {\n\t\t\t\t\titem: selectedItem,\n\t\t\t\t\tcell: currentCell,\n\t\t\t\t\tcolspan: newColspan,\n\t\t\t\t\trowspan: newRowspan,\n\t\t\t\t});\n\n\t\t\t\t// Complete the interaction via state machine\n\t\t\t\tstateMachine.transition({ type: 'COMMIT_INTERACTION' });\n\t\t\t\tstateMachine.transition({ type: 'FINISH_COMMIT' });\n\n\t\t\t\t// Restore viewTransitionName after View Transition completes (200ms)\n\t\t\t\t// Track the timeout so we can cancel it if another resize starts\n\t\t\t\tconst itemToRestore = selectedItem;\n\t\t\t\tconst timeoutId = window.setTimeout(() => {\n\t\t\t\t\titemToRestore.style.removeProperty('view-transition-name');\n\t\t\t\t\tif (pendingVtnRestore?.item === itemToRestore) {\n\t\t\t\t\t\tpendingVtnRestore = null;\n\t\t\t\t\t}\n\t\t\t\t}, 250);\n\t\t\t\tpendingVtnRestore = { item: itemToRestore, timeoutId };\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Calculate move amount\n\t\t\tlet amount = 1;\n\t\t\tif (e.ctrlKey || e.metaKey) {\n\t\t\t\t// Ctrl+nav: Jump by item size\n\t\t\t\tamount = direction === 'up' || direction === 'down'\n\t\t\t\t\t? itemSize.rowspan\n\t\t\t\t\t: itemSize.colspan;\n\t\t\t}\n\n\t\t\tconst rawCell = getAdjacentCell(currentCell, direction, amount);\n\n\t\t\t// Clamp cell so item fits within grid bounds\n\t\t\tconst maxColumn = Math.max(1, gridInfo.columns.length - itemSize.colspan + 1);\n\t\t\tconst maxRow = Math.max(1, gridInfo.rows.length - itemSize.rowspan + 1);\n\t\t\tconst targetCell = {\n\t\t\t\tcolumn: Math.max(1, Math.min(maxColumn, rawCell.column)),\n\t\t\t\trow: Math.max(1, Math.min(maxRow, rawCell.row)),\n\t\t\t};\n\n\t\t\t// Skip if clamped position is same as current (at edge, can't move further)\n\t\t\tif (targetCell.column === currentCell.column && targetCell.row === currentCell.row) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst heldItem = getHeldItem();\n\t\t\tif (heldItem) {\n\t\t\t\t// Moving a held item - update locally tracked target cell\n\t\t\t\tkeyboardTargetCell = targetCell;\n\t\t\t\tcore.emit('drag-move', { item: heldItem, cell: targetCell, x: 0, y: 0, colspan: itemSize.colspan, rowspan: itemSize.rowspan, source: 'keyboard' as const });\n\t\t\t} else {\n\t\t\t\t// Nudge: Move item directly\n\t\t\t\t// Emit drag-start then drag-end (skip drag-move since we don't need preview)\n\t\t\t\tcore.emit('drag-start', { item: selectedItem, cell: currentCell, colspan: itemSize.colspan, rowspan: itemSize.rowspan, source: 'keyboard' as const });\n\t\t\t\tcore.emit('drag-end', { item: selectedItem, cell: targetCell, colspan: itemSize.colspan, rowspan: itemSize.rowspan, source: 'keyboard' as const });\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t};\n\n\tdocument.addEventListener('keydown', onKeyDown);\n\n\treturn () => {\n\t\tdocument.removeEventListener('keydown', onKeyDown);\n\t\tcore.element.removeAttribute('data-egg-keyboard-mode');\n\t};\n}\n","import { listenEvents } from '../engine';\nimport type {\n\tDragCancelDetail,\n\tDragEndDetail,\n\tDragMoveDetail,\n\tDragStartDetail,\n\tGridCell,\n\tEggCore,\n\tResizeCancelDetail,\n\tResizeEndDetail,\n\tResizeMoveDetail,\n\tResizeStartDetail,\n} from '../types';\n\nexport function attachAccessibility(core: EggCore): () => void {\n\t// Create live region for screen reader announcements\n\tconst liveRegion = document.createElement('div');\n\tliveRegion.setAttribute('aria-live', 'assertive');\n\tliveRegion.setAttribute('aria-atomic', 'true');\n\t// Visually hidden but accessible to screen readers\n\tObject.assign(liveRegion.style, {\n\t\tposition: 'absolute',\n\t\twidth: '1px',\n\t\theight: '1px',\n\t\tpadding: '0',\n\t\tmargin: '-1px',\n\t\toverflow: 'hidden',\n\t\tclip: 'rect(0, 0, 0, 0)',\n\t\twhiteSpace: 'nowrap',\n\t\tborder: '0',\n\t});\n\tcore.element.appendChild(liveRegion);\n\n\tlet lastCell: GridCell | null = null;\n\tlet lastResizeSize: { colspan: number; rowspan: number } | null = null;\n\n\tfunction announce(message: string) {\n\t\t// Clear and re-set to force re-announcement\n\t\tliveRegion.textContent = '';\n\t\trequestAnimationFrame(() => {\n\t\t\tliveRegion.textContent = message;\n\t\t});\n\t}\n\n\tfunction getLabel(item: HTMLElement): string {\n\t\treturn (\n\t\t\titem.getAttribute('data-egg-label') ||\n\t\t\titem.getAttribute('aria-label') ||\n\t\t\titem.id ||\n\t\t\t'Item'\n\t\t);\n\t}\n\n\tfunction formatPosition(cell: GridCell): string {\n\t\treturn `row ${cell.row}, column ${cell.column}`;\n\t}\n\n\tfunction resolveTemplate(\n\t\titem: HTMLElement,\n\t\tevent: string,\n\t\tvars: Record<string, string>,\n\t\tfallback: string,\n\t): string {\n\t\tconst template =\n\t\t\titem.getAttribute(`data-egg-announce-${event}`) ||\n\t\t\tcore.element.getAttribute(`data-egg-announce-${event}`);\n\t\tif (!template) return fallback;\n\t\treturn template.replace(/\\{(\\w+)\\}/g, (_, key) => vars[key] ?? '');\n\t}\n\n\tfunction getAnnouncement(\n\t\titem: HTMLElement,\n\t\tevent: 'grab' | 'move' | 'drop' | 'cancel',\n\t\tcell?: GridCell,\n\t): string {\n\t\tconst label = getLabel(item);\n\t\tconst pos = cell ? formatPosition(cell) : '';\n\t\tconst vars = { label, row: String(cell?.row ?? ''), column: String(cell?.column ?? '') };\n\n\t\tconst defaults: Record<string, string> = {\n\t\t\tgrab: `${label} grabbed. Position ${pos}. Use arrow keys to move, Enter to drop, Escape to cancel.`,\n\t\t\tmove: `Moved to ${pos}.`,\n\t\t\tdrop: `${label} dropped at ${pos}.`,\n\t\t\tcancel: `${label} drag cancelled.`,\n\t\t};\n\t\treturn resolveTemplate(item, event, vars, defaults[event]);\n\t}\n\n\tfunction getResizeAnnouncement(\n\t\titem: HTMLElement,\n\t\tevent: 'resize-start' | 'resize-move' | 'resize-end' | 'resize-cancel',\n\t\topts?: { cell?: GridCell; colspan?: number; rowspan?: number },\n\t): string {\n\t\tconst label = getLabel(item);\n\t\tconst size = opts?.colspan != null && opts?.rowspan != null\n\t\t\t? `${opts.colspan} columns by ${opts.rowspan} rows`\n\t\t\t: '';\n\t\tconst pos = opts?.cell ? formatPosition(opts.cell) : '';\n\t\tconst vars = {\n\t\t\tlabel,\n\t\t\tcolspan: String(opts?.colspan ?? ''),\n\t\t\trowspan: String(opts?.rowspan ?? ''),\n\t\t\trow: String(opts?.cell?.row ?? ''),\n\t\t\tcolumn: String(opts?.cell?.column ?? ''),\n\t\t};\n\n\t\tconst defaults: Record<string, string> = {\n\t\t\t'resize-start': `${label} resize started. Size ${size}. Use pointer to resize, Escape to cancel.`,\n\t\t\t'resize-move': `Resized to ${size}.`,\n\t\t\t'resize-end': `${label} resized to ${size} at ${pos}.`,\n\t\t\t'resize-cancel': `${label} resize cancelled.`,\n\t\t};\n\t\treturn resolveTemplate(item, event, vars, defaults[event]);\n\t}\n\n\tconst onDragStart = (e: CustomEvent<DragStartDetail>) => {\n\t\tlastCell = e.detail.cell;\n\t\tannounce(getAnnouncement(e.detail.item, 'grab', e.detail.cell));\n\t};\n\n\tconst onDragMove = (e: CustomEvent<DragMoveDetail>) => {\n\t\t// Only announce if cell actually changed\n\t\tconst { cell } = e.detail;\n\t\tif (\n\t\t\tlastCell &&\n\t\t\tcell.row === lastCell.row &&\n\t\t\tcell.column === lastCell.column\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\tlastCell = cell;\n\t\tannounce(getAnnouncement(e.detail.item, 'move', cell));\n\t};\n\n\tconst onDragEnd = (e: CustomEvent<DragEndDetail>) => {\n\t\tlastCell = null;\n\t\tannounce(getAnnouncement(e.detail.item, 'drop', e.detail.cell));\n\t};\n\n\tconst onDragCancel = (e: CustomEvent<DragCancelDetail>) => {\n\t\tlastCell = null;\n\t\tannounce(getAnnouncement(e.detail.item, 'cancel'));\n\t};\n\n\tconst onResizeStart = (e: CustomEvent<ResizeStartDetail>) => {\n\t\tconst { item, colspan, rowspan } = e.detail;\n\t\tlastResizeSize = { colspan, rowspan };\n\t\tannounce(getResizeAnnouncement(item, 'resize-start', { colspan, rowspan }));\n\t};\n\n\tconst onResizeMove = (e: CustomEvent<ResizeMoveDetail>) => {\n\t\tconst { item, cell, colspan, rowspan } = e.detail;\n\t\t// Only announce if size actually changed\n\t\tif (\n\t\t\tlastResizeSize &&\n\t\t\tcolspan === lastResizeSize.colspan &&\n\t\t\trowspan === lastResizeSize.rowspan\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\tlastResizeSize = { colspan, rowspan };\n\t\tannounce(getResizeAnnouncement(item, 'resize-move', { cell, colspan, rowspan }));\n\t};\n\n\tconst onResizeEnd = (e: CustomEvent<ResizeEndDetail>) => {\n\t\tconst { item, cell, colspan, rowspan } = e.detail;\n\t\tlastResizeSize = null;\n\t\tannounce(getResizeAnnouncement(item, 'resize-end', { cell, colspan, rowspan }));\n\t};\n\n\tconst onResizeCancel = (e: CustomEvent<ResizeCancelDetail>) => {\n\t\tlastResizeSize = null;\n\t\tannounce(getResizeAnnouncement(e.detail.item, 'resize-cancel'));\n\t};\n\n\tconst unlisten = listenEvents(core.element, {\n\t\t'egg-drag-start': onDragStart as EventListener,\n\t\t'egg-drag-move': onDragMove as EventListener,\n\t\t'egg-drag-end': onDragEnd as EventListener,\n\t\t'egg-drag-cancel': onDragCancel as EventListener,\n\t\t'egg-resize-start': onResizeStart as EventListener,\n\t\t'egg-resize-move': onResizeMove as EventListener,\n\t\t'egg-resize-end': onResizeEnd as EventListener,\n\t\t'egg-resize-cancel': onResizeCancel as EventListener,\n\t});\n\n\treturn () => {\n\t\tunlisten();\n\t\tliveRegion.remove();\n\t};\n}\n","/**\n * Resize plugin for EG Grid\n *\n * Pure input plugin — detects resize gestures on grid item corners/edges\n * and emits resize-start/move/end/cancel events. Does NOT persist layout.\n * A behavior plugin (e.g., Algorithm) listens for resize-end and handles persistence.\n *\n * Usage:\n *   import { attachResize } from 'eg-grid/resize';\n *\n *   const detach = attachResize(gridElement, {\n *     core,                 // EggCore instance (required)\n *     handles: 'corners',   // 'corners' | 'edges' | 'all'\n *     handleSize: 12,\n *     minSize: { colspan: 1, rowspan: 1 },\n *     maxSize: { colspan: 6, rowspan: 6 },\n *   });\n */\n\nimport { getItemSize } from '../engine';\nimport type {\n\tGridCell,\n\tEggCore,\n\tResizeCancelDetail,\n\tResizeEndDetail,\n\tResizeHandle,\n\tResizeMoveDetail,\n\tResizeStartDetail,\n} from '../types';\n\n\nexport interface ResizeOptions {\n\t/** EggCore instance (required) */\n\tcore: EggCore;\n\t/** Which handles to show: 'corners' | 'edges' | 'all' (default: 'corners') */\n\thandles?: 'corners' | 'edges' | 'all';\n\t/** Size of the hit zone for handles in pixels (default: 12) */\n\thandleSize?: number;\n\t/** Minimum size in grid cells (default: { colspan: 1, rowspan: 1 }) */\n\tminSize?: { colspan: number; rowspan: number };\n\t/** Maximum size in grid cells (default: { colspan: 6, rowspan: 6 }) */\n\tmaxSize?: { colspan: number; rowspan: number };\n\t/** Show size label during resize (default: true) */\n\tshowSizeLabel?: boolean;\n}\n\ninterface ActiveResize {\n\titem: HTMLElement;\n\tpointerId: number;\n\thandle: ResizeHandle;\n\t/** Original cell position at start of resize - never changes */\n\tstartCell: GridCell;\n\t/** Original size at start of resize - never changes */\n\toriginalSize: { colspan: number; rowspan: number };\n\t/** Current position (may differ from startCell for NW/NE/SW handles) */\n\tcurrentCell: GridCell;\n\t/** Current size during resize */\n\tcurrentSize: { colspan: number; rowspan: number };\n\tsizeLabel: HTMLElement | null;\n\t/** Initial bounding rect for smooth resize */\n\tinitialRect: DOMRect;\n\t/** Pointer position at start */\n\tstartPointerX: number;\n\tstartPointerY: number;\n}\n\n\n/**\n * Detect which resize handle (if any) is under the pointer\n */\nfunction detectHandle(\n\te: PointerEvent,\n\titem: HTMLElement,\n\tsize: number,\n\tmode: 'corners' | 'edges' | 'all',\n): ResizeHandle | null {\n\tconst rect = item.getBoundingClientRect();\n\tconst x = e.clientX - rect.left;\n\tconst y = e.clientY - rect.top;\n\n\tconst nearLeft = x < size;\n\tconst nearRight = x > rect.width - size;\n\tconst nearTop = y < size;\n\tconst nearBottom = y > rect.height - size;\n\n\t// Corners\n\tif (mode === 'corners' || mode === 'all') {\n\t\tif (nearTop && nearLeft) return 'nw';\n\t\tif (nearTop && nearRight) return 'ne';\n\t\tif (nearBottom && nearLeft) return 'sw';\n\t\tif (nearBottom && nearRight) return 'se';\n\t}\n\n\t// Edges (only if not at corners)\n\tif (mode === 'edges' || mode === 'all') {\n\t\tif (nearTop) return 'n';\n\t\tif (nearBottom) return 's';\n\t\tif (nearLeft) return 'w';\n\t\tif (nearRight) return 'e';\n\t}\n\n\treturn null;\n}\n\nconst CURSOR: Record<string, string> = {\n\tnw: 'nwse-resize', se: 'nwse-resize',\n\tne: 'nesw-resize', sw: 'nesw-resize',\n\tn: 'ns-resize', s: 'ns-resize',\n\te: 'ew-resize', w: 'ew-resize',\n};\n\n/**\n * Create a size label element\n */\nfunction createSizeLabel(): HTMLElement {\n\tconst label = document.createElement('div');\n\tlabel.className = 'egg-resize-label';\n\tlabel.style.cssText = `\n\t\tposition: absolute;\n\t\ttop: 50%;\n\t\tleft: 50%;\n\t\ttransform: translate(-50%, -50%);\n\t\tbackground: rgba(0, 0, 0, 0.8);\n\t\tcolor: white;\n\t\tpadding: 4px 8px;\n\t\tborder-radius: 4px;\n\t\tfont-size: 14px;\n\t\tfont-weight: 600;\n\t\tfont-family: system-ui, sans-serif;\n\t\tpointer-events: none;\n\t\tz-index: 1000;\n\t\twhite-space: nowrap;\n\t`;\n\treturn label;\n}\n\n/**\n * Attach resize functionality to a grid element.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach resize\n */\nexport function attachResize(\n\tgridElement: HTMLElement,\n\toptions: ResizeOptions,\n): { destroy(): void } {\n\tconst {\n\t\tcore,\n\t\thandles = 'corners',\n\t\thandleSize = 12,\n\t\tminSize = { colspan: 1, rowspan: 1 },\n\t\tmaxSize = { colspan: 6, rowspan: 6 },\n\t\tshowSizeLabel = true,\n\t} = options;\n\n\tlet activeResize: ActiveResize | null = null;\n\tlet hoveredItem: HTMLElement | null = null;\n\tlet hoveredHandle: ResizeHandle | null = null;\n\n\tfunction emit<T>(event: string, detail: T): void {\n\t\tgridElement.dispatchEvent(\n\t\t\tnew CustomEvent(`egg-${event}`, {\n\t\t\t\tbubbles: true,\n\t\t\t\tdetail,\n\t\t\t}),\n\t\t);\n\t}\n\n\tfunction startResize(item: HTMLElement, handle: ResizeHandle, e: PointerEvent) {\n\t\tconst { colspan, rowspan } = getItemSize(item);\n\n\t\tconst style = getComputedStyle(item);\n\t\tconst column = parseInt(style.gridColumnStart, 10) || 1;\n\t\tconst row = parseInt(style.gridRowStart, 10) || 1;\n\n\t\tconst originalSize = { colspan, rowspan };\n\t\tconst startCell = { column, row };\n\t\tconst initialRect = item.getBoundingClientRect();\n\n\t\t// Create size label if enabled\n\t\tlet sizeLabel: HTMLElement | null = null;\n\t\tif (showSizeLabel) {\n\t\t\tsizeLabel = createSizeLabel();\n\t\t\tsizeLabel.textContent = `${colspan}×${rowspan}`;\n\t\t\titem.appendChild(sizeLabel);\n\t\t}\n\n\t\tactiveResize = {\n\t\t\titem,\n\t\t\tpointerId: e.pointerId,\n\t\t\thandle,\n\t\t\tstartCell,\n\t\t\toriginalSize,\n\t\t\tcurrentCell: { ...startCell },\n\t\t\tcurrentSize: { ...originalSize },\n\t\t\tsizeLabel,\n\t\t\tinitialRect,\n\t\t\tstartPointerX: e.clientX,\n\t\t\tstartPointerY: e.clientY,\n\t\t};\n\n\t\titem.setAttribute('data-egg-resizing', '');\n\t\titem.setAttribute('data-egg-handle-active', handle);\n\t\titem.removeAttribute('data-egg-handle-hover'); // Clear hover state\n\t\titem.setPointerCapture(e.pointerId);\n\n\t\t// Add event listeners to item (pointer capture sends events to this element)\n\t\titem.addEventListener('pointermove', onItemPointerMove);\n\t\titem.addEventListener('pointerup', onItemPointerUp);\n\t\titem.addEventListener('pointercancel', onItemPointerCancel);\n\n\t\t// Transition state machine to interacting\n\t\tconst itemId = item.id || item.getAttribute('data-egg-item') || '';\n\t\tcore.stateMachine.transition({\n\t\t\ttype: 'START_INTERACTION',\n\t\t\tcontext: { type: 'resize', mode: 'pointer', itemId, element: item, columnCount: core.getGridInfo().columns.length },\n\t\t});\n\n\t\t// Emit resize-start BEFORE changing grid styles so originalPositions captures correct layout\n\t\temit<ResizeStartDetail>('resize-start', {\n\t\t\titem,\n\t\t\tcell: startCell,\n\t\t\tcolspan: originalSize.colspan,\n\t\t\trowspan: originalSize.rowspan,\n\t\t\thandle,\n\t\t\tsource: 'pointer',\n\t\t});\n\n\t\t// Switch to fixed positioning - item follows cursor in viewport coordinates\n\t\t// CSS Grid ignores fixed positioned children, allowing the grid to reflow\n\t\titem.style.position = 'fixed';\n\t\titem.style.left = `${initialRect.left}px`;\n\t\titem.style.top = `${initialRect.top}px`;\n\t\titem.style.width = `${initialRect.width}px`;\n\t\titem.style.height = `${initialRect.height}px`;\n\t\titem.style.zIndex = '100';\n\t\t// Exclude from view transitions during resize\n\t\titem.style.viewTransitionName = 'resizing';\n\t}\n\n\tfunction updateResize(e: PointerEvent) {\n\t\tif (!activeResize) return;\n\n\t\tconst { item, handle, startCell, originalSize, currentCell, currentSize, sizeLabel, initialRect, startPointerX, startPointerY } =\n\t\t\tactiveResize;\n\n\t\tconst gridInfo = core.getGridInfo();\n\n\t\t// Calculate pointer delta\n\t\tconst deltaX = e.clientX - startPointerX;\n\t\tconst deltaY = e.clientY - startPointerY;\n\n\t\t// Calculate new visual dimensions based on handle\n\t\tlet newWidth = initialRect.width;\n\t\tlet newHeight = initialRect.height;\n\t\tlet newLeft = initialRect.left;\n\t\tlet newTop = initialRect.top;\n\n\t\t// Minimum visual size (1 cell)\n\t\tconst minWidth = gridInfo.cellWidth;\n\t\tconst minHeight = gridInfo.cellHeight;\n\t\t// Maximum visual size (clamped by maxSize config)\n\t\tconst maxWidthByConfig = maxSize.colspan * gridInfo.cellWidth + (maxSize.colspan - 1) * gridInfo.gap;\n\t\tconst maxHeightByConfig = maxSize.rowspan * gridInfo.cellHeight + (maxSize.rowspan - 1) * gridInfo.gap;\n\t\t// Maximum visual size (clamped by grid bounds)\n\t\tconst maxWidthByGrid = gridInfo.rect.right - initialRect.left;\n\t\tconst maxHeightByGrid = gridInfo.rect.bottom - initialRect.top;\n\t\tconst maxWidth = Math.min(maxWidthByConfig, maxWidthByGrid);\n\t\tconst maxHeight = Math.min(maxHeightByConfig, maxHeightByGrid);\n\n\t\t// Apply delta based on handle direction\n\t\tif (handle === 'e' || handle === 'se' || handle === 'ne') {\n\t\t\tnewWidth = Math.max(minWidth, Math.min(maxWidth, initialRect.width + deltaX));\n\t\t}\n\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t\t// For left edge, clamp to grid left\n\t\t\tconst maxLeftShift = initialRect.left - gridInfo.rect.left;\n\t\t\tconst maxWidthFromLeft = Math.min(maxWidthByConfig, initialRect.width + maxLeftShift);\n\t\t\tconst widthChange = Math.max(-initialRect.width + minWidth, Math.min(maxWidthFromLeft - initialRect.width, -deltaX));\n\t\t\tnewWidth = initialRect.width + widthChange;\n\t\t\tnewLeft = initialRect.left - widthChange;\n\t\t}\n\t\tif (handle === 's' || handle === 'se' || handle === 'sw') {\n\t\t\tnewHeight = Math.max(minHeight, Math.min(maxHeight, initialRect.height + deltaY));\n\t\t}\n\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t\t// For top edge, clamp to grid top\n\t\t\tconst maxTopShift = initialRect.top - gridInfo.rect.top;\n\t\t\tconst maxHeightFromTop = Math.min(maxHeightByConfig, initialRect.height + maxTopShift);\n\t\t\tconst heightChange = Math.max(-initialRect.height + minHeight, Math.min(maxHeightFromTop - initialRect.height, -deltaY));\n\t\t\tnewHeight = initialRect.height + heightChange;\n\t\t\tnewTop = initialRect.top - heightChange;\n\t\t}\n\n\t\t// Apply smooth visual size (fixed positioning uses viewport coordinates)\n\t\titem.style.left = `${newLeft}px`;\n\t\titem.style.top = `${newTop}px`;\n\t\titem.style.width = `${newWidth}px`;\n\t\titem.style.height = `${newHeight}px`;\n\n\t\t// Calculate projected final grid size (what it will snap to)\n\t\tconst cellPlusGap = gridInfo.cellWidth + gridInfo.gap;\n\t\tconst rowPlusGap = gridInfo.cellHeight + gridInfo.gap;\n\n\t\t// Calculate raw ratios\n\t\tconst rawColspanRatio = (newWidth + gridInfo.gap) / cellPlusGap;\n\t\tconst rawRowspanRatio = (newHeight + gridInfo.gap) / rowPlusGap;\n\n\t\t// Snap when 30% into the next cell (works symmetrically for grow and shrink)\n\t\tconst RESIZE_SNAP = 0.3;\n\t\tlet projectedColspan = Math.floor(rawColspanRatio + (1 - RESIZE_SNAP));\n\t\tlet projectedRowspan = Math.floor(rawRowspanRatio + (1 - RESIZE_SNAP));\n\n\t\t// Apply min/max constraints\n\t\tprojectedColspan = Math.max(minSize.colspan, Math.min(maxSize.colspan, projectedColspan));\n\t\tprojectedRowspan = Math.max(minSize.rowspan, Math.min(maxSize.rowspan, projectedRowspan));\n\n\t\t// Calculate cell position: anchor corner stays fixed, opposite edge moves\n\t\tlet projectedColumn = startCell.column;\n\t\tlet projectedRow = startCell.row;\n\n\t\t// For handles that move the left edge, calculate column from the right anchor\n\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t\tconst rightEdge = startCell.column + originalSize.colspan - 1;\n\t\t\tprojectedColumn = rightEdge - projectedColspan + 1;\n\t\t}\n\n\t\t// For handles that move the top edge, calculate row from the bottom anchor\n\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t\tconst bottomEdge = startCell.row + originalSize.rowspan - 1;\n\t\t\tprojectedRow = bottomEdge - projectedRowspan + 1;\n\t\t}\n\n\t\t// Update tracking\n\t\tactiveResize.currentSize = { colspan: projectedColspan, rowspan: projectedRowspan };\n\t\tactiveResize.currentCell = { column: projectedColumn, row: projectedRow };\n\n\t\t// Update size label with projected final size\n\t\tif (sizeLabel) {\n\t\t\tsizeLabel.textContent = `${projectedColspan}×${projectedRowspan}`;\n\t\t}\n\n\t\t// Calculate anchor cell (the corner that stays fixed during resize)\n\t\tlet anchorCell: GridCell;\n\t\tif (handle === 'se' || handle === 's' || handle === 'e') {\n\t\t\t// NW corner is anchor\n\t\t\tanchorCell = { column: startCell.column, row: startCell.row };\n\t\t} else if (handle === 'nw' || handle === 'n' || handle === 'w') {\n\t\t\t// SE corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column + originalSize.colspan - 1,\n\t\t\t\trow: startCell.row + originalSize.rowspan - 1,\n\t\t\t};\n\t\t} else if (handle === 'ne') {\n\t\t\t// SW corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column,\n\t\t\t\trow: startCell.row + originalSize.rowspan - 1,\n\t\t\t};\n\t\t} else {\n\t\t\t// SW handle: NE corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column + originalSize.colspan - 1,\n\t\t\t\trow: startCell.row,\n\t\t\t};\n\t\t}\n\n\t\temit<ResizeMoveDetail>('resize-move', {\n\t\t\titem,\n\t\t\tcell: { column: projectedColumn, row: projectedRow },\n\t\t\tanchorCell,\n\t\t\tstartCell,\n\t\t\tcolspan: projectedColspan,\n\t\t\trowspan: projectedRowspan,\n\t\t\thandle,\n\t\t\tsource: 'pointer',\n\t\t});\n\t}\n\n\tfunction cleanupResizeListeners(item: HTMLElement, pointerId: number) {\n\t\titem.releasePointerCapture(pointerId);\n\t\titem.removeEventListener('pointermove', onItemPointerMove);\n\t\titem.removeEventListener('pointerup', onItemPointerUp);\n\t\titem.removeEventListener('pointercancel', onItemPointerCancel);\n\t}\n\n\tfunction resetItem(item: HTMLElement, pointerId: number, sizeLabel: HTMLElement | null) {\n\t\tcleanupResizeListeners(item, pointerId);\n\t\tif (sizeLabel) sizeLabel.remove();\n\t\titem.style.position = '';\n\t\titem.style.left = '';\n\t\titem.style.top = '';\n\t\titem.style.width = '';\n\t\titem.style.height = '';\n\t\titem.style.zIndex = '';\n\t\tconst itemId = item.style.getPropertyValue('--item-id') || item.dataset.eggItem || item.id || item.dataset.id;\n\t\titem.style.viewTransitionName = itemId || '';\n\t\titem.removeAttribute('data-egg-resizing');\n\t\titem.removeAttribute('data-egg-handle-active');\n\t}\n\n\tfunction finishResize() {\n\t\tif (!activeResize) return;\n\t\tconst { item, pointerId, currentSize, currentCell, sizeLabel } = activeResize;\n\t\titem.setAttribute('data-egg-colspan', String(currentSize.colspan));\n\t\titem.setAttribute('data-egg-rowspan', String(currentSize.rowspan));\n\t\tcore.stateMachine.transition({ type: 'COMMIT_INTERACTION' });\n\t\temit<ResizeEndDetail>('resize-end', {\n\t\t\titem, cell: currentCell,\n\t\t\tcolspan: currentSize.colspan, rowspan: currentSize.rowspan,\n\t\t\tsource: 'pointer',\n\t\t});\n\t\tresetItem(item, pointerId, sizeLabel);\n\t\tactiveResize = null;\n\t\tcore.stateMachine.transition({ type: 'FINISH_COMMIT' });\n\t}\n\n\tfunction cancelResize() {\n\t\tif (!activeResize) return;\n\t\tconst { item, pointerId, sizeLabel } = activeResize;\n\t\temit<ResizeCancelDetail>('resize-cancel', { item, source: 'pointer' });\n\t\tcore.stateMachine.transition({ type: 'CANCEL_INTERACTION' });\n\t\tresetItem(item, pointerId, sizeLabel);\n\t\tactiveResize = null;\n\t}\n\n\t// --- Event handlers ---\n\n\t// Use capture phase to intercept before pointer plugin\n\tconst onPointerDown = (e: PointerEvent) => {\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-egg-item]',\n\t\t) as HTMLElement | null;\n\t\tif (!item) return;\n\n\t\tconst handle = detectHandle(e, item, handleSize, handles);\n\t\tif (!handle) return; // Not on handle - let pointer plugin handle drag\n\n\t\t// Stop event from reaching pointer plugin\n\t\te.stopPropagation();\n\t\te.preventDefault();\n\n\t\t// Select the item (resize captures before pointer plugin, so pointer's select never fires)\n\t\tcore.select(item);\n\n\t\tstartResize(item, handle, e);\n\t};\n\n\t// Item-specific handlers (added during resize, removed on finish/cancel)\n\tconst onItemPointerMove = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tupdateResize(e);\n\t\t}\n\t};\n\n\tconst onItemPointerUp = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tfinishResize();\n\t\t}\n\t};\n\n\tconst onItemPointerCancel = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tcancelResize();\n\t\t}\n\t};\n\n\t// Grid-level hover handler for cursor changes and handle hover state\n\tconst onPointerMove = (e: PointerEvent) => {\n\t\t// Skip hover handling during active resize\n\t\tif (activeResize) return;\n\n\t\t// Handle hover cursor changes\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-egg-item]',\n\t\t) as HTMLElement | null;\n\n\t\tif (item) {\n\t\t\tconst handle = detectHandle(e, item, handleSize, handles);\n\n\t\t\tif (handle !== hoveredHandle || item !== hoveredItem) {\n\t\t\t\t// Clear previous item's hover state\n\t\t\t\tif (hoveredItem && hoveredItem !== item) {\n\t\t\t\t\thoveredItem.style.cursor = '';\n\t\t\t\t\thoveredItem.removeAttribute('data-egg-handle-hover');\n\t\t\t\t}\n\n\t\t\t\t// Clear hover attribute if handle changed on same item\n\t\t\t\tif (hoveredItem === item && hoveredHandle && !handle) {\n\t\t\t\t\titem.removeAttribute('data-egg-handle-hover');\n\t\t\t\t}\n\n\t\t\t\thoveredItem = item;\n\t\t\t\thoveredHandle = handle;\n\n\t\t\t\t// Set cursor and hover attribute based on handle\n\t\t\t\titem.style.cursor = (handle ? CURSOR[handle] : '') || '';\n\t\t\t\tif (handle) {\n\t\t\t\t\titem.setAttribute('data-egg-handle-hover', handle);\n\t\t\t\t} else {\n\t\t\t\t\titem.removeAttribute('data-egg-handle-hover');\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (hoveredItem) {\n\t\t\thoveredItem.style.cursor = '';\n\t\t\thoveredItem.removeAttribute('data-egg-handle-hover');\n\t\t\thoveredItem = null;\n\t\t\thoveredHandle = null;\n\t\t}\n\t};\n\n\tconst onKeyDown = (e: KeyboardEvent) => {\n\t\tif (e.key === 'Escape' && activeResize) {\n\t\t\tcancelResize();\n\t\t}\n\t};\n\n\t// Register event listeners\n\tgridElement.addEventListener('pointerdown', onPointerDown, { capture: true });\n\tgridElement.addEventListener('pointermove', onPointerMove);\n\tdocument.addEventListener('keydown', onKeyDown);\n\n\tfunction destroy() {\n\t\tgridElement.removeEventListener('pointerdown', onPointerDown, {\n\t\t\tcapture: true,\n\t\t});\n\t\tgridElement.removeEventListener('pointermove', onPointerMove);\n\t\tdocument.removeEventListener('keydown', onKeyDown);\n\n\t\tif (activeResize) {\n\t\t\tcancelResize();\n\t\t}\n\t}\n\n\treturn { destroy };\n}\n\nexport type { ResizeHandle };\n","/**\n * Camera plugin for EG Grid\n *\n * Handles viewport scrolling to keep the active item visible:\n * - Auto-scroll when dragging near viewport edges\n * - Scroll into view when selecting items via keyboard\n *\n * The \"active item\" is: the dragged item during drag, or the selected item otherwise.\n */\n\nimport { listenEvents } from '../engine';\nimport type {\n\tDragStartDetail,\n\tDragMoveDetail,\n\tDragEndDetail,\n\tDragCancelDetail,\n\tSelectDetail,\n\tEggCore,\n} from '../types';\n\nexport type CameraMode = 'contain' | 'center' | 'off';\n\nexport interface CameraOptions {\n\t/**\n\t * Scroll behavior mode:\n\t * - 'contain': Only scroll when item would leave viewport (default)\n\t * - 'center': Keep active item centered (can feel jarring)\n\t * - 'off': Disable camera scrolling\n\t */\n\tmode?: CameraMode;\n\n\t/**\n\t * The scrollable container. Defaults to the grid's scroll parent.\n\t * Pass `window` to scroll the document.\n\t */\n\tscrollContainer?: HTMLElement | Window;\n\n\t/**\n\t * Size of edge zones that trigger auto-scroll during drag (in pixels).\n\t * @default 60\n\t */\n\tedgeSize?: number;\n\n\t/**\n\t * Maximum scroll speed in pixels per frame.\n\t * @default 15\n\t */\n\tscrollSpeed?: number;\n\n\t/**\n\t * Scroll behavior for selection changes.\n\t * @default 'smooth'\n\t */\n\tscrollBehavior?: ScrollBehavior;\n\n\t/**\n\t * Margin around item when scrolling into view (in pixels).\n\t * @default 20\n\t */\n\tscrollMargin?: number;\n\n\t/**\n\t * Whether to scroll on selection changes (keyboard nav).\n\t * @default true\n\t */\n\tscrollOnSelect?: boolean;\n\n\t/**\n\t * Whether to auto-scroll during drag.\n\t * @default true\n\t */\n\tautoScrollOnDrag?: boolean;\n\n\t/**\n\t * Time in ms after scrolling stops before considered \"settled\".\n\t * Other plugins can check isScrolling() to defer updates.\n\t * @default 150\n\t */\n\tsettleDelay?: number;\n\n\t/**\n\t * EG Grid core instance for provider registration.\n\t * If provided, registers a 'camera' provider.\n\t */\n\tcore?: EggCore;\n}\n\n/**\n * Camera state exposed via provider registry.\n */\nexport interface CameraState {\n\t/** Whether the camera is actively auto-scrolling */\n\tisScrolling: boolean;\n\t/** Current camera mode */\n\tmode: CameraMode;\n}\n\nexport interface CameraInstance {\n\t/** Change the camera mode */\n\tsetMode(mode: CameraMode): void;\n\t/** Get current mode */\n\tgetMode(): CameraMode;\n\t/** Manually scroll an item into view */\n\tscrollTo(item: HTMLElement, behavior?: ScrollBehavior): void;\n\t/** Stop any active auto-scrolling */\n\tstop(): void;\n\t/** Clean up and remove event listeners */\n\tdestroy(): void;\n}\n\n/**\n * Find the nearest scrollable ancestor of an element.\n */\nfunction findScrollParent(element: HTMLElement): HTMLElement | Window {\n\tlet parent = element.parentElement;\n\n\twhile (parent) {\n\t\tconst style = getComputedStyle(parent);\n\t\tconst overflowY = style.overflowY;\n\t\tconst overflowX = style.overflowX;\n\n\t\tif (\n\t\t\toverflowY === 'auto' ||\n\t\t\toverflowY === 'scroll' ||\n\t\t\toverflowX === 'auto' ||\n\t\t\toverflowX === 'scroll'\n\t\t) {\n\t\t\treturn parent;\n\t\t}\n\n\t\tparent = parent.parentElement;\n\t}\n\n\treturn window;\n}\n\n/**\n * Get viewport rect for a scroll container.\n */\nfunction getViewportRect(\n\tcontainer: HTMLElement | Window\n): { top: number; left: number; width: number; height: number } {\n\tif (container === window) {\n\t\treturn {\n\t\t\ttop: 0,\n\t\t\tleft: 0,\n\t\t\twidth: window.innerWidth,\n\t\t\theight: window.innerHeight,\n\t\t};\n\t}\n\tconst rect = (container as HTMLElement).getBoundingClientRect();\n\treturn {\n\t\ttop: rect.top,\n\t\tleft: rect.left,\n\t\twidth: rect.width,\n\t\theight: rect.height,\n\t};\n}\n\n/**\n * Attach camera behavior to a EG Grid grid element.\n */\nexport function attachCamera(\n\tgridElement: HTMLElement,\n\toptions: CameraOptions = {}\n): CameraInstance {\n\tconst {\n\t\tmode: initialMode = 'contain',\n\t\tscrollContainer: customContainer,\n\t\tedgeSize = 60,\n\t\tscrollSpeed = 15,\n\t\tscrollBehavior = 'smooth',\n\t\tscrollMargin = 20,\n\t\tscrollOnSelect = true,\n\t\tautoScrollOnDrag = true,\n\t\tsettleDelay = 150,\n\t\tcore,\n\t} = options;\n\n\tlet mode = initialMode;\n\tlet scrollContainer = customContainer ?? findScrollParent(gridElement);\n\tlet animationFrameId: number | null = null;\n\tlet isDragging = false;\n\tlet dragSource: 'pointer' | 'keyboard' | null = null;\n\tlet lastPointerX = 0;\n\tlet lastPointerY = 0;\n\tlet isScrolling = false;\n\tlet settleTimeoutId: ReturnType<typeof setTimeout> | null = null;\n\n\t// Expose scrolling state on core\n\tif (core) {\n\t\tcore.cameraScrolling = false;\n\t}\n\n\t/**\n\t * Mark scrolling as active, with settle timeout.\n\t */\n\tfunction setScrolling(active: boolean): void {\n\t\tif (active) {\n\t\t\tisScrolling = true;\n\t\t\tif (core) core.cameraScrolling = true;\n\t\t\tif (settleTimeoutId) {\n\t\t\t\tclearTimeout(settleTimeoutId);\n\t\t\t\tsettleTimeoutId = null;\n\t\t\t}\n\t\t} else {\n\t\t\t// Start settle timer\n\t\t\tif (settleTimeoutId) clearTimeout(settleTimeoutId);\n\t\t\tsettleTimeoutId = setTimeout(() => {\n\t\t\t\tisScrolling = false;\n\t\t\t\tif (core) core.cameraScrolling = false;\n\t\t\t\tsettleTimeoutId = null;\n\t\t\t\t// Emit settle event so algorithm can recalculate\n\t\t\t\tgridElement.dispatchEvent(\n\t\t\t\t\tnew CustomEvent('egg-camera-settled', { bubbles: true })\n\t\t\t\t);\n\t\t\t}, settleDelay);\n\t\t}\n\t}\n\n\t/**\n\t * Scroll an item into view based on current mode.\n\t */\n\tfunction scrollTo(item: HTMLElement, behavior: ScrollBehavior = scrollBehavior): void {\n\t\tif (mode === 'off') return;\n\n\t\tconst itemRect = item.getBoundingClientRect();\n\t\tconst viewport = getViewportRect(scrollContainer);\n\n\t\tif (mode === 'center') {\n\t\t\t// Center the item in the viewport\n\t\t\tconst targetScrollTop =\n\t\t\t\tscrollContainer === window\n\t\t\t\t\t? window.scrollY + itemRect.top - viewport.height / 2 + itemRect.height / 2\n\t\t\t\t\t: (scrollContainer as HTMLElement).scrollTop +\n\t\t\t\t\t\titemRect.top -\n\t\t\t\t\t\tviewport.top -\n\t\t\t\t\t\tviewport.height / 2 +\n\t\t\t\t\t\titemRect.height / 2;\n\n\t\t\tconst targetScrollLeft =\n\t\t\t\tscrollContainer === window\n\t\t\t\t\t? window.scrollX + itemRect.left - viewport.width / 2 + itemRect.width / 2\n\t\t\t\t\t: (scrollContainer as HTMLElement).scrollLeft +\n\t\t\t\t\t\titemRect.left -\n\t\t\t\t\t\tviewport.left -\n\t\t\t\t\t\tviewport.width / 2 +\n\t\t\t\t\t\titemRect.width / 2;\n\n\t\t\tif (scrollContainer === window) {\n\t\t\t\twindow.scrollTo({ top: targetScrollTop, left: targetScrollLeft, behavior });\n\t\t\t} else {\n\t\t\t\t(scrollContainer as HTMLElement).scrollTo({\n\t\t\t\t\ttop: targetScrollTop,\n\t\t\t\t\tleft: targetScrollLeft,\n\t\t\t\t\tbehavior,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t// 'contain' mode - use CSS scroll-margin with scrollIntoView\n\t\t\t// The scroll-margin should be set in CSS on items (or we set it here)\n\t\t\t// This lets the browser handle all the positioning math\n\n\t\t\titem.scrollIntoView({\n\t\t\t\tbehavior,\n\t\t\t\tblock: 'nearest',\n\t\t\t\tinline: 'nearest',\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Calculate scroll velocity based on pointer position relative to edges.\n\t */\n\tfunction getEdgeScrollVelocity(\n\t\tpointerX: number,\n\t\tpointerY: number\n\t): { x: number; y: number } {\n\t\tconst viewport = getViewportRect(scrollContainer);\n\t\tlet velocityX = 0;\n\t\tlet velocityY = 0;\n\n\t\t// Pointer position relative to viewport\n\t\tconst relativeX = pointerX - viewport.left;\n\t\tconst relativeY = pointerY - viewport.top;\n\n\t\t// Check horizontal edges\n\t\tif (relativeX < edgeSize) {\n\t\t\t// Near left edge - scroll left (negative)\n\t\t\tvelocityX = -scrollSpeed * (1 - relativeX / edgeSize);\n\t\t} else if (relativeX > viewport.width - edgeSize) {\n\t\t\t// Near right edge - scroll right (positive)\n\t\t\tvelocityX = scrollSpeed * (1 - (viewport.width - relativeX) / edgeSize);\n\t\t}\n\n\t\t// Check vertical edges\n\t\tif (relativeY < edgeSize) {\n\t\t\t// Near top edge - scroll up (negative)\n\t\t\tvelocityY = -scrollSpeed * (1 - relativeY / edgeSize);\n\t\t} else if (relativeY > viewport.height - edgeSize) {\n\t\t\t// Near bottom edge - scroll down (positive)\n\t\t\tvelocityY = scrollSpeed * (1 - (viewport.height - relativeY) / edgeSize);\n\t\t}\n\n\t\treturn { x: velocityX, y: velocityY };\n\t}\n\n\t/**\n\t * Animation loop for edge scrolling during drag.\n\t */\n\tlet wasScrollingLastFrame = false;\n\n\tfunction scrollLoop(): void {\n\t\tif (!isDragging || !autoScrollOnDrag || mode === 'off') {\n\t\t\tanimationFrameId = null;\n\t\t\tif (wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(false);\n\t\t\t\twasScrollingLastFrame = false;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconst velocity = getEdgeScrollVelocity(lastPointerX, lastPointerY);\n\t\tconst isNearEdge = velocity.x !== 0 || velocity.y !== 0;\n\n\t\tif (isNearEdge) {\n\t\t\tif (!wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(true);\n\t\t\t}\n\t\t\twasScrollingLastFrame = true;\n\t\t\tif (scrollContainer === window) {\n\t\t\t\twindow.scrollBy(velocity.x, velocity.y);\n\t\t\t} else {\n\t\t\t\t(scrollContainer as HTMLElement).scrollLeft += velocity.x;\n\t\t\t\t(scrollContainer as HTMLElement).scrollTop += velocity.y;\n\t\t\t}\n\t\t} else {\n\t\t\t// Not near edge\n\t\t\tif (wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(false);\n\t\t\t\twasScrollingLastFrame = false;\n\t\t\t}\n\t\t}\n\n\t\tanimationFrameId = requestAnimationFrame(scrollLoop);\n\t}\n\n\t/**\n\t * Start the scroll loop.\n\t */\n\tfunction startScrollLoop(): void {\n\t\tif (animationFrameId === null) {\n\t\t\tanimationFrameId = requestAnimationFrame(scrollLoop);\n\t\t}\n\t}\n\n\t/**\n\t * Stop the scroll loop.\n\t */\n\tfunction stopScrollLoop(): void {\n\t\tif (animationFrameId !== null) {\n\t\t\tcancelAnimationFrame(animationFrameId);\n\t\t\tanimationFrameId = null;\n\t\t}\n\t\tsetScrolling(false);\n\t}\n\n\t// Track pointer position continuously during drag (not just on cell change)\n\tfunction onPointerMove(e: PointerEvent): void {\n\t\tif (!isDragging || !autoScrollOnDrag || mode === 'off') return;\n\n\t\tlastPointerX = e.clientX;\n\t\tlastPointerY = e.clientY;\n\t\tstartScrollLoop();\n\t}\n\n\t// Event handlers\n\tfunction onDragStart(e: CustomEvent<DragStartDetail>): void {\n\t\tisDragging = true;\n\t\tdragSource = e.detail.source;\n\t\t// Only listen for raw pointer moves during pointer drags (for edge-scroll detection)\n\t\tif (dragSource === 'pointer') {\n\t\t\twindow.addEventListener('pointermove', onPointerMove);\n\t\t}\n\t}\n\n\tfunction onDragMove(e: CustomEvent<DragMoveDetail>): void {\n\t\tif (mode === 'off') return;\n\n\t\tif (e.detail.source === 'pointer') {\n\t\t\t// Pointer drag: update position for edge detection\n\t\t\tlastPointerX = e.detail.x;\n\t\t\tlastPointerY = e.detail.y;\n\t\t} else {\n\t\t\t// Keyboard drag - scroll to keep item visible\n\t\t\t// Use requestAnimationFrame to let the DOM update first\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tscrollTo(e.detail.item, 'smooth');\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction onDragEnd(e: CustomEvent<DragEndDetail>): void {\n\t\tconst wasPointerDrag = dragSource === 'pointer';\n\t\tisDragging = false;\n\t\tdragSource = null;\n\t\tstopScrollLoop();\n\t\tif (wasPointerDrag) {\n\t\t\twindow.removeEventListener('pointermove', onPointerMove);\n\t\t}\n\n\t\t// For keyboard moves (nudge), scroll to keep item visible after it moves\n\t\t// Pointer drags handle their own scrolling via edge detection\n\t\tif (!wasPointerDrag && scrollOnSelect) {\n\t\t\t// Wait for layout to settle (view transitions may be animating)\n\t\t\t// Use setTimeout + rAF to ensure DOM has updated\n\t\t\tsetTimeout(() => {\n\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\tscrollTo(e.detail.item, 'smooth');\n\t\t\t\t});\n\t\t\t}, 100);\n\t\t}\n\t}\n\n\tfunction onDragCancel(e: CustomEvent<DragCancelDetail>): void {\n\t\tconst wasPointerDrag = dragSource === 'pointer';\n\t\tisDragging = false;\n\t\tdragSource = null;\n\t\tstopScrollLoop();\n\t\tif (wasPointerDrag) {\n\t\t\twindow.removeEventListener('pointermove', onPointerMove);\n\t\t}\n\t}\n\n\tfunction onSelect(e: CustomEvent<SelectDetail>): void {\n\t\tif (!scrollOnSelect || mode === 'off') return;\n\n\t\t// Don't scroll during drag - the drag handles its own scrolling\n\t\tif (isDragging) return;\n\n\t\tscrollTo(e.detail.item);\n\t}\n\n\tconst removeListeners = listenEvents(gridElement, {\n\t\t'egg-drag-start': onDragStart as EventListener,\n\t\t'egg-drag-move': onDragMove as EventListener,\n\t\t'egg-drag-end': onDragEnd as EventListener,\n\t\t'egg-drag-cancel': onDragCancel as EventListener,\n\t\t'egg-select': onSelect as EventListener,\n\t});\n\n\tfunction destroy(): void {\n\t\tstopScrollLoop();\n\t\tremoveListeners();\n\t}\n\n\treturn {\n\t\tsetMode(newMode: CameraMode): void {\n\t\t\tmode = newMode;\n\t\t\tif (mode === 'off') {\n\t\t\t\tstopScrollLoop();\n\t\t\t}\n\t\t},\n\t\tgetMode(): CameraMode {\n\t\t\treturn mode;\n\t\t},\n\t\tscrollTo,\n\t\tstop: stopScrollLoop,\n\t\tdestroy,\n\t};\n}\n\n","/**\n * Placeholder plugin for EG Grid\n *\n * Shows a visual placeholder where the dragged item will land.\n * Handles creation, positioning, and cleanup automatically.\n */\n\nimport { listenEvents } from '../engine';\nimport type {\n\tDragStartDetail,\n\tDragMoveDetail,\n\tDragEndDetail,\n\tDragCancelDetail,\n\tDropPreviewDetail,\n\tResizeStartDetail,\n\tResizeMoveDetail,\n\tResizeEndDetail,\n\tResizeCancelDetail,\n} from '../types';\n\nexport interface PlaceholderOptions {\n\t/**\n\t * CSS class name for the placeholder element.\n\t * @default 'egg-placeholder'\n\t */\n\tclassName?: string;\n\n\t/**\n\t * Custom element to use as placeholder instead of creating one.\n\t * If provided, className is ignored.\n\t */\n\telement?: HTMLElement;\n\n\t/**\n\t * Whether to disable view-transition-name on the placeholder.\n\t * Set to true to prevent the placeholder from animating with View Transitions.\n\t * @default true\n\t */\n\tdisableViewTransition?: boolean;\n}\n\nexport interface PlaceholderInstance {\n\t/** Manually show the placeholder at a position */\n\tshow(column: number, row: number, colspan?: number, rowspan?: number): void;\n\t/** Manually hide the placeholder */\n\thide(): void;\n\t/** Remove event listeners and clean up */\n\tdestroy(): void;\n}\n\n/**\n * Attach a placeholder to a EG Grid grid element.\n *\n * @example\n * ```js\n * import { init } from './eg-grid.js';\n * import { attachPlaceholder } from './placeholder.js';\n *\n * const grid = init(document.getElementById('grid'));\n * const placeholder = attachPlaceholder(grid.element);\n *\n * // Later, to clean up:\n * placeholder.destroy();\n * ```\n */\nexport function attachPlaceholder(\n\tgridElement: HTMLElement,\n\toptions: PlaceholderOptions = {}\n): PlaceholderInstance {\n\tconst {\n\t\tclassName = 'egg-placeholder',\n\t\telement: customElement,\n\t\tdisableViewTransition = true,\n\t} = options;\n\n\tlet placeholder: HTMLElement | null = null;\n\tlet isCustomElement = false;\n\n\tfunction create(): void {\n\t\tif (placeholder) return;\n\n\t\tif (customElement) {\n\t\t\tplaceholder = customElement;\n\t\t\tisCustomElement = true;\n\t\t} else {\n\t\t\tplaceholder = document.createElement('div');\n\t\t\tplaceholder.className = className;\n\t\t}\n\n\t\t// Prevent placeholder from interfering with pointer events\n\t\tplaceholder.style.pointerEvents = 'none';\n\n\t\t// Disable view transitions on placeholder to prevent animation artifacts\n\t\tif (disableViewTransition) {\n\t\t\tplaceholder.style.viewTransitionName = 'none';\n\t\t}\n\n\t\tgridElement.appendChild(placeholder);\n\t}\n\n\tfunction update(\n\t\tcolumn: number,\n\t\trow: number,\n\t\tcolspan: number = 1,\n\t\trowspan: number = 1\n\t): void {\n\t\tif (!placeholder) return;\n\t\tplaceholder.style.gridColumn = `${column} / span ${colspan}`;\n\t\tplaceholder.style.gridRow = `${row} / span ${rowspan}`;\n\t}\n\n\tfunction remove(): void {\n\t\tif (placeholder) {\n\t\t\tplaceholder.remove();\n\t\t\t// Only null out if we created it; keep reference if custom\n\t\t\tif (!isCustomElement) {\n\t\t\t\tplaceholder = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Event handlers\n\tfunction handleDragStart(e: CustomEvent<DragStartDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tcreate();\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleDragMove(e: CustomEvent<DragMoveDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\t// Algorithm plugins (e.g. reorder) emit drop-preview when the actual\n\t// landing position differs from the raw pointer cell. Override the\n\t// placeholder position so it shows where the item will really land.\n\tfunction handleDropPreview(e: CustomEvent<DropPreviewDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleDragEnd(_e: CustomEvent<DragEndDetail>): void {\n\t\tremove();\n\t}\n\n\tfunction handleDragCancel(_e: CustomEvent<DragCancelDetail>): void {\n\t\tremove();\n\t}\n\n\t// Resize event handlers\n\t// The placeholder shows where the item will land after resize. For handles that\n\t// change position (NW, NE, SW, N, W), the cell position changes but the anchor\n\t// corner stays fixed. This is correct - the placeholder shows the final landing spot.\n\tfunction handleResizeStart(e: CustomEvent<ResizeStartDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tcreate();\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleResizeMove(e: CustomEvent<ResizeMoveDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleResizeEnd(_e: CustomEvent<ResizeEndDetail>): void {\n\t\tremove();\n\t}\n\n\tfunction handleResizeCancel(_e: CustomEvent<ResizeCancelDetail>): void {\n\t\tremove();\n\t}\n\n\t// Fallback cleanup for edge cases (pointer released outside window, etc.)\n\tfunction handlePointerUp(): void {\n\t\trequestAnimationFrame(() => {\n\t\t\tif (\n\t\t\t\tplaceholder &&\n\t\t\t\t!document.querySelector('[data-egg-dragging]') &&\n\t\t\t\t!document.querySelector('[data-egg-resizing]')\n\t\t\t) {\n\t\t\t\tremove();\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction handlePointerCancel(): void {\n\t\tremove();\n\t}\n\n\t// Attach listeners\n\tconst removeGridListeners = listenEvents(gridElement, {\n\t\t'egg-drag-start': handleDragStart as EventListener,\n\t\t'egg-drag-move': handleDragMove as EventListener,\n\t\t'egg-drag-end': handleDragEnd as EventListener,\n\t\t'egg-drag-cancel': handleDragCancel as EventListener,\n\t\t'egg-drop-preview': handleDropPreview as EventListener,\n\t\t'egg-resize-start': handleResizeStart as EventListener,\n\t\t'egg-resize-move': handleResizeMove as EventListener,\n\t\t'egg-resize-end': handleResizeEnd as EventListener,\n\t\t'egg-resize-cancel': handleResizeCancel as EventListener,\n\t});\n\tconst removeDocListeners = listenEvents(document, {\n\t\tpointerup: handlePointerUp,\n\t\tpointercancel: handlePointerCancel,\n\t});\n\n\t// Public API\n\treturn {\n\t\tshow(\n\t\t\tcolumn: number,\n\t\t\trow: number,\n\t\t\tcolspan: number = 1,\n\t\t\trowspan: number = 1\n\t\t): void {\n\t\t\tcreate();\n\t\t\tupdate(column, row, colspan, rowspan);\n\t\t},\n\n\t\thide(): void {\n\t\t\tremove();\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tremove();\n\t\t\tremoveGridListeners();\n\t\t\tremoveDocListeners();\n\t\t},\n\t};\n}\n\n","/**\n * Shared DOM integration harness for layout algorithms.\n *\n * Provides the boilerplate that every algorithm needs: event listeners for\n * drag/resize, View Transitions, CSS injection via StyleManager, layout\n * provider registration, camera-settled handling, and cleanup.\n *\n * Individual algorithms implement AlgorithmStrategy and call attachAlgorithm().\n */\n\nimport { listenEvents } from \"../engine\";\nimport type {\n  DragEndDetail,\n  DragMoveDetail,\n  DragStartDetail,\n  DragSource,\n  GridCell,\n  EggCore,\n  ItemPosition,\n  LayoutChangeDetail,\n  ResizeCancelDetail,\n  ResizeEndDetail,\n  ResizeMoveDetail,\n  ResizeStartDetail,\n  ResponsiveLayoutModel,\n  StyleManager,\n} from \"../types\";\n\n// ============================================================================\n// Shared types (originally in algorithm-push-core.ts)\n// ============================================================================\n\nexport interface ItemRect {\n  id: string;\n  column: number;\n  row: number;\n  width: number;\n  height: number;\n}\n\n/**\n * Options for CSS generation\n */\nexport interface LayoutToCSSOptions {\n  selectorPrefix?: string;\n  selectorSuffix?: string;\n  excludeSelector?: string;\n  maxColumns?: number;\n}\n\n// ============================================================================\n// Shared pure functions\n// ============================================================================\n\n/**\n * Convert layout to CSS rules for injection into a <style> tag.\n */\nexport function layoutToCSS(\n  items: ItemRect[],\n  options: LayoutToCSSOptions = {},\n): string {\n  const {\n    selectorPrefix = '[data-egg-item=\"',\n    selectorSuffix = '\"]',\n    excludeSelector = \"\",\n    maxColumns,\n  } = options;\n\n  const rules: string[] = [];\n\n  for (const item of items) {\n    const width = maxColumns ? Math.min(item.width, maxColumns) : item.width;\n    const column = maxColumns\n      ? Math.max(1, Math.min(item.column, maxColumns - width + 1))\n      : item.column;\n    const selector = `${selectorPrefix}${item.id}${selectorSuffix}${excludeSelector}`;\n    const gridColumn = `${column} / span ${width}`;\n    const gridRow = `${item.row} / span ${item.height}`;\n\n    rules.push(\n      `${selector} { grid-column: ${gridColumn}; grid-row: ${gridRow}; }`,\n    );\n  }\n\n  return rules.join(\"\\n\");\n}\n\n/**\n * Read item positions from DOM elements\n */\nexport function readItemsFromDOM(container: HTMLElement): ItemRect[] {\n  const elements = container.querySelectorAll(\"[data-egg-item]\");\n  return Array.from(elements).map((el) => {\n    const element = el as HTMLElement;\n    const style = getComputedStyle(element);\n    const column = parseInt(style.gridColumnStart, 10) || 1;\n    const row = parseInt(style.gridRowStart, 10) || 1;\n    const width =\n      parseInt(element.getAttribute(\"data-egg-colspan\") || \"1\", 10) || 1;\n    const height =\n      parseInt(element.getAttribute(\"data-egg-rowspan\") || \"1\", 10) || 1;\n    const id = element.dataset.eggItem || element.dataset.id || \"\";\n\n    return { id, column, row, width, height };\n  });\n}\n\n// ============================================================================\n// Strategy interface\n// ============================================================================\n\nexport interface AlgorithmStrategy {\n  /** Calculate layout after a drag move/end */\n  calculateDragLayout(\n    items: ItemRect[],\n    movedId: string,\n    targetCell: GridCell,\n    columns: number,\n  ): ItemRect[];\n\n  /** Optional hook called after drag-move layout is applied (e.g. emit drop-preview) */\n  afterDragMove?(\n    layout: ItemRect[],\n    movedId: string,\n    gridElement: HTMLElement,\n  ): void;\n\n  /** Calculate layout after a resize move/end. If undefined, resize events are ignored. */\n  calculateResizeLayout?(\n    items: ItemRect[],\n    resizedId: string,\n    cell: GridCell,\n    colspan: number,\n    rowspan: number,\n    columns: number,\n  ): ItemRect[];\n}\n\n// ============================================================================\n// Harness options\n// ============================================================================\n\nexport interface AlgorithmHarnessOptions {\n  selectorPrefix?: string;\n  selectorSuffix?: string;\n  core?: EggCore;\n  layoutModel?: ResponsiveLayoutModel;\n}\n\n// ============================================================================\n// attachAlgorithm — shared DOM integration\n// ============================================================================\n\n/**\n * Attach a layout algorithm strategy to a grid element.\n *\n * Handles all DOM event wiring, View Transitions, CSS injection, layout model\n * persistence, and cleanup. The strategy only needs to provide pure layout\n * calculation functions.\n *\n * @param gridElement - The grid container element\n * @param strategy - Algorithm-specific layout functions\n * @param options - Configuration options\n * @returns Cleanup function to detach the algorithm\n */\nexport function attachAlgorithm(\n  gridElement: HTMLElement,\n  strategy: AlgorithmStrategy,\n  options: AlgorithmHarnessOptions = {},\n): () => void {\n  const {\n    selectorPrefix = '[data-egg-item=\"',\n    selectorSuffix = '\"]',\n    core,\n    layoutModel,\n  } = options;\n  const styles: StyleManager | null = core?.styles ?? null;\n\n  function getCurrentColumnCount(): number {\n    const style = getComputedStyle(gridElement);\n    const columns = style.gridTemplateColumns.split(\" \").filter(Boolean);\n    return Math.max(1, columns.length);\n  }\n\n  let originalPositions: Map<string, { column: number; row: number }> | null =\n    null;\n  let draggedItemId: string | null = null;\n  let draggedElement: HTMLElement | null = null;\n  let dragSource: DragSource | null = null;\n  let layoutVersion = 0;\n  let currentLayout: ItemRect[] | null = null;\n  let dragStartColumnCount: number | null = null;\n\n  // Resize state\n  let resizedItemId: string | null = null;\n  let resizedElement: HTMLElement | null = null;\n  let resizeSource: DragSource | null = null;\n  let resizeOriginalPositions: Map<\n    string,\n    { column: number; row: number; width: number; height: number }\n  > | null = null;\n  let lastResizeLayout: {\n    cell: GridCell;\n    colspan: number;\n    rowspan: number;\n  } | null = null;\n  let resizeStartColumnCount: number | null = null;\n\n  function getItemId(element: HTMLElement): string {\n    return element.dataset.eggItem || element.dataset.id || \"\";\n  }\n\n  /** Read items from DOM with original positions restored (except the actively dragged item) */\n  function getItemsWithOriginals(\n    excludeId: string | null,\n    originals: Map<string, { column: number; row: number }>,\n  ): ItemRect[] {\n    return readItemsFromDOM(gridElement).map((item) => {\n      const original = originals.get(item.id);\n      if (original && item.id !== excludeId) {\n        return { ...item, column: original.column, row: original.row };\n      }\n      return item;\n    });\n  }\n\n  /** Build resize items from original positions, with resized item updated */\n  function getResizeItems(\n    originals: Map<\n      string,\n      { column: number; row: number; width: number; height: number }\n    >,\n    resizedId: string,\n    cell: GridCell,\n    colspan: number,\n    rowspan: number,\n  ): ItemRect[] {\n    const items: ItemRect[] = [];\n    for (const [id, original] of originals) {\n      if (id === resizedId) {\n        items.push({\n          id,\n          column: cell.column,\n          row: cell.row,\n          width: colspan,\n          height: rowspan,\n        });\n      } else {\n        items.push({\n          id,\n          column: original.column,\n          row: original.row,\n          width: original.width,\n          height: original.height,\n        });\n      }\n    }\n    return items;\n  }\n\n  function saveAndClearPreview(\n    layout: ItemRect[],\n    columnCount: number,\n    afterSave?: () => void,\n  ): void {\n    if (!layoutModel || !columnCount) return;\n    const positions = new Map<string, ItemPosition>();\n    for (const item of layout) {\n      positions.set(item.id, { column: item.column, row: item.row });\n    }\n    layoutModel.saveLayout(columnCount, positions);\n    if (afterSave) afterSave();\n    if (styles) {\n      styles.clear(\"preview\");\n      styles.commit();\n    }\n\n    // Emit layout-change only on settled layouts (drag-end / resize-end)\n    if (core) {\n      core.emit<LayoutChangeDetail>(\"layout-change\", {\n        items: layout,\n        columnCount,\n      });\n    }\n  }\n\n  function applyLayout(\n    layout: ItemRect[],\n    excludeId: string | null,\n    useViewTransition: boolean,\n    onApplied?: () => void,\n  ): void {\n    const thisVersion = ++layoutVersion;\n    currentLayout = layout;\n    const capturedColumnCount = dragStartColumnCount ?? resizeStartColumnCount;\n\n    const applyChanges = () => {\n      if (thisVersion !== layoutVersion) return;\n\n      if (styles) {\n        const itemsToStyle = excludeId\n          ? layout.filter((item) => item.id !== excludeId)\n          : layout;\n        const css = layoutToCSS(itemsToStyle, {\n          selectorPrefix,\n          selectorSuffix,\n          maxColumns: capturedColumnCount ?? undefined,\n        });\n        styles.set(\"preview\", css);\n        styles.commit();\n\n        const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n        for (const el of elements) {\n          const element = el as HTMLElement;\n          const id = getItemId(element);\n          const vtn = element.style.viewTransitionName;\n          if (id !== excludeId && vtn !== \"none\") {\n            element.style.gridColumn = \"\";\n            element.style.gridRow = \"\";\n          }\n        }\n      } else {\n        const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n        for (const el of elements) {\n          const element = el as HTMLElement;\n          const id = getItemId(element);\n          if (id === excludeId) continue;\n          const item = layout.find((it) => it.id === id);\n          if (item) {\n            const colspan =\n              parseInt(\n                element.getAttribute(\"data-egg-colspan\") || \"1\",\n                10,\n              ) || 1;\n            const rowspan =\n              parseInt(\n                element.getAttribute(\"data-egg-rowspan\") || \"1\",\n                10,\n              ) || 1;\n            element.style.gridColumn = `${item.column} / span ${colspan}`;\n            element.style.gridRow = `${item.row} / span ${rowspan}`;\n          }\n        }\n      }\n\n      if (onApplied) onApplied();\n    };\n\n    if (useViewTransition && \"startViewTransition\" in document) {\n      if (draggedElement && excludeId) {\n        draggedElement.style.viewTransitionName = \"dragging\";\n      }\n      (document as any).startViewTransition(applyChanges);\n    } else {\n      applyChanges();\n    }\n  }\n\n  // =========================================================================\n  // Drag event handlers\n  // =========================================================================\n\n  const onDragStart = (e: Event) => {\n    const detail = (e as CustomEvent<DragStartDetail>).detail;\n    draggedElement = detail.item;\n    draggedItemId = getItemId(detail.item);\n    dragSource = detail.source;\n    dragStartColumnCount = getCurrentColumnCount();\n\n    const items = readItemsFromDOM(gridElement);\n    originalPositions = new Map();\n    for (const item of items) {\n      originalPositions.set(item.id, { column: item.column, row: item.row });\n    }\n\n    if (styles) {\n      const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n      for (const el of elements) {\n        const element = el as HTMLElement;\n        if (element !== draggedElement) {\n          element.style.gridColumn = \"\";\n          element.style.gridRow = \"\";\n        }\n      }\n      const css = layoutToCSS(items, {\n        selectorPrefix,\n        selectorSuffix,\n        maxColumns: dragStartColumnCount,\n      });\n      styles.set(\"preview\", css);\n      styles.commit();\n    }\n  };\n\n  let pendingCell: GridCell | null = null;\n\n  const onDragMove = (e: Event) => {\n    if (!draggedItemId || !originalPositions) return;\n    const detail = (e as CustomEvent<DragMoveDetail>).detail;\n\n    if (core?.cameraScrolling) {\n      pendingCell = detail.cell;\n      return;\n    }\n    pendingCell = null;\n\n    const items = getItemsWithOriginals(draggedItemId, originalPositions!);\n    const columns = dragStartColumnCount ?? getCurrentColumnCount();\n    const newLayout = strategy.calculateDragLayout(\n      items,\n      draggedItemId,\n      detail.cell,\n      columns,\n    );\n    applyLayout(newLayout, draggedItemId, true);\n\n    if (strategy.afterDragMove) {\n      strategy.afterDragMove(newLayout, draggedItemId, gridElement);\n    }\n  };\n\n  const onDragEnd = (e: Event) => {\n    if (!draggedItemId || !originalPositions) return;\n    const detail = (e as CustomEvent<DragEndDetail>).detail;\n    const items = getItemsWithOriginals(draggedItemId, originalPositions!);\n\n    const columns = dragStartColumnCount ?? getCurrentColumnCount();\n    const finalLayout = strategy.calculateDragLayout(\n      items,\n      draggedItemId,\n      detail.cell,\n      columns,\n    );\n\n    const isPointerDrag = dragSource === \"pointer\";\n    if (\n      draggedElement &&\n      draggedElement.style.viewTransitionName === \"dragging\"\n    ) {\n      draggedElement.style.viewTransitionName = \"\";\n    }\n\n    const useViewTransition = !isPointerDrag;\n    const savedDragStartColumnCount = dragStartColumnCount;\n\n    applyLayout(finalLayout, null, useViewTransition, () =>\n      saveAndClearPreview(finalLayout, savedDragStartColumnCount!),\n    );\n\n    draggedItemId = null;\n    draggedElement = null;\n    dragSource = null;\n    originalPositions = null;\n    pendingCell = null;\n    dragStartColumnCount = null;\n  };\n\n  const onDragCancel = () => {\n    if (!draggedItemId || !originalPositions) return;\n\n    if (\n      draggedElement &&\n      draggedElement.style.viewTransitionName === \"dragging\"\n    ) {\n      draggedElement.style.viewTransitionName = \"\";\n    }\n\n    const restoreLayout = getItemsWithOriginals(null, originalPositions!);\n    const restore = () => applyLayout(restoreLayout, null, false);\n\n    if (\"startViewTransition\" in document) {\n      (document as any).startViewTransition(restore);\n    } else {\n      restore();\n    }\n\n    draggedItemId = null;\n    draggedElement = null;\n    dragSource = null;\n    originalPositions = null;\n    pendingCell = null;\n    dragStartColumnCount = null;\n  };\n\n  const onCameraSettled = () => {\n    if (!draggedItemId || !originalPositions) return;\n\n    let cell = pendingCell;\n    if (!cell && draggedElement) {\n      const rect = draggedElement.getBoundingClientRect();\n      const centerX = rect.left + rect.width / 2;\n      const centerY = rect.top + rect.height / 2;\n      cell = core?.getCellFromPoint(centerX, centerY) ?? null;\n    }\n\n    if (!cell) return;\n    pendingCell = null;\n\n    const items = getItemsWithOriginals(draggedItemId, originalPositions!);\n    const columns = dragStartColumnCount ?? getCurrentColumnCount();\n    const newLayout = strategy.calculateDragLayout(\n      items,\n      draggedItemId!,\n      cell,\n      columns,\n    );\n    applyLayout(newLayout, draggedItemId, true);\n\n    if (strategy.afterDragMove) {\n      strategy.afterDragMove(newLayout, draggedItemId!, gridElement);\n    }\n  };\n\n  // =========================================================================\n  // Resize event handlers (only if strategy supports resize)\n  // =========================================================================\n\n  const onResizeStart = (e: Event) => {\n    if (!strategy.calculateResizeLayout) return;\n    const detail = (e as CustomEvent<ResizeStartDetail>).detail;\n    resizedElement = detail.item;\n    resizedItemId = getItemId(detail.item);\n    resizeSource = detail.source;\n    resizeStartColumnCount = getCurrentColumnCount();\n\n    const items = readItemsFromDOM(gridElement);\n    resizeOriginalPositions = new Map();\n    for (const item of items) {\n      resizeOriginalPositions.set(item.id, {\n        column: item.column,\n        row: item.row,\n        width: item.width,\n        height: item.height,\n      });\n    }\n\n    if (styles) {\n      const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n      for (const el of elements) {\n        const element = el as HTMLElement;\n        if (element !== resizedElement) {\n          element.style.gridColumn = \"\";\n          element.style.gridRow = \"\";\n        }\n      }\n      const css = layoutToCSS(items, {\n        selectorPrefix,\n        selectorSuffix,\n        maxColumns: resizeStartColumnCount,\n      });\n      styles.set(\"preview\", css);\n      styles.commit();\n    }\n\n    lastResizeLayout = null;\n  };\n\n  const onResizeMove = (e: Event) => {\n    if (!strategy.calculateResizeLayout) return;\n    if (!resizedItemId || !resizeOriginalPositions) return;\n    const detail = (e as CustomEvent<ResizeMoveDetail>).detail;\n\n    if (\n      lastResizeLayout &&\n      lastResizeLayout.cell.column === detail.cell.column &&\n      lastResizeLayout.cell.row === detail.cell.row &&\n      lastResizeLayout.colspan === detail.colspan &&\n      lastResizeLayout.rowspan === detail.rowspan\n    ) {\n      return;\n    }\n    lastResizeLayout = {\n      cell: { ...detail.cell },\n      colspan: detail.colspan,\n      rowspan: detail.rowspan,\n    };\n\n    const items = getResizeItems(\n      resizeOriginalPositions,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n    );\n    const columns = resizeStartColumnCount ?? getCurrentColumnCount();\n    const newLayout = strategy.calculateResizeLayout(\n      items,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n      columns,\n    );\n    applyLayout(newLayout, resizedItemId, true);\n  };\n\n  const onResizeEnd = (e: Event) => {\n    if (!strategy.calculateResizeLayout) return;\n    if (!resizedItemId || !resizeOriginalPositions) return;\n    const detail = (e as CustomEvent<ResizeEndDetail>).detail;\n    const items = getResizeItems(\n      resizeOriginalPositions,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n    );\n\n    const columns = resizeStartColumnCount ?? getCurrentColumnCount();\n    const finalLayout = strategy.calculateResizeLayout(\n      items,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n      columns,\n    );\n\n    const isPointerResize = resizeSource === \"pointer\";\n    const useViewTransition = !isPointerResize;\n    const savedResizedItemId = resizedItemId;\n    const savedResizeStartColumnCount = resizeStartColumnCount;\n\n    applyLayout(finalLayout, null, useViewTransition, () =>\n      saveAndClearPreview(finalLayout, savedResizeStartColumnCount!, () => {\n        layoutModel!.updateItemSize(savedResizedItemId!, {\n          width: detail.colspan,\n          height: detail.rowspan,\n        });\n      }),\n    );\n\n    resizedItemId = null;\n    resizedElement = null;\n    resizeSource = null;\n    resizeOriginalPositions = null;\n    lastResizeLayout = null;\n    resizeStartColumnCount = null;\n  };\n\n  const onResizeCancel = () => {\n    if (!resizedItemId || !resizeOriginalPositions) return;\n\n    const restoreLayout = Array.from(resizeOriginalPositions, ([id, o]) => ({\n      id,\n      column: o.column,\n      row: o.row,\n      width: o.width,\n      height: o.height,\n    }));\n    const restore = () => applyLayout(restoreLayout, null, false);\n\n    if (\"startViewTransition\" in document) {\n      (document as any).startViewTransition(restore);\n    } else {\n      restore();\n    }\n\n    resizedItemId = null;\n    resizedElement = null;\n    resizeSource = null;\n    resizeOriginalPositions = null;\n    lastResizeLayout = null;\n    resizeStartColumnCount = null;\n  };\n\n  // =========================================================================\n  // Event listener registration\n  // =========================================================================\n\n  return listenEvents(gridElement, {\n    \"egg-drag-start\": onDragStart,\n    \"egg-drag-move\": onDragMove,\n    \"egg-drag-end\": onDragEnd,\n    \"egg-drag-cancel\": onDragCancel,\n    \"egg-camera-settled\": onCameraSettled,\n    \"egg-resize-start\": onResizeStart,\n    \"egg-resize-move\": onResizeMove,\n    \"egg-resize-end\": onResizeEnd,\n    \"egg-resize-cancel\": onResizeCancel,\n  });\n}\n","/**\n * Push-down layout algorithm for EG Grid\n *\n * This module provides both:\n * 1. Pure algorithm functions (overlap detection, push-down, compaction)\n * 2. DOM integration via the shared algorithm harness\n *\n * Usage (pure functions):\n *   import { calculateLayout, layoutToCSS } from 'eg-grid/algorithm-push';\n *   const newLayout = calculateLayout(items, movedId, targetCell);\n *   core.styles.set('preview', layoutToCSS(newLayout));\n *   core.styles.commit();\n *\n * Usage (DOM integration):\n *   import { init } from 'eg-grid';\n *   import { attachPushAlgorithm } from 'eg-grid/algorithm-push';\n *\n *   const grid = init(element);\n *   const detach = attachPushAlgorithm(grid.element);\n */\n\nimport type {\n\tGridCell,\n\tEggCore,\n\tResponsiveLayoutModel,\n} from '../types';\n\nimport {\n\tattachAlgorithm,\n\ttype AlgorithmHarnessOptions,\n\ttype AlgorithmStrategy,\n\ttype ItemRect,\n} from './algorithm-harness';\n\n// Re-export shared types and functions from harness\nexport {\n\tlayoutToCSS,\n\treadItemsFromDOM,\n\ttype ItemRect,\n\ttype LayoutToCSSOptions,\n} from './algorithm-harness';\n\n// Also re-export GridCell so consumers don't need to import from types.ts\nexport type { GridCell } from '../types';\n\n// ============================================================================\n// Pure push-down algorithm\n// ============================================================================\n\n/**\n * Check if two items overlap\n */\nexport function itemsOverlap(a: ItemRect, b: ItemRect): boolean {\n\treturn !(\n\t\ta.column + a.width <= b.column ||\n\t\tb.column + b.width <= a.column ||\n\t\ta.row + a.height <= b.row ||\n\t\tb.row + b.height <= a.row\n\t);\n}\n\n/**\n * Check if any items in the layout overlap\n * @returns Array of overlapping pairs, empty if no overlaps\n */\nexport function findOverlaps(items: ItemRect[]): Array<[ItemRect, ItemRect]> {\n\tconst overlaps: Array<[ItemRect, ItemRect]> = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tfor (let j = i + 1; j < items.length; j++) {\n\t\t\tif (itemsOverlap(items[i], items[j])) {\n\t\t\t\toverlaps.push([items[i], items[j]]);\n\t\t\t}\n\t\t}\n\t}\n\treturn overlaps;\n}\n\n/**\n * Push items down recursively to resolve collisions\n * Mutates the items array in place\n */\nexport function pushDown(\n\titems: ItemRect[],\n\tmoved: ItemRect,\n\tmovedId: string,\n\tdepth = 0,\n): void {\n\tif (depth > 50) {\n\t\treturn;\n\t}\n\n\t// Sort by row descending - push bottom items first so upper items settle on top\n\t// This preserves the original relative ordering of items\n\tconst colliders = items\n\t\t.filter((it) => it.id !== movedId && it.id !== moved.id && itemsOverlap(moved, it))\n\t\t.sort((a, b) => b.row - a.row || a.column - b.column);\n\n\tfor (const collider of colliders) {\n\t\tconst newRow = moved.row + moved.height;\n\t\tif (collider.row < newRow) {\n\t\t\tcollider.row = newRow;\n\t\t\tpushDown(items, collider, movedId, depth + 1);\n\t\t}\n\t}\n}\n\n/**\n * Compact items upward to fill gaps\n * Mutates the items array in place\n */\nexport function compactUp(items: ItemRect[], excludeId: string): void {\n\tconst sorted = [...items]\n\t\t.filter((it) => it.id !== excludeId)\n\t\t.sort((a, b) => a.row - b.row || a.column - b.column);\n\n\tfor (const item of sorted) {\n\t\tlet iterations = 0;\n\t\twhile (item.row > 1 && iterations < 100) {\n\t\t\titerations++;\n\t\t\titem.row -= 1;\n\t\t\tconst hasCollision = items.some(\n\t\t\t\t(other) => other.id !== item.id && itemsOverlap(item, other),\n\t\t\t);\n\t\t\tif (hasCollision) {\n\t\t\t\titem.row += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Options for calculateLayout\n */\nexport interface CalculateLayoutOptions {\n\t/**\n\t * Whether to compact items upward after resolving collisions (default: true)\n\t */\n\tcompact?: boolean;\n}\n\n/**\n * Calculate new layout after moving an item\n * Returns a new array with updated positions\n */\nexport function calculateLayout(\n\titems: ItemRect[],\n\tmovedId: string,\n\ttargetCell: GridCell,\n\toptions: CalculateLayoutOptions = {},\n): ItemRect[] {\n\tconst { compact = true } = options;\n\n\t// Deep copy items\n\tconst result = items.map((item) => ({ ...item }));\n\n\tconst movedItem = result.find((it) => it.id === movedId);\n\tif (!movedItem) return result;\n\n\tmovedItem.column = targetCell.column;\n\tmovedItem.row = targetCell.row;\n\n\tpushDown(result, movedItem, movedId);\n\tif (compact) {\n\t\tcompactUp(result, movedId);\n\t}\n\n\treturn result;\n}\n\n// ============================================================================\n// DOM integration via harness\n// ============================================================================\n\n/**\n * Options for attachPushAlgorithm\n */\nexport interface AttachPushAlgorithmOptions {\n\tselectorPrefix?: string;\n\tselectorSuffix?: string;\n\t/**\n\t * Whether to compact items upward after resolving collisions (default: true)\n\t * When false, items only get pushed down but won't float back up to fill gaps.\n\t */\n\tcompaction?: boolean;\n\tcore?: EggCore;\n\tlayoutModel?: ResponsiveLayoutModel;\n}\n\n/**\n * Attach push-down algorithm to a grid element.\n *\n * This creates event listeners for eg-grid drag events and updates\n * the layout when items are moved. Layout changes are animated\n * via View Transitions.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach the algorithm\n */\nexport function attachPushAlgorithm(\n\tgridElement: HTMLElement,\n\toptions: AttachPushAlgorithmOptions = {},\n): () => void {\n\tconst { compaction = true, ...harnessOptions } = options;\n\n\tconst strategy: AlgorithmStrategy = {\n\t\tcalculateDragLayout(items, movedId, targetCell) {\n\t\t\treturn calculateLayout(items, movedId, targetCell, { compact: compaction });\n\t\t},\n\t\tcalculateResizeLayout(items, resizedId, cell) {\n\t\t\treturn calculateLayout(items, resizedId, cell, { compact: compaction });\n\t\t},\n\t};\n\n\treturn attachAlgorithm(gridElement, strategy, harnessOptions);\n}\n\n","/**\n * Reorder layout algorithm for EG Grid\n *\n * Sequence-based reflow: items have a logical order, dragging changes\n * position in that sequence, all items reflow like CSS Grid auto-placement.\n *\n * Usage (pure functions):\n *   import { calculateReorderLayout, reflowItems, layoutToCSS } from 'eg-grid/algorithm-reorder';\n *\n * Usage (DOM integration):\n *   import { attachReorderAlgorithm } from 'eg-grid/algorithm-reorder';\n *   const detach = attachReorderAlgorithm(grid.element, { core });\n */\n\nimport type {\n\tGridCell,\n\tEggCore,\n\tResponsiveLayoutModel,\n} from '../types';\n\nimport {\n\tattachAlgorithm,\n\ttype AlgorithmStrategy,\n\ttype ItemRect,\n} from './algorithm-harness';\n\n// Re-export shared types and functions from harness\nexport {\n\tlayoutToCSS,\n\ttype ItemRect,\n\ttype LayoutToCSSOptions,\n} from './algorithm-harness';\n\n// Also re-export GridCell so consumers don't need to import from types.ts\nexport type { GridCell } from '../types';\n\n// ============================================================================\n// Pure reorder algorithm\n// ============================================================================\n\n/**\n * Sort items into reading order (row-major: row first, then column)\n */\nexport function getItemOrder(items: ItemRect[]): ItemRect[] {\n\treturn [...items].sort((a, b) => a.row - b.row || a.column - b.column);\n}\n\n/**\n * Check if a cell range is available (not occupied)\n */\nfunction rangeAvailable(\n\toccupied: Set<string>,\n\tcolumn: number,\n\trow: number,\n\twidth: number,\n\theight: number,\n\tcolumns: number,\n): boolean {\n\tif (column + width - 1 > columns) return false;\n\n\tfor (let r = row; r < row + height; r++) {\n\t\tfor (let c = column; c < column + width; c++) {\n\t\t\tif (occupied.has(`${c},${r}`)) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Mark cells as occupied\n */\nfunction markOccupied(\n\toccupied: Set<string>,\n\tcolumn: number,\n\trow: number,\n\twidth: number,\n\theight: number,\n): void {\n\tfor (let r = row; r < row + height; r++) {\n\t\tfor (let c = column; c < column + width; c++) {\n\t\t\toccupied.add(`${c},${r}`);\n\t\t}\n\t}\n}\n\n/**\n * Reflow items into grid positions using auto-placement.\n * Scans left-to-right, top-to-bottom for the first position each item fits.\n *\n * @param items - Items in logical order (sequence determines placement priority)\n * @param columns - Number of grid columns\n * @returns New array with updated positions\n */\nexport function reflowItems(items: ItemRect[], columns: number): ItemRect[] {\n\tconst occupied = new Set<string>();\n\tconst result: ItemRect[] = [];\n\n\tfor (const item of items) {\n\t\tconst width = Math.min(item.width, columns);\n\t\tlet placed = false;\n\n\t\tfor (let row = 1; !placed; row++) {\n\t\t\tfor (let col = 1; col <= columns; col++) {\n\t\t\t\tif (rangeAvailable(occupied, col, row, width, item.height, columns)) {\n\t\t\t\t\tmarkOccupied(occupied, col, row, width, item.height);\n\t\t\t\t\tresult.push({ ...item, column: col, row, width });\n\t\t\t\t\tplaced = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Safety: prevent infinite loop on pathological inputs\n\t\t\tif (row > 100) {\n\t\t\t\tresult.push({ ...item, column: 1, row, width });\n\t\t\t\tmarkOccupied(occupied, 1, row, width, item.height);\n\t\t\t\tplaced = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Compare positions in reading order (row-major)\n */\nfunction positionBefore(a: GridCell, b: GridCell): boolean {\n\treturn a.row < b.row || (a.row === b.row && a.column < b.column);\n}\n\n/**\n * Options for calculateReorderLayout\n */\nexport interface CalculateReorderLayoutOptions {\n\t/** Number of grid columns */\n\tcolumns: number;\n}\n\n/**\n * Calculate new layout after reordering an item.\n *\n * 1. Sort items by current position to get logical order\n * 2. Remove moved item from sequence\n * 3. Reflow remaining items to get candidate positions\n * 4. Find insertion index: before the first candidate whose reflowed position\n *    comes after targetCell in reading order\n * 5. Insert moved item at that index\n * 6. Reflow all items\n *\n * @returns New array with updated positions\n */\nexport function calculateReorderLayout(\n\titems: ItemRect[],\n\tmovedId: string,\n\ttargetCell: GridCell,\n\toptions: CalculateReorderLayoutOptions,\n): ItemRect[] {\n\tconst { columns } = options;\n\n\t// Deep copy items\n\tconst all = items.map((item) => ({ ...item }));\n\n\t// Get logical order from current positions\n\tconst ordered = getItemOrder(all);\n\n\t// Extract moved item\n\tconst movedItem = ordered.find((it) => it.id === movedId);\n\tif (!movedItem) return reflowItems(ordered, columns);\n\n\tconst remaining = ordered.filter((it) => it.id !== movedId);\n\n\t// Reflow remaining to get candidate positions\n\tconst reflowed = reflowItems(remaining, columns);\n\n\t// Find insertion index: before the first reflowed item whose position\n\t// comes after targetCell in reading order\n\tlet insertIndex = reflowed.length; // default: append at end\n\tfor (let i = 0; i < reflowed.length; i++) {\n\t\tif (!positionBefore(reflowed[i], targetCell)) {\n\t\t\tinsertIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Build final sequence with moved item inserted\n\tconst finalSequence: ItemRect[] = [\n\t\t...remaining.slice(0, insertIndex),\n\t\tmovedItem,\n\t\t...remaining.slice(insertIndex),\n\t];\n\n\t// Reflow everything\n\treturn reflowItems(finalSequence, columns);\n}\n\n// ============================================================================\n// DOM integration via harness\n// ============================================================================\n\n/**\n * Options for attachReorderAlgorithm\n */\nexport interface AttachReorderAlgorithmOptions {\n\tselectorPrefix?: string;\n\tselectorSuffix?: string;\n\tcore?: EggCore;\n\tlayoutModel?: ResponsiveLayoutModel;\n}\n\n/**\n * Attach reorder algorithm to a grid element.\n *\n * Listens to drag/resize events and reflows items in sequence order.\n * Layout changes are animated via View Transitions.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach the algorithm\n */\nexport function attachReorderAlgorithm(\n\tgridElement: HTMLElement,\n\toptions: AttachReorderAlgorithmOptions = {},\n): () => void {\n\tconst strategy: AlgorithmStrategy = {\n\t\tcalculateDragLayout(items, movedId, targetCell, columns) {\n\t\t\treturn calculateReorderLayout(items, movedId, targetCell, { columns });\n\t\t},\n\n\t\tafterDragMove(layout, movedId, el) {\n\t\t\t// Emit drop-preview so the placeholder knows the actual landing position.\n\t\t\t// Use queueMicrotask to ensure this fires AFTER all drag-move handlers\n\t\t\t// (including the placeholder's) have finished, regardless of listener order.\n\t\t\tconst landingItem = layout.find((it) => it.id === movedId);\n\t\t\tif (landingItem) {\n\t\t\t\tconst previewDetail = {\n\t\t\t\t\tcell: { column: landingItem.column, row: landingItem.row },\n\t\t\t\t\tcolspan: landingItem.width,\n\t\t\t\t\trowspan: landingItem.height,\n\t\t\t\t};\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tel.dispatchEvent(new CustomEvent('egg-drop-preview', {\n\t\t\t\t\t\tdetail: previewDetail,\n\t\t\t\t\t\tbubbles: true,\n\t\t\t\t\t}));\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tcalculateResizeLayout(items, _resizedId, _cell, _colspan, _rowspan, columns) {\n\t\t\t// For resize, reflow all items in their current order with the resized item's new size\n\t\t\tconst ordered = [...items].sort((a, b) => a.row - b.row || a.column - b.column);\n\t\t\treturn reflowItems(ordered, columns);\n\t\t},\n\t};\n\n\treturn attachAlgorithm(gridElement, strategy, options);\n}\n\n","/**\n * Responsive Plugin\n *\n * Handles responsive column detection and CSS injection for different breakpoints.\n *\n * Responsibilities:\n * - Detect column count changes via ResizeObserver\n * - Inject CSS for all breakpoints using container queries\n * - Register 'columnCount' provider for other plugins\n * - Emit 'egg-column-count-change' events\n * - Regenerate CSS when layout model changes\n *\n * CSS is injected once on init and regenerated when the layout model changes.\n * The actual responsive layout switching is handled by CSS container queries.\n */\n\nimport type {\n\tColumnCountChangeDetail,\n\tEggCore,\n\tResponsivePluginOptions,\n\tStyleManager,\n} from '../types';\n\n/**\n * Responsive state exposed via provider registry\n */\nexport interface ResponsiveState {\n\tcolumnCount: number;\n\tmaxColumns: number;\n\tminColumns: number;\n\thasOverride: boolean;\n}\n\n/**\n * Attach the responsive plugin to a grid element.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options including layout model and style element\n * @param core - Optional EggCore for provider registration\n * @returns Cleanup function to detach the plugin\n */\nexport function attachResponsive(\n\tgridElement: HTMLElement,\n\toptions: ResponsivePluginOptions,\n\tcore?: EggCore,\n): () => void {\n\tconst { layoutModel } = options;\n\tconst styles: StyleManager | null = core?.styles ?? null;\n\n\t// Infer cell size and gap from CSS if not provided\n\tlet cellSize = options.cellSize;\n\tlet gap = options.gap;\n\n\tfunction inferGridMetrics(): void {\n\t\tif (cellSize !== undefined && gap !== undefined) return;\n\n\t\tconst style = getComputedStyle(gridElement);\n\n\t\tif (gap === undefined) {\n\t\t\tgap = parseFloat(style.columnGap) || parseFloat(style.gap) || 16;\n\t\t}\n\n\t\tif (cellSize === undefined) {\n\t\t\t// Try to infer from grid-auto-rows or first track\n\t\t\tconst autoRows = parseFloat(style.gridAutoRows) || 0;\n\t\t\tif (autoRows > 0) {\n\t\t\t\tcellSize = autoRows;\n\t\t\t} else {\n\t\t\t\t// Fall back to first column track width\n\t\t\t\tconst columns = style.gridTemplateColumns.split(' ');\n\t\t\t\tcellSize = parseFloat(columns[0] ?? '184') || 184;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Detect current column count from computed grid style\n\t */\n\tfunction detectColumnCount(): number {\n\t\tconst style = getComputedStyle(gridElement);\n\t\tconst columns = style.gridTemplateColumns.split(' ').filter(Boolean);\n\t\treturn Math.max(1, columns.length);\n\t}\n\n\t/**\n\t * Inject CSS for all breakpoints\n\t */\n\tfunction injectCSS(): void {\n\t\tif (!styles) return;\n\n\t\tinferGridMetrics();\n\n\t\t// Use the grid element's class or ID as the selector\n\t\tconst gridSelector = gridElement.id\n\t\t\t? `#${gridElement.id}`\n\t\t\t: gridElement.className\n\t\t\t\t? `.${gridElement.className.split(' ')[0]}`\n\t\t\t\t: '.grid';\n\n\t\tconst css = layoutModel.generateAllBreakpointCSS({\n\t\t\tcellSize: cellSize!,\n\t\t\tgap: gap!,\n\t\t\tgridSelector,\n\t\t});\n\n\t\tstyles.set('base', css);\n\t\tstyles.commit();\n\t}\n\n\t// Track if server-rendered CSS was detected\n\t// When true, we only inject CSS for explicit user overrides, not derived layouts\n\tconst hasServerRenderedCSS = !!(styles?.get('base')?.trim());\n\n\t// Only inject CSS if base layer is empty (not server-rendered)\n\t// This prevents flash when server has already provided initial CSS\n\tif (!hasServerRenderedCSS) {\n\t\tinjectCSS();\n\t}\n\n\t// Subscribe to layout model changes\n\t// The subscription only fires on user actions (saveLayout/clearOverride),\n\t// so we always inject CSS here - the initial hasServerRenderedCSS check\n\t// prevents injection on page load, this handles user interactions.\n\tconst unsubscribe = layoutModel.subscribe(() => injectCSS());\n\n\t// Watch for resize to update column count tracking\n\tlet lastColumnCount = layoutModel.currentColumnCount;\n\n\tconst resizeObserver = new ResizeObserver(() => {\n\t\tconst newColumnCount = detectColumnCount();\n\n\t\tif (newColumnCount !== lastColumnCount) {\n\t\t\tconst previousCount = lastColumnCount;\n\t\t\tlastColumnCount = newColumnCount;\n\n\t\t\t// Update layout model\n\t\t\tlayoutModel.setCurrentColumnCount(newColumnCount);\n\n\t\t\tgridElement.dispatchEvent(\n\t\t\t\tnew CustomEvent('egg-column-count-change', {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail: { previousCount, currentCount: newColumnCount },\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t});\n\n\tresizeObserver.observe(gridElement);\n\n\t// Cleanup function\n\treturn () => {\n\t\tresizeObserver.disconnect();\n\t\tunsubscribe();\n\t};\n}\n\n","import type { GridCell, EggCore, InitOptions, StyleManager } from './types';\nimport { createStateMachine } from './state-machine';\nimport { attachPointer } from './plugins/pointer';\nimport { attachKeyboard } from './plugins/keyboard';\nimport { attachAccessibility } from './plugins/accessibility';\nimport { attachResize } from './plugins/resize';\nimport { attachCamera } from './plugins/camera';\nimport { attachPlaceholder } from './plugins/placeholder';\nimport { attachPushAlgorithm } from './plugins/algorithm-push';\nimport { attachReorderAlgorithm } from './plugins/algorithm-reorder';\nimport { attachResponsive } from './plugins/responsive';\n\n/**\n * Initialize EG Grid on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): EggCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\t// Create centralized state machine\n\tconst stateMachine = createStateMachine();\n\n\t// Track selected element (state machine stores itemId, we need the element)\n\tlet selectedElement: HTMLElement | null = null;\n\n\t// StyleManager: single style element, multiple named layers\n\tconst styleLayers = new Map<string, string>(); // layer name → CSS\n\tconst layerOrder: string[] = []; // insertion order\n\tconst managedStyleElement = styleElement ?? document.createElement('style');\n\tif (!styleElement) {\n\t\tdocument.head.appendChild(managedStyleElement);\n\t\tcleanups.push(() => managedStyleElement.remove());\n\t}\n\n\t// Pre-populate 'base' layer with any existing content (e.g. server-rendered CSS)\n\tconst existingCSS = managedStyleElement.textContent?.trim();\n\tif (existingCSS) {\n\t\tstyleLayers.set('base', existingCSS);\n\t\tlayerOrder.push('base');\n\t}\n\n\tconst styles: StyleManager = {\n\t\tset(layer: string, css: string): void {\n\t\t\tif (!styleLayers.has(layer)) {\n\t\t\t\tlayerOrder.push(layer);\n\t\t\t}\n\t\t\tstyleLayers.set(layer, css);\n\t\t},\n\t\tget(layer: string): string {\n\t\t\treturn styleLayers.get(layer) ?? '';\n\t\t},\n\t\tclear(layer: string): void {\n\t\t\tif (styleLayers.has(layer)) {\n\t\t\t\tstyleLayers.set(layer, '');\n\t\t\t}\n\t\t},\n\t\tcommit(): void {\n\t\t\tconst parts: string[] = [];\n\t\t\tfor (const layer of layerOrder) {\n\t\t\t\tconst css = styleLayers.get(layer);\n\t\t\t\tif (css) parts.push(css);\n\t\t\t}\n\t\t\tmanagedStyleElement.textContent = parts.join('\\n\\n');\n\t\t},\n\t};\n\n\tconst core: EggCore = {\n\t\telement,\n\t\tstateMachine,\n\t\tstyles,\n\t\tcameraScrolling: false,\n\n\t\t// Selection state (backed by state machine)\n\t\tget selectedItem() {\n\t\t\treturn selectedElement;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedElement) return;\n\n\t\t\tconst previousItem = selectedElement;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-egg-selected');\n\t\t\t}\n\n\t\t\t// Update state machine and local element reference\n\t\t\tif (item) {\n\t\t\t\tconst itemId = item.id || item.getAttribute('data-egg-item') || '';\n\t\t\t\tstateMachine.transition({ type: 'SELECT', itemId, element: item });\n\t\t\t\tselectedElement = item;\n\t\t\t\titem.setAttribute('data-egg-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else {\n\t\t\t\tstateMachine.transition({ type: 'DESELECT' });\n\t\t\t\tselectedElement = null;\n\t\t\t\tif (previousItem) {\n\t\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`egg-${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Direct initialization — no registry, no loop\n\tif (options.pointer !== false) {\n\t\tcleanups.push(attachPointer(core));\n\t}\n\tif (options.keyboard !== false) {\n\t\tcleanups.push(attachKeyboard(core));\n\t}\n\tif (options.accessibility !== false) {\n\t\tcleanups.push(attachAccessibility(core));\n\t}\n\n\tif (options.resize !== false) {\n\t\tconst resizeOpts = typeof options.resize === 'object' ? options.resize : {};\n\t\tconst inst = attachResize(element, { ...resizeOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.camera !== false) {\n\t\tconst cameraOpts = typeof options.camera === 'object' ? options.camera : {};\n\t\tconst inst = attachCamera(element, { ...cameraOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.placeholder !== false) {\n\t\tconst placeholderOpts = typeof options.placeholder === 'object' ? options.placeholder : {};\n\t\tconst inst = attachPlaceholder(element, placeholderOpts);\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\t// Algorithm: push (default) or reorder\n\tif (options.algorithm !== false) {\n\t\tconst algoOpts = options.algorithmOptions ?? {};\n\t\tif (options.algorithm === 'reorder') {\n\t\t\tcleanups.push(attachReorderAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t} else {\n\t\t\tcleanups.push(attachPushAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t}\n\t}\n\n\tif (options.responsive) {\n\t\tcleanups.push(attachResponsive(element, options.responsive, core));\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Get the size of an item from its data attributes\n */\nexport function getItemSize(item: HTMLElement): { colspan: number; rowspan: number } {\n\treturn {\n\t\tcolspan: parseInt(item.getAttribute('data-egg-colspan') || '1', 10) || 1,\n\t\trowspan: parseInt(item.getAttribute('data-egg-rowspan') || '1', 10) || 1,\n\t};\n}\n\n/**\n * Attach multiple event listeners and return a cleanup function to remove them all\n */\nexport function listenEvents(\n\telement: EventTarget,\n\tevents: Record<string, EventListenerOrEventListenerObject>,\n): () => void {\n\tfor (const [name, handler] of Object.entries(events)) {\n\t\telement.addEventListener(name, handler);\n\t}\n\treturn () => {\n\t\tfor (const [name, handler] of Object.entries(events)) {\n\t\t\telement.removeEventListener(name, handler);\n\t\t}\n\t};\n}\n","/**\n * Responsive Layout Model\n *\n * Manages layouts across different column counts with a three-tier system:\n * 1. Canonical layout - source of truth at maxColumns\n * 2. Per-column-count overrides - user customizations at specific breakpoints\n * 3. Auto-derived layouts - calculated via compaction for other column counts\n *\n * This module is pure data/logic with no DOM dependencies, making it suitable\n * for use with backend-driven state (e.g., Datastar integration).\n */\n\nimport type {\n\tBreakpointCSSOptions,\n\tCreateLayoutModelOptions,\n\tItemDefinition,\n\tItemPosition,\n\tLayoutItem,\n\tResponsiveLayoutModel,\n} from './types';\n\nconst MAX_ROWS = 100; // Safety limit for layout derivation\n\n/**\n * Create a responsive layout model\n */\nexport function createLayoutModel(\n\toptions: CreateLayoutModelOptions,\n): ResponsiveLayoutModel {\n\tconst { maxColumns, minColumns = 1, items: itemDefs } = options;\n\n\t// Store item definitions\n\tconst items = new Map<string, ItemDefinition>();\n\tfor (const item of itemDefs) {\n\t\titems.set(item.id, { id: item.id, width: item.width, height: item.height });\n\t}\n\n\t// Store canonical positions (at maxColumns)\n\tlet canonicalPositions = new Map<string, ItemPosition>(\n\t\toptions.canonicalPositions,\n\t);\n\n\t// Store per-column-count overrides\n\tconst overrides = new Map<number, Map<string, ItemPosition>>(\n\t\toptions.overrides,\n\t);\n\n\t// Current column count (updated by responsive plugin)\n\tlet currentColumnCount = maxColumns;\n\n\t// Subscribers for layout changes\n\tconst subscribers = new Set<() => void>();\n\n\tfunction notifySubscribers(): void {\n\t\tfor (const callback of Array.from(subscribers)) {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * Get items sorted by position (top-to-bottom, left-to-right)\n\t * Used for consistent ordering in layout derivation\n\t */\n\tfunction getItemsInPositionOrder(\n\t\tpositions: Map<string, ItemPosition>,\n\t): ItemDefinition[] {\n\t\treturn Array.from(items.values()).sort((a, b) => {\n\t\t\tconst posA = positions.get(a.id) ?? { column: 0, row: 0 };\n\t\t\tconst posB = positions.get(b.id) ?? { column: 0, row: 0 };\n\t\t\t// Sort by row first, then column\n\t\t\treturn posA.row - posB.row || posA.column - posB.column;\n\t\t});\n\t}\n\n\t/**\n\t * Derive layout for a given column count using first-fit compaction.\n\t * Items are placed in position order (top-to-bottom, left-to-right)\n\t * into the first available space that fits.\n\t */\n\tfunction deriveLayoutForColumns(\n\t\tcols: number,\n\t\tsourcePositions: Map<string, ItemPosition>,\n\t): Map<string, ItemPosition> {\n\t\tconst sorted = getItemsInPositionOrder(sourcePositions);\n\t\tconst result = new Map<string, ItemPosition>();\n\n\t\t// 2D occupancy grid: occupied[row][col] = itemId or null\n\t\tconst occupied: (string | null)[][] = [];\n\t\tfor (let r = 0; r < MAX_ROWS; r++) {\n\t\t\toccupied.push(new Array(cols).fill(null));\n\t\t}\n\n\t\tfor (const itemDef of sorted) {\n\t\t\t// Clamp width to available columns\n\t\t\tconst w = Math.min(itemDef.width, cols);\n\t\t\tconst h = itemDef.height;\n\n\t\t\t// Find first available position (first-fit)\n\t\t\tlet placed = false;\n\t\t\tfor (let row = 0; row < MAX_ROWS && !placed; row++) {\n\t\t\t\tfor (let col = 0; col <= cols - w && !placed; col++) {\n\t\t\t\t\t// Check if space is available\n\t\t\t\t\tlet canFit = true;\n\t\t\t\t\tfor (let dy = 0; dy < h && canFit; dy++) {\n\t\t\t\t\t\tfor (let dx = 0; dx < w && canFit; dx++) {\n\t\t\t\t\t\t\tif (occupied[row + dy]?.[col + dx] !== null) {\n\t\t\t\t\t\t\t\tcanFit = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (canFit) {\n\t\t\t\t\t\tresult.set(itemDef.id, { column: col + 1, row: row + 1 }); // 1-indexed for CSS Grid\n\t\t\t\t\t\t// Mark cells as occupied\n\t\t\t\t\t\tfor (let dy = 0; dy < h; dy++) {\n\t\t\t\t\t\t\tfor (let dx = 0; dx < w; dx++) {\n\t\t\t\t\t\t\t\tif (occupied[row + dy]) {\n\t\t\t\t\t\t\t\t\toccupied[row + dy]![col + dx] = itemDef.id;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplaced = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!placed) {\n\t\t\t\t// Fallback: place at bottom (shouldn't happen with reasonable MAX_ROWS)\n\t\t\t\tresult.set(itemDef.id, { column: 1, row: MAX_ROWS });\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Calculate breakpoint width for a given column count.\n\t * n columns needs: n * cellSize + (n - 1) * gap pixels\n\t */\n\tfunction getBreakpointWidth(cols: number, cellSize: number, gap: number): number {\n\t\treturn cols * cellSize + (cols - 1) * gap;\n\t}\n\n\tconst model: ResponsiveLayoutModel = {\n\t\tget maxColumns() {\n\t\t\treturn maxColumns;\n\t\t},\n\t\tget minColumns() {\n\t\t\treturn minColumns;\n\t\t},\n\t\tget items() {\n\t\t\treturn items;\n\t\t},\n\t\tget currentColumnCount() {\n\t\t\treturn currentColumnCount;\n\t\t},\n\n\t\tgetLayoutForColumns(columnCount: number): Map<string, ItemPosition> {\n\t\t\t// Clamp to valid range\n\t\t\tconst cols = Math.max(minColumns, Math.min(maxColumns, columnCount));\n\n\t\t\tif (cols === maxColumns) {\n\t\t\t\treturn new Map(canonicalPositions);\n\t\t\t}\n\n\t\t\t// Check for explicit override\n\t\t\tconst override = overrides.get(cols);\n\t\t\tif (override) {\n\t\t\t\treturn new Map(override);\n\t\t\t}\n\n\t\t\t// Auto-derive from canonical\n\t\t\treturn deriveLayoutForColumns(cols, canonicalPositions);\n\t\t},\n\n\t\tgetCurrentLayout(): Map<string, ItemPosition> {\n\t\t\treturn this.getLayoutForColumns(currentColumnCount);\n\t\t},\n\n\t\thasOverride(columnCount: number): boolean {\n\t\t\treturn overrides.has(columnCount);\n\t\t},\n\n\t\tgetOverrideColumnCounts(): number[] {\n\t\t\treturn Array.from(overrides.keys()).sort((a, b) => b - a);\n\t\t},\n\n\t\tsaveLayout(columnCount: number, positions: Map<string, ItemPosition>): void {\n\t\t\tconst cols = Math.max(minColumns, Math.min(maxColumns, columnCount));\n\n\t\t\tif (cols === maxColumns) {\n\t\t\t\t// Update canonical layout\n\t\t\t\tcanonicalPositions = new Map(positions);\n\t\t\t} else {\n\t\t\t\t// Create/update override\n\t\t\t\toverrides.set(cols, new Map(positions));\n\t\t\t}\n\n\t\t\tnotifySubscribers();\n\t\t},\n\n\t\tclearOverride(columnCount: number): void {\n\t\t\tif (columnCount === maxColumns) {\n\t\t\t\t// Can't clear canonical layout\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (overrides.delete(columnCount)) {\n\t\t\t\tnotifySubscribers();\n\t\t\t}\n\t\t},\n\n\t\tupdateItemSize(itemId: string, size: { width: number; height: number }): void {\n\t\t\tconst existing = items.get(itemId);\n\t\t\tif (!existing) {\n\t\t\t\tconsole.warn(`[layout-model] updateItemSize: item \"${itemId}\" not found in items Map. Available IDs:`, Array.from(items.keys()));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Update the item definition\n\t\t\titems.set(itemId, {\n\t\t\t\tid: itemId,\n\t\t\t\twidth: size.width,\n\t\t\t\theight: size.height,\n\t\t\t});\n\n\t\t\tnotifySubscribers();\n\t\t},\n\n\t\tsetCurrentColumnCount(columnCount: number): void {\n\t\t\tconst newCount = Math.max(minColumns, Math.min(maxColumns, columnCount));\n\t\t\tif (newCount !== currentColumnCount) {\n\t\t\t\tcurrentColumnCount = newCount;\n\t\t\t\t// Note: We don't notify here because this is just tracking state.\n\t\t\t\t// The responsive plugin will emit an event for UI updates.\n\t\t\t}\n\t\t},\n\n\t\tgenerateAllBreakpointCSS(options?: BreakpointCSSOptions): string {\n\t\t\tconst {\n\t\t\t\tselectorPrefix = '[data-egg-item=\"',\n\t\t\t\tselectorSuffix = '\"]',\n\t\t\t\tcellSize,\n\t\t\t\tgap,\n\t\t\t\tgridSelector = '.grid-container',\n\t\t\t} = options ?? { cellSize: 184, gap: 16 };\n\n\t\t\tconst cssRules: string[] = [];\n\n\t\t\t// Generate fallback rules (canonical layout, no container query)\n\t\t\t// These apply immediately before container queries are evaluated\n\t\t\tcssRules.push('/* Fallback: canonical layout (before container queries evaluate) */');\n\t\t\tfor (const [id, pos] of Array.from(canonicalPositions)) {\n\t\t\t\tconst itemDef = items.get(id);\n\t\t\t\tif (!itemDef) continue;\n\t\t\t\tcssRules.push(\n\t\t\t\t\t`${selectorPrefix}${id}${selectorSuffix} { grid-column: ${pos.column} / span ${itemDef.width}; grid-row: ${pos.row} / span ${itemDef.height}; }`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tcssRules.push('');\n\n\t\t\t// Generate rules for each column count (maxColumns down to minColumns)\n\t\t\tfor (let cols = maxColumns; cols >= minColumns; cols--) {\n\t\t\t\tconst positions = this.getLayoutForColumns(cols);\n\t\t\t\tconst minWidth = getBreakpointWidth(cols, cellSize, gap);\n\t\t\t\tconst hasOverride = overrides.has(cols);\n\n\t\t\t\t// Build container query\n\t\t\t\tlet containerQuery: string;\n\t\t\t\tif (cols === maxColumns) {\n\t\t\t\t\tcontainerQuery = `@container (min-width: ${minWidth}px)`;\n\t\t\t\t} else if (cols === minColumns) {\n\t\t\t\t\t// Smallest size is the default/fallback\n\t\t\t\t\tconst maxWidth = getBreakpointWidth(cols + 1, cellSize, gap) - 1;\n\t\t\t\t\tcontainerQuery = `@container (max-width: ${maxWidth}px)`;\n\t\t\t\t} else {\n\t\t\t\t\tconst maxWidth = getBreakpointWidth(cols + 1, cellSize, gap) - 1;\n\t\t\t\t\tcontainerQuery = `@container (min-width: ${minWidth}px) and (max-width: ${maxWidth}px)`;\n\t\t\t\t}\n\n\t\t\t\t// Build rules for this column count\n\t\t\t\tconst itemRules: string[] = [];\n\n\t\t\t\t// Grid template\n\t\t\t\titemRules.push(\n\t\t\t\t\t`${gridSelector} { grid-template-columns: repeat(${cols}, 1fr); }`,\n\t\t\t\t);\n\n\t\t\t\t// Item positions\n\t\t\t\tfor (const [id, pos] of positions) {\n\t\t\t\t\tconst itemDef = items.get(id);\n\t\t\t\t\tif (!itemDef) continue;\n\n\t\t\t\t\t// Clamp width to current column count\n\t\t\t\t\tconst w = Math.min(itemDef.width, cols);\n\t\t\t\t\titemRules.push(\n\t\t\t\t\t\t`${selectorPrefix}${id}${selectorSuffix} { grid-column: ${pos.column} / span ${w}; grid-row: ${pos.row} / span ${itemDef.height}; }`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Add comment and rules\n\t\t\t\tconst layoutType =\n\t\t\t\t\tcols === maxColumns\n\t\t\t\t\t\t? '(canonical)'\n\t\t\t\t\t\t: hasOverride\n\t\t\t\t\t\t\t? '(override)'\n\t\t\t\t\t\t\t: '(derived)';\n\t\t\t\tcssRules.push(`/* ${cols} columns ${layoutType} */`);\n\t\t\t\tcssRules.push(`${containerQuery} {`);\n\t\t\t\tcssRules.push(itemRules.map((r) => '  ' + r).join('\\n'));\n\t\t\t\tcssRules.push('}');\n\t\t\t\tcssRules.push('');\n\t\t\t}\n\n\t\t\treturn cssRules.join('\\n');\n\t\t},\n\n\t\tsubscribe(callback: () => void): () => void {\n\t\t\tsubscribers.add(callback);\n\t\t\treturn () => subscribers.delete(callback);\n\t\t},\n\t};\n\n\treturn model;\n}\n\n"],"mappings":"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"}