{"version":3,"file":"algorithm-reorder.js","names":[],"sources":["../engine.ts","../plugins/algorithm-harness.ts","../plugins/algorithm-reorder.ts"],"sourcesContent":["import type { GridCell, EggCore, InitOptions, StyleManager } from './types';\nimport { createStateMachine } from './state-machine';\nimport { attachPointer } from './plugins/pointer';\nimport { attachKeyboard } from './plugins/keyboard';\nimport { attachAccessibility } from './plugins/accessibility';\nimport { attachResize } from './plugins/resize';\nimport { attachCamera } from './plugins/camera';\nimport { attachPlaceholder } from './plugins/placeholder';\nimport { attachPushAlgorithm } from './plugins/algorithm-push';\nimport { attachReorderAlgorithm } from './plugins/algorithm-reorder';\nimport { attachResponsive } from './plugins/responsive';\n\n/**\n * Initialize EG Grid on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): EggCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\t// Create centralized state machine\n\tconst stateMachine = createStateMachine();\n\n\t// Track selected element (state machine stores itemId, we need the element)\n\tlet selectedElement: HTMLElement | null = null;\n\n\t// StyleManager: single style element, multiple named layers\n\tconst styleLayers = new Map<string, string>(); // layer name → CSS\n\tconst layerOrder: string[] = []; // insertion order\n\tconst managedStyleElement = styleElement ?? document.createElement('style');\n\tif (!styleElement) {\n\t\tdocument.head.appendChild(managedStyleElement);\n\t\tcleanups.push(() => managedStyleElement.remove());\n\t}\n\n\t// Pre-populate 'base' layer with any existing content (e.g. server-rendered CSS)\n\tconst existingCSS = managedStyleElement.textContent?.trim();\n\tif (existingCSS) {\n\t\tstyleLayers.set('base', existingCSS);\n\t\tlayerOrder.push('base');\n\t}\n\n\tconst styles: StyleManager = {\n\t\tset(layer: string, css: string): void {\n\t\t\tif (!styleLayers.has(layer)) {\n\t\t\t\tlayerOrder.push(layer);\n\t\t\t}\n\t\t\tstyleLayers.set(layer, css);\n\t\t},\n\t\tget(layer: string): string {\n\t\t\treturn styleLayers.get(layer) ?? '';\n\t\t},\n\t\tclear(layer: string): void {\n\t\t\tif (styleLayers.has(layer)) {\n\t\t\t\tstyleLayers.set(layer, '');\n\t\t\t}\n\t\t},\n\t\tcommit(): void {\n\t\t\tconst parts: string[] = [];\n\t\t\tfor (const layer of layerOrder) {\n\t\t\t\tconst css = styleLayers.get(layer);\n\t\t\t\tif (css) parts.push(css);\n\t\t\t}\n\t\t\tmanagedStyleElement.textContent = parts.join('\\n\\n');\n\t\t},\n\t};\n\n\tconst core: EggCore = {\n\t\telement,\n\t\tstateMachine,\n\t\tstyles,\n\t\tcameraScrolling: false,\n\n\t\t// Selection state (backed by state machine)\n\t\tget selectedItem() {\n\t\t\treturn selectedElement;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedElement) return;\n\n\t\t\tconst previousItem = selectedElement;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-egg-selected');\n\t\t\t}\n\n\t\t\t// Update state machine and local element reference\n\t\t\tif (item) {\n\t\t\t\tconst itemId = item.id || item.getAttribute('data-egg-item') || '';\n\t\t\t\tstateMachine.transition({ type: 'SELECT', itemId, element: item });\n\t\t\t\tselectedElement = item;\n\t\t\t\titem.setAttribute('data-egg-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else {\n\t\t\t\tstateMachine.transition({ type: 'DESELECT' });\n\t\t\t\tselectedElement = null;\n\t\t\t\tif (previousItem) {\n\t\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`egg-${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Direct initialization — no registry, no loop\n\tif (options.pointer !== false) {\n\t\tcleanups.push(attachPointer(core));\n\t}\n\tif (options.keyboard !== false) {\n\t\tcleanups.push(attachKeyboard(core));\n\t}\n\tif (options.accessibility !== false) {\n\t\tcleanups.push(attachAccessibility(core));\n\t}\n\n\tif (options.resize !== false) {\n\t\tconst resizeOpts = typeof options.resize === 'object' ? options.resize : {};\n\t\tconst inst = attachResize(element, { ...resizeOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.camera !== false) {\n\t\tconst cameraOpts = typeof options.camera === 'object' ? options.camera : {};\n\t\tconst inst = attachCamera(element, { ...cameraOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.placeholder !== false) {\n\t\tconst placeholderOpts = typeof options.placeholder === 'object' ? options.placeholder : {};\n\t\tconst inst = attachPlaceholder(element, placeholderOpts);\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\t// Algorithm: push (default) or reorder\n\tif (options.algorithm !== false) {\n\t\tconst algoOpts = options.algorithmOptions ?? {};\n\t\tif (options.algorithm === 'reorder') {\n\t\t\tcleanups.push(attachReorderAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t} else {\n\t\t\tcleanups.push(attachPushAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t}\n\t}\n\n\tif (options.responsive) {\n\t\tcleanups.push(attachResponsive(element, options.responsive, core));\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Get the size of an item from its data attributes\n */\nexport function getItemSize(item: HTMLElement): { colspan: number; rowspan: number } {\n\treturn {\n\t\tcolspan: parseInt(item.getAttribute('data-egg-colspan') || '1', 10) || 1,\n\t\trowspan: parseInt(item.getAttribute('data-egg-rowspan') || '1', 10) || 1,\n\t};\n}\n\n/**\n * Attach multiple event listeners and return a cleanup function to remove them all\n */\nexport function listenEvents(\n\telement: EventTarget,\n\tevents: Record<string, EventListenerOrEventListenerObject>,\n): () => void {\n\tfor (const [name, handler] of Object.entries(events)) {\n\t\telement.addEventListener(name, handler);\n\t}\n\treturn () => {\n\t\tfor (const [name, handler] of Object.entries(events)) {\n\t\t\telement.removeEventListener(name, handler);\n\t\t}\n\t};\n}\n","/**\n * Shared DOM integration harness for layout algorithms.\n *\n * Provides the boilerplate that every algorithm needs: event listeners for\n * drag/resize, View Transitions, CSS injection via StyleManager, layout\n * provider registration, camera-settled handling, and cleanup.\n *\n * Individual algorithms implement AlgorithmStrategy and call attachAlgorithm().\n */\n\nimport { listenEvents } from \"../engine\";\nimport type {\n  DragEndDetail,\n  DragMoveDetail,\n  DragStartDetail,\n  DragSource,\n  GridCell,\n  EggCore,\n  ItemPosition,\n  LayoutChangeDetail,\n  ResizeCancelDetail,\n  ResizeEndDetail,\n  ResizeMoveDetail,\n  ResizeStartDetail,\n  ResponsiveLayoutModel,\n  StyleManager,\n} from \"../types\";\n\n// ============================================================================\n// Shared types (originally in algorithm-push-core.ts)\n// ============================================================================\n\nexport interface ItemRect {\n  id: string;\n  column: number;\n  row: number;\n  width: number;\n  height: number;\n}\n\n/**\n * Options for CSS generation\n */\nexport interface LayoutToCSSOptions {\n  selectorPrefix?: string;\n  selectorSuffix?: string;\n  excludeSelector?: string;\n  maxColumns?: number;\n}\n\n// ============================================================================\n// Shared pure functions\n// ============================================================================\n\n/**\n * Convert layout to CSS rules for injection into a <style> tag.\n */\nexport function layoutToCSS(\n  items: ItemRect[],\n  options: LayoutToCSSOptions = {},\n): string {\n  const {\n    selectorPrefix = '[data-egg-item=\"',\n    selectorSuffix = '\"]',\n    excludeSelector = \"\",\n    maxColumns,\n  } = options;\n\n  const rules: string[] = [];\n\n  for (const item of items) {\n    const width = maxColumns ? Math.min(item.width, maxColumns) : item.width;\n    const column = maxColumns\n      ? Math.max(1, Math.min(item.column, maxColumns - width + 1))\n      : item.column;\n    const selector = `${selectorPrefix}${item.id}${selectorSuffix}${excludeSelector}`;\n    const gridColumn = `${column} / span ${width}`;\n    const gridRow = `${item.row} / span ${item.height}`;\n\n    rules.push(\n      `${selector} { grid-column: ${gridColumn}; grid-row: ${gridRow}; }`,\n    );\n  }\n\n  return rules.join(\"\\n\");\n}\n\n/**\n * Read item positions from DOM elements\n */\nexport function readItemsFromDOM(container: HTMLElement): ItemRect[] {\n  const elements = container.querySelectorAll(\"[data-egg-item]\");\n  return Array.from(elements).map((el) => {\n    const element = el as HTMLElement;\n    const style = getComputedStyle(element);\n    const column = parseInt(style.gridColumnStart, 10) || 1;\n    const row = parseInt(style.gridRowStart, 10) || 1;\n    const width =\n      parseInt(element.getAttribute(\"data-egg-colspan\") || \"1\", 10) || 1;\n    const height =\n      parseInt(element.getAttribute(\"data-egg-rowspan\") || \"1\", 10) || 1;\n    const id = element.dataset.eggItem || element.dataset.id || \"\";\n\n    return { id, column, row, width, height };\n  });\n}\n\n// ============================================================================\n// Strategy interface\n// ============================================================================\n\nexport interface AlgorithmStrategy {\n  /** Calculate layout after a drag move/end */\n  calculateDragLayout(\n    items: ItemRect[],\n    movedId: string,\n    targetCell: GridCell,\n    columns: number,\n  ): ItemRect[];\n\n  /** Optional hook called after drag-move layout is applied (e.g. emit drop-preview) */\n  afterDragMove?(\n    layout: ItemRect[],\n    movedId: string,\n    gridElement: HTMLElement,\n  ): void;\n\n  /** Calculate layout after a resize move/end. If undefined, resize events are ignored. */\n  calculateResizeLayout?(\n    items: ItemRect[],\n    resizedId: string,\n    cell: GridCell,\n    colspan: number,\n    rowspan: number,\n    columns: number,\n  ): ItemRect[];\n}\n\n// ============================================================================\n// Harness options\n// ============================================================================\n\nexport interface AlgorithmHarnessOptions {\n  selectorPrefix?: string;\n  selectorSuffix?: string;\n  core?: EggCore;\n  layoutModel?: ResponsiveLayoutModel;\n}\n\n// ============================================================================\n// attachAlgorithm — shared DOM integration\n// ============================================================================\n\n/**\n * Attach a layout algorithm strategy to a grid element.\n *\n * Handles all DOM event wiring, View Transitions, CSS injection, layout model\n * persistence, and cleanup. The strategy only needs to provide pure layout\n * calculation functions.\n *\n * @param gridElement - The grid container element\n * @param strategy - Algorithm-specific layout functions\n * @param options - Configuration options\n * @returns Cleanup function to detach the algorithm\n */\nexport function attachAlgorithm(\n  gridElement: HTMLElement,\n  strategy: AlgorithmStrategy,\n  options: AlgorithmHarnessOptions = {},\n): () => void {\n  const {\n    selectorPrefix = '[data-egg-item=\"',\n    selectorSuffix = '\"]',\n    core,\n    layoutModel,\n  } = options;\n  const styles: StyleManager | null = core?.styles ?? null;\n\n  function getCurrentColumnCount(): number {\n    const style = getComputedStyle(gridElement);\n    const columns = style.gridTemplateColumns.split(\" \").filter(Boolean);\n    return Math.max(1, columns.length);\n  }\n\n  let originalPositions: Map<string, { column: number; row: number }> | null =\n    null;\n  let draggedItemId: string | null = null;\n  let draggedElement: HTMLElement | null = null;\n  let dragSource: DragSource | null = null;\n  let layoutVersion = 0;\n  let currentLayout: ItemRect[] | null = null;\n  let dragStartColumnCount: number | null = null;\n\n  // Resize state\n  let resizedItemId: string | null = null;\n  let resizedElement: HTMLElement | null = null;\n  let resizeSource: DragSource | null = null;\n  let resizeOriginalPositions: Map<\n    string,\n    { column: number; row: number; width: number; height: number }\n  > | null = null;\n  let lastResizeLayout: {\n    cell: GridCell;\n    colspan: number;\n    rowspan: number;\n  } | null = null;\n  let resizeStartColumnCount: number | null = null;\n\n  function getItemId(element: HTMLElement): string {\n    return element.dataset.eggItem || element.dataset.id || \"\";\n  }\n\n  /** Read items from DOM with original positions restored (except the actively dragged item) */\n  function getItemsWithOriginals(\n    excludeId: string | null,\n    originals: Map<string, { column: number; row: number }>,\n  ): ItemRect[] {\n    return readItemsFromDOM(gridElement).map((item) => {\n      const original = originals.get(item.id);\n      if (original && item.id !== excludeId) {\n        return { ...item, column: original.column, row: original.row };\n      }\n      return item;\n    });\n  }\n\n  /** Build resize items from original positions, with resized item updated */\n  function getResizeItems(\n    originals: Map<\n      string,\n      { column: number; row: number; width: number; height: number }\n    >,\n    resizedId: string,\n    cell: GridCell,\n    colspan: number,\n    rowspan: number,\n  ): ItemRect[] {\n    const items: ItemRect[] = [];\n    for (const [id, original] of originals) {\n      if (id === resizedId) {\n        items.push({\n          id,\n          column: cell.column,\n          row: cell.row,\n          width: colspan,\n          height: rowspan,\n        });\n      } else {\n        items.push({\n          id,\n          column: original.column,\n          row: original.row,\n          width: original.width,\n          height: original.height,\n        });\n      }\n    }\n    return items;\n  }\n\n  function saveAndClearPreview(\n    layout: ItemRect[],\n    columnCount: number,\n    afterSave?: () => void,\n  ): void {\n    if (!layoutModel || !columnCount) return;\n    const positions = new Map<string, ItemPosition>();\n    for (const item of layout) {\n      positions.set(item.id, { column: item.column, row: item.row });\n    }\n    layoutModel.saveLayout(columnCount, positions);\n    if (afterSave) afterSave();\n    if (styles) {\n      styles.clear(\"preview\");\n      styles.commit();\n    }\n\n    // Emit layout-change only on settled layouts (drag-end / resize-end)\n    if (core) {\n      core.emit<LayoutChangeDetail>(\"layout-change\", {\n        items: layout,\n        columnCount,\n      });\n    }\n  }\n\n  function applyLayout(\n    layout: ItemRect[],\n    excludeId: string | null,\n    useViewTransition: boolean,\n    onApplied?: () => void,\n  ): void {\n    const thisVersion = ++layoutVersion;\n    currentLayout = layout;\n    const capturedColumnCount = dragStartColumnCount ?? resizeStartColumnCount;\n\n    const applyChanges = () => {\n      if (thisVersion !== layoutVersion) return;\n\n      if (styles) {\n        const itemsToStyle = excludeId\n          ? layout.filter((item) => item.id !== excludeId)\n          : layout;\n        const css = layoutToCSS(itemsToStyle, {\n          selectorPrefix,\n          selectorSuffix,\n          maxColumns: capturedColumnCount ?? undefined,\n        });\n        styles.set(\"preview\", css);\n        styles.commit();\n\n        const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n        for (const el of elements) {\n          const element = el as HTMLElement;\n          const id = getItemId(element);\n          const vtn = element.style.viewTransitionName;\n          if (id !== excludeId && vtn !== \"none\") {\n            element.style.gridColumn = \"\";\n            element.style.gridRow = \"\";\n          }\n        }\n      } else {\n        const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n        for (const el of elements) {\n          const element = el as HTMLElement;\n          const id = getItemId(element);\n          if (id === excludeId) continue;\n          const item = layout.find((it) => it.id === id);\n          if (item) {\n            const colspan =\n              parseInt(\n                element.getAttribute(\"data-egg-colspan\") || \"1\",\n                10,\n              ) || 1;\n            const rowspan =\n              parseInt(\n                element.getAttribute(\"data-egg-rowspan\") || \"1\",\n                10,\n              ) || 1;\n            element.style.gridColumn = `${item.column} / span ${colspan}`;\n            element.style.gridRow = `${item.row} / span ${rowspan}`;\n          }\n        }\n      }\n\n      if (onApplied) onApplied();\n    };\n\n    if (useViewTransition && \"startViewTransition\" in document) {\n      if (draggedElement && excludeId) {\n        draggedElement.style.viewTransitionName = \"dragging\";\n      }\n      (document as any).startViewTransition(applyChanges);\n    } else {\n      applyChanges();\n    }\n  }\n\n  // =========================================================================\n  // Drag event handlers\n  // =========================================================================\n\n  const onDragStart = (e: Event) => {\n    const detail = (e as CustomEvent<DragStartDetail>).detail;\n    draggedElement = detail.item;\n    draggedItemId = getItemId(detail.item);\n    dragSource = detail.source;\n    dragStartColumnCount = getCurrentColumnCount();\n\n    const items = readItemsFromDOM(gridElement);\n    originalPositions = new Map();\n    for (const item of items) {\n      originalPositions.set(item.id, { column: item.column, row: item.row });\n    }\n\n    if (styles) {\n      const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n      for (const el of elements) {\n        const element = el as HTMLElement;\n        if (element !== draggedElement) {\n          element.style.gridColumn = \"\";\n          element.style.gridRow = \"\";\n        }\n      }\n      const css = layoutToCSS(items, {\n        selectorPrefix,\n        selectorSuffix,\n        maxColumns: dragStartColumnCount,\n      });\n      styles.set(\"preview\", css);\n      styles.commit();\n    }\n  };\n\n  let pendingCell: GridCell | null = null;\n\n  const onDragMove = (e: Event) => {\n    if (!draggedItemId || !originalPositions) return;\n    const detail = (e as CustomEvent<DragMoveDetail>).detail;\n\n    if (core?.cameraScrolling) {\n      pendingCell = detail.cell;\n      return;\n    }\n    pendingCell = null;\n\n    const items = getItemsWithOriginals(draggedItemId, originalPositions!);\n    const columns = dragStartColumnCount ?? getCurrentColumnCount();\n    const newLayout = strategy.calculateDragLayout(\n      items,\n      draggedItemId,\n      detail.cell,\n      columns,\n    );\n    applyLayout(newLayout, draggedItemId, true);\n\n    if (strategy.afterDragMove) {\n      strategy.afterDragMove(newLayout, draggedItemId, gridElement);\n    }\n  };\n\n  const onDragEnd = (e: Event) => {\n    if (!draggedItemId || !originalPositions) return;\n    const detail = (e as CustomEvent<DragEndDetail>).detail;\n    const items = getItemsWithOriginals(draggedItemId, originalPositions!);\n\n    const columns = dragStartColumnCount ?? getCurrentColumnCount();\n    const finalLayout = strategy.calculateDragLayout(\n      items,\n      draggedItemId,\n      detail.cell,\n      columns,\n    );\n\n    const isPointerDrag = dragSource === \"pointer\";\n    if (\n      draggedElement &&\n      draggedElement.style.viewTransitionName === \"dragging\"\n    ) {\n      draggedElement.style.viewTransitionName = \"\";\n    }\n\n    const useViewTransition = !isPointerDrag;\n    const savedDragStartColumnCount = dragStartColumnCount;\n\n    applyLayout(finalLayout, null, useViewTransition, () =>\n      saveAndClearPreview(finalLayout, savedDragStartColumnCount!),\n    );\n\n    draggedItemId = null;\n    draggedElement = null;\n    dragSource = null;\n    originalPositions = null;\n    pendingCell = null;\n    dragStartColumnCount = null;\n  };\n\n  const onDragCancel = () => {\n    if (!draggedItemId || !originalPositions) return;\n\n    if (\n      draggedElement &&\n      draggedElement.style.viewTransitionName === \"dragging\"\n    ) {\n      draggedElement.style.viewTransitionName = \"\";\n    }\n\n    const restoreLayout = getItemsWithOriginals(null, originalPositions!);\n    const restore = () => applyLayout(restoreLayout, null, false);\n\n    if (\"startViewTransition\" in document) {\n      (document as any).startViewTransition(restore);\n    } else {\n      restore();\n    }\n\n    draggedItemId = null;\n    draggedElement = null;\n    dragSource = null;\n    originalPositions = null;\n    pendingCell = null;\n    dragStartColumnCount = null;\n  };\n\n  const onCameraSettled = () => {\n    if (!draggedItemId || !originalPositions) return;\n\n    let cell = pendingCell;\n    if (!cell && draggedElement) {\n      const rect = draggedElement.getBoundingClientRect();\n      const centerX = rect.left + rect.width / 2;\n      const centerY = rect.top + rect.height / 2;\n      cell = core?.getCellFromPoint(centerX, centerY) ?? null;\n    }\n\n    if (!cell) return;\n    pendingCell = null;\n\n    const items = getItemsWithOriginals(draggedItemId, originalPositions!);\n    const columns = dragStartColumnCount ?? getCurrentColumnCount();\n    const newLayout = strategy.calculateDragLayout(\n      items,\n      draggedItemId!,\n      cell,\n      columns,\n    );\n    applyLayout(newLayout, draggedItemId, true);\n\n    if (strategy.afterDragMove) {\n      strategy.afterDragMove(newLayout, draggedItemId!, gridElement);\n    }\n  };\n\n  // =========================================================================\n  // Resize event handlers (only if strategy supports resize)\n  // =========================================================================\n\n  const onResizeStart = (e: Event) => {\n    if (!strategy.calculateResizeLayout) return;\n    const detail = (e as CustomEvent<ResizeStartDetail>).detail;\n    resizedElement = detail.item;\n    resizedItemId = getItemId(detail.item);\n    resizeSource = detail.source;\n    resizeStartColumnCount = getCurrentColumnCount();\n\n    const items = readItemsFromDOM(gridElement);\n    resizeOriginalPositions = new Map();\n    for (const item of items) {\n      resizeOriginalPositions.set(item.id, {\n        column: item.column,\n        row: item.row,\n        width: item.width,\n        height: item.height,\n      });\n    }\n\n    if (styles) {\n      const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n      for (const el of elements) {\n        const element = el as HTMLElement;\n        if (element !== resizedElement) {\n          element.style.gridColumn = \"\";\n          element.style.gridRow = \"\";\n        }\n      }\n      const css = layoutToCSS(items, {\n        selectorPrefix,\n        selectorSuffix,\n        maxColumns: resizeStartColumnCount,\n      });\n      styles.set(\"preview\", css);\n      styles.commit();\n    }\n\n    lastResizeLayout = null;\n  };\n\n  const onResizeMove = (e: Event) => {\n    if (!strategy.calculateResizeLayout) return;\n    if (!resizedItemId || !resizeOriginalPositions) return;\n    const detail = (e as CustomEvent<ResizeMoveDetail>).detail;\n\n    if (\n      lastResizeLayout &&\n      lastResizeLayout.cell.column === detail.cell.column &&\n      lastResizeLayout.cell.row === detail.cell.row &&\n      lastResizeLayout.colspan === detail.colspan &&\n      lastResizeLayout.rowspan === detail.rowspan\n    ) {\n      return;\n    }\n    lastResizeLayout = {\n      cell: { ...detail.cell },\n      colspan: detail.colspan,\n      rowspan: detail.rowspan,\n    };\n\n    const items = getResizeItems(\n      resizeOriginalPositions,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n    );\n    const columns = resizeStartColumnCount ?? getCurrentColumnCount();\n    const newLayout = strategy.calculateResizeLayout(\n      items,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n      columns,\n    );\n    applyLayout(newLayout, resizedItemId, true);\n  };\n\n  const onResizeEnd = (e: Event) => {\n    if (!strategy.calculateResizeLayout) return;\n    if (!resizedItemId || !resizeOriginalPositions) return;\n    const detail = (e as CustomEvent<ResizeEndDetail>).detail;\n    const items = getResizeItems(\n      resizeOriginalPositions,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n    );\n\n    const columns = resizeStartColumnCount ?? getCurrentColumnCount();\n    const finalLayout = strategy.calculateResizeLayout(\n      items,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n      columns,\n    );\n\n    const isPointerResize = resizeSource === \"pointer\";\n    const useViewTransition = !isPointerResize;\n    const savedResizedItemId = resizedItemId;\n    const savedResizeStartColumnCount = resizeStartColumnCount;\n\n    applyLayout(finalLayout, null, useViewTransition, () =>\n      saveAndClearPreview(finalLayout, savedResizeStartColumnCount!, () => {\n        layoutModel!.updateItemSize(savedResizedItemId!, {\n          width: detail.colspan,\n          height: detail.rowspan,\n        });\n      }),\n    );\n\n    resizedItemId = null;\n    resizedElement = null;\n    resizeSource = null;\n    resizeOriginalPositions = null;\n    lastResizeLayout = null;\n    resizeStartColumnCount = null;\n  };\n\n  const onResizeCancel = () => {\n    if (!resizedItemId || !resizeOriginalPositions) return;\n\n    const restoreLayout = Array.from(resizeOriginalPositions, ([id, o]) => ({\n      id,\n      column: o.column,\n      row: o.row,\n      width: o.width,\n      height: o.height,\n    }));\n    const restore = () => applyLayout(restoreLayout, null, false);\n\n    if (\"startViewTransition\" in document) {\n      (document as any).startViewTransition(restore);\n    } else {\n      restore();\n    }\n\n    resizedItemId = null;\n    resizedElement = null;\n    resizeSource = null;\n    resizeOriginalPositions = null;\n    lastResizeLayout = null;\n    resizeStartColumnCount = null;\n  };\n\n  // =========================================================================\n  // Event listener registration\n  // =========================================================================\n\n  return listenEvents(gridElement, {\n    \"egg-drag-start\": onDragStart,\n    \"egg-drag-move\": onDragMove,\n    \"egg-drag-end\": onDragEnd,\n    \"egg-drag-cancel\": onDragCancel,\n    \"egg-camera-settled\": onCameraSettled,\n    \"egg-resize-start\": onResizeStart,\n    \"egg-resize-move\": onResizeMove,\n    \"egg-resize-end\": onResizeEnd,\n    \"egg-resize-cancel\": onResizeCancel,\n  });\n}\n","/**\n * Reorder layout algorithm for EG Grid\n *\n * Sequence-based reflow: items have a logical order, dragging changes\n * position in that sequence, all items reflow like CSS Grid auto-placement.\n *\n * Usage (pure functions):\n *   import { calculateReorderLayout, reflowItems, layoutToCSS } from 'eg-grid/algorithm-reorder';\n *\n * Usage (DOM integration):\n *   import { attachReorderAlgorithm } from 'eg-grid/algorithm-reorder';\n *   const detach = attachReorderAlgorithm(grid.element, { core });\n */\n\nimport type {\n\tGridCell,\n\tEggCore,\n\tResponsiveLayoutModel,\n} from '../types';\n\nimport {\n\tattachAlgorithm,\n\ttype AlgorithmStrategy,\n\ttype ItemRect,\n} from './algorithm-harness';\n\n// Re-export shared types and functions from harness\nexport {\n\tlayoutToCSS,\n\ttype ItemRect,\n\ttype LayoutToCSSOptions,\n} from './algorithm-harness';\n\n// Also re-export GridCell so consumers don't need to import from types.ts\nexport type { GridCell } from '../types';\n\n// ============================================================================\n// Pure reorder algorithm\n// ============================================================================\n\n/**\n * Sort items into reading order (row-major: row first, then column)\n */\nexport function getItemOrder(items: ItemRect[]): ItemRect[] {\n\treturn [...items].sort((a, b) => a.row - b.row || a.column - b.column);\n}\n\n/**\n * Check if a cell range is available (not occupied)\n */\nfunction rangeAvailable(\n\toccupied: Set<string>,\n\tcolumn: number,\n\trow: number,\n\twidth: number,\n\theight: number,\n\tcolumns: number,\n): boolean {\n\tif (column + width - 1 > columns) return false;\n\n\tfor (let r = row; r < row + height; r++) {\n\t\tfor (let c = column; c < column + width; c++) {\n\t\t\tif (occupied.has(`${c},${r}`)) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Mark cells as occupied\n */\nfunction markOccupied(\n\toccupied: Set<string>,\n\tcolumn: number,\n\trow: number,\n\twidth: number,\n\theight: number,\n): void {\n\tfor (let r = row; r < row + height; r++) {\n\t\tfor (let c = column; c < column + width; c++) {\n\t\t\toccupied.add(`${c},${r}`);\n\t\t}\n\t}\n}\n\n/**\n * Reflow items into grid positions using auto-placement.\n * Scans left-to-right, top-to-bottom for the first position each item fits.\n *\n * @param items - Items in logical order (sequence determines placement priority)\n * @param columns - Number of grid columns\n * @returns New array with updated positions\n */\nexport function reflowItems(items: ItemRect[], columns: number): ItemRect[] {\n\tconst occupied = new Set<string>();\n\tconst result: ItemRect[] = [];\n\n\tfor (const item of items) {\n\t\tconst width = Math.min(item.width, columns);\n\t\tlet placed = false;\n\n\t\tfor (let row = 1; !placed; row++) {\n\t\t\tfor (let col = 1; col <= columns; col++) {\n\t\t\t\tif (rangeAvailable(occupied, col, row, width, item.height, columns)) {\n\t\t\t\t\tmarkOccupied(occupied, col, row, width, item.height);\n\t\t\t\t\tresult.push({ ...item, column: col, row, width });\n\t\t\t\t\tplaced = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Safety: prevent infinite loop on pathological inputs\n\t\t\tif (row > 100) {\n\t\t\t\tresult.push({ ...item, column: 1, row, width });\n\t\t\t\tmarkOccupied(occupied, 1, row, width, item.height);\n\t\t\t\tplaced = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Compare positions in reading order (row-major)\n */\nfunction positionBefore(a: GridCell, b: GridCell): boolean {\n\treturn a.row < b.row || (a.row === b.row && a.column < b.column);\n}\n\n/**\n * Options for calculateReorderLayout\n */\nexport interface CalculateReorderLayoutOptions {\n\t/** Number of grid columns */\n\tcolumns: number;\n}\n\n/**\n * Calculate new layout after reordering an item.\n *\n * 1. Sort items by current position to get logical order\n * 2. Remove moved item from sequence\n * 3. Reflow remaining items to get candidate positions\n * 4. Find insertion index: before the first candidate whose reflowed position\n *    comes after targetCell in reading order\n * 5. Insert moved item at that index\n * 6. Reflow all items\n *\n * @returns New array with updated positions\n */\nexport function calculateReorderLayout(\n\titems: ItemRect[],\n\tmovedId: string,\n\ttargetCell: GridCell,\n\toptions: CalculateReorderLayoutOptions,\n): ItemRect[] {\n\tconst { columns } = options;\n\n\t// Deep copy items\n\tconst all = items.map((item) => ({ ...item }));\n\n\t// Get logical order from current positions\n\tconst ordered = getItemOrder(all);\n\n\t// Extract moved item\n\tconst movedItem = ordered.find((it) => it.id === movedId);\n\tif (!movedItem) return reflowItems(ordered, columns);\n\n\tconst remaining = ordered.filter((it) => it.id !== movedId);\n\n\t// Reflow remaining to get candidate positions\n\tconst reflowed = reflowItems(remaining, columns);\n\n\t// Find insertion index: before the first reflowed item whose position\n\t// comes after targetCell in reading order\n\tlet insertIndex = reflowed.length; // default: append at end\n\tfor (let i = 0; i < reflowed.length; i++) {\n\t\tif (!positionBefore(reflowed[i], targetCell)) {\n\t\t\tinsertIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Build final sequence with moved item inserted\n\tconst finalSequence: ItemRect[] = [\n\t\t...remaining.slice(0, insertIndex),\n\t\tmovedItem,\n\t\t...remaining.slice(insertIndex),\n\t];\n\n\t// Reflow everything\n\treturn reflowItems(finalSequence, columns);\n}\n\n// ============================================================================\n// DOM integration via harness\n// ============================================================================\n\n/**\n * Options for attachReorderAlgorithm\n */\nexport interface AttachReorderAlgorithmOptions {\n\tselectorPrefix?: string;\n\tselectorSuffix?: string;\n\tcore?: EggCore;\n\tlayoutModel?: ResponsiveLayoutModel;\n}\n\n/**\n * Attach reorder algorithm to a grid element.\n *\n * Listens to drag/resize events and reflows items in sequence order.\n * Layout changes are animated via View Transitions.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach the algorithm\n */\nexport function attachReorderAlgorithm(\n\tgridElement: HTMLElement,\n\toptions: AttachReorderAlgorithmOptions = {},\n): () => void {\n\tconst strategy: AlgorithmStrategy = {\n\t\tcalculateDragLayout(items, movedId, targetCell, columns) {\n\t\t\treturn calculateReorderLayout(items, movedId, targetCell, { columns });\n\t\t},\n\n\t\tafterDragMove(layout, movedId, el) {\n\t\t\t// Emit drop-preview so the placeholder knows the actual landing position.\n\t\t\t// Use queueMicrotask to ensure this fires AFTER all drag-move handlers\n\t\t\t// (including the placeholder's) have finished, regardless of listener order.\n\t\t\tconst landingItem = layout.find((it) => it.id === movedId);\n\t\t\tif (landingItem) {\n\t\t\t\tconst previewDetail = {\n\t\t\t\t\tcell: { column: landingItem.column, row: landingItem.row },\n\t\t\t\t\tcolspan: landingItem.width,\n\t\t\t\t\trowspan: landingItem.height,\n\t\t\t\t};\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tel.dispatchEvent(new CustomEvent('egg-drop-preview', {\n\t\t\t\t\t\tdetail: previewDetail,\n\t\t\t\t\t\tbubbles: true,\n\t\t\t\t\t}));\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tcalculateResizeLayout(items, _resizedId, _cell, _colspan, _rowspan, columns) {\n\t\t\t// For resize, reflow all items in their current order with the resized item's new size\n\t\t\tconst ordered = [...items].sort((a, b) => a.row - b.row || a.column - b.column);\n\t\t\treturn reflowItems(ordered, columns);\n\t\t},\n\t};\n\n\treturn attachAlgorithm(gridElement, strategy, options);\n}\n\n"],"mappings":"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"}