{"version":3,"file":"algorithm-reorder.min.js","names":[],"sources":["../engine.ts","../plugins/algorithm-harness.ts","../plugins/algorithm-reorder.ts"],"sourcesContent":["import type { GridCell, EggCore, InitOptions, StyleManager } from './types';\nimport { createStateMachine } from './state-machine';\nimport { attachPointer } from './plugins/pointer';\nimport { attachKeyboard } from './plugins/keyboard';\nimport { attachAccessibility } from './plugins/accessibility';\nimport { attachResize } from './plugins/resize';\nimport { attachCamera } from './plugins/camera';\nimport { attachPlaceholder } from './plugins/placeholder';\nimport { attachPushAlgorithm } from './plugins/algorithm-push';\nimport { attachReorderAlgorithm } from './plugins/algorithm-reorder';\nimport { attachResponsive } from './plugins/responsive';\n\n/**\n * Initialize EG Grid on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): EggCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\t// Create centralized state machine\n\tconst stateMachine = createStateMachine();\n\n\t// Track selected element (state machine stores itemId, we need the element)\n\tlet selectedElement: HTMLElement | null = null;\n\n\t// StyleManager: single style element, multiple named layers\n\tconst styleLayers = new Map<string, string>(); // layer name → CSS\n\tconst layerOrder: string[] = []; // insertion order\n\tconst managedStyleElement = styleElement ?? document.createElement('style');\n\tif (!styleElement) {\n\t\tdocument.head.appendChild(managedStyleElement);\n\t\tcleanups.push(() => managedStyleElement.remove());\n\t}\n\n\t// Pre-populate 'base' layer with any existing content (e.g. server-rendered CSS)\n\tconst existingCSS = managedStyleElement.textContent?.trim();\n\tif (existingCSS) {\n\t\tstyleLayers.set('base', existingCSS);\n\t\tlayerOrder.push('base');\n\t}\n\n\tconst styles: StyleManager = {\n\t\tset(layer: string, css: string): void {\n\t\t\tif (!styleLayers.has(layer)) {\n\t\t\t\tlayerOrder.push(layer);\n\t\t\t}\n\t\t\tstyleLayers.set(layer, css);\n\t\t},\n\t\tget(layer: string): string {\n\t\t\treturn styleLayers.get(layer) ?? '';\n\t\t},\n\t\tclear(layer: string): void {\n\t\t\tif (styleLayers.has(layer)) {\n\t\t\t\tstyleLayers.set(layer, '');\n\t\t\t}\n\t\t},\n\t\tcommit(): void {\n\t\t\tconst parts: string[] = [];\n\t\t\tfor (const layer of layerOrder) {\n\t\t\t\tconst css = styleLayers.get(layer);\n\t\t\t\tif (css) parts.push(css);\n\t\t\t}\n\t\t\tmanagedStyleElement.textContent = parts.join('\\n\\n');\n\t\t},\n\t};\n\n\tconst core: EggCore = {\n\t\telement,\n\t\tstateMachine,\n\t\tstyles,\n\t\tcameraScrolling: false,\n\n\t\t// Selection state (backed by state machine)\n\t\tget selectedItem() {\n\t\t\treturn selectedElement;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedElement) return;\n\n\t\t\tconst previousItem = selectedElement;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-egg-selected');\n\t\t\t}\n\n\t\t\t// Update state machine and local element reference\n\t\t\tif (item) {\n\t\t\t\tconst itemId = item.id || item.getAttribute('data-egg-item') || '';\n\t\t\t\tstateMachine.transition({ type: 'SELECT', itemId, element: item });\n\t\t\t\tselectedElement = item;\n\t\t\t\titem.setAttribute('data-egg-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else {\n\t\t\t\tstateMachine.transition({ type: 'DESELECT' });\n\t\t\t\tselectedElement = null;\n\t\t\t\tif (previousItem) {\n\t\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`egg-${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Direct initialization — no registry, no loop\n\tif (options.pointer !== false) {\n\t\tcleanups.push(attachPointer(core));\n\t}\n\tif (options.keyboard !== false) {\n\t\tcleanups.push(attachKeyboard(core));\n\t}\n\tif (options.accessibility !== false) {\n\t\tcleanups.push(attachAccessibility(core));\n\t}\n\n\tif (options.resize !== false) {\n\t\tconst resizeOpts = typeof options.resize === 'object' ? options.resize : {};\n\t\tconst inst = attachResize(element, { ...resizeOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.camera !== false) {\n\t\tconst cameraOpts = typeof options.camera === 'object' ? options.camera : {};\n\t\tconst inst = attachCamera(element, { ...cameraOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.placeholder !== false) {\n\t\tconst placeholderOpts = typeof options.placeholder === 'object' ? options.placeholder : {};\n\t\tconst inst = attachPlaceholder(element, placeholderOpts);\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\t// Algorithm: push (default) or reorder\n\tif (options.algorithm !== false) {\n\t\tconst algoOpts = options.algorithmOptions ?? {};\n\t\tif (options.algorithm === 'reorder') {\n\t\t\tcleanups.push(attachReorderAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t} else {\n\t\t\tcleanups.push(attachPushAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t}\n\t}\n\n\tif (options.responsive) {\n\t\tcleanups.push(attachResponsive(element, options.responsive, core));\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Get the size of an item from its data attributes\n */\nexport function getItemSize(item: HTMLElement): { colspan: number; rowspan: number } {\n\treturn {\n\t\tcolspan: parseInt(item.getAttribute('data-egg-colspan') || '1', 10) || 1,\n\t\trowspan: parseInt(item.getAttribute('data-egg-rowspan') || '1', 10) || 1,\n\t};\n}\n\n/**\n * Attach multiple event listeners and return a cleanup function to remove them all\n */\nexport function listenEvents(\n\telement: EventTarget,\n\tevents: Record<string, EventListenerOrEventListenerObject>,\n): () => void {\n\tfor (const [name, handler] of Object.entries(events)) {\n\t\telement.addEventListener(name, handler);\n\t}\n\treturn () => {\n\t\tfor (const [name, handler] of Object.entries(events)) {\n\t\t\telement.removeEventListener(name, handler);\n\t\t}\n\t};\n}\n","/**\n * Shared DOM integration harness for layout algorithms.\n *\n * Provides the boilerplate that every algorithm needs: event listeners for\n * drag/resize, View Transitions, CSS injection via StyleManager, layout\n * provider registration, camera-settled handling, and cleanup.\n *\n * Individual algorithms implement AlgorithmStrategy and call attachAlgorithm().\n */\n\nimport { listenEvents } from \"../engine\";\nimport type {\n  DragEndDetail,\n  DragMoveDetail,\n  DragStartDetail,\n  DragSource,\n  GridCell,\n  EggCore,\n  ItemPosition,\n  LayoutChangeDetail,\n  ResizeCancelDetail,\n  ResizeEndDetail,\n  ResizeMoveDetail,\n  ResizeStartDetail,\n  ResponsiveLayoutModel,\n  StyleManager,\n} from \"../types\";\n\n// ============================================================================\n// Shared types (originally in algorithm-push-core.ts)\n// ============================================================================\n\nexport interface ItemRect {\n  id: string;\n  column: number;\n  row: number;\n  width: number;\n  height: number;\n}\n\n/**\n * Options for CSS generation\n */\nexport interface LayoutToCSSOptions {\n  selectorPrefix?: string;\n  selectorSuffix?: string;\n  excludeSelector?: string;\n  maxColumns?: number;\n}\n\n// ============================================================================\n// Shared pure functions\n// ============================================================================\n\n/**\n * Convert layout to CSS rules for injection into a <style> tag.\n */\nexport function layoutToCSS(\n  items: ItemRect[],\n  options: LayoutToCSSOptions = {},\n): string {\n  const {\n    selectorPrefix = '[data-egg-item=\"',\n    selectorSuffix = '\"]',\n    excludeSelector = \"\",\n    maxColumns,\n  } = options;\n\n  const rules: string[] = [];\n\n  for (const item of items) {\n    const width = maxColumns ? Math.min(item.width, maxColumns) : item.width;\n    const column = maxColumns\n      ? Math.max(1, Math.min(item.column, maxColumns - width + 1))\n      : item.column;\n    const selector = `${selectorPrefix}${item.id}${selectorSuffix}${excludeSelector}`;\n    const gridColumn = `${column} / span ${width}`;\n    const gridRow = `${item.row} / span ${item.height}`;\n\n    rules.push(\n      `${selector} { grid-column: ${gridColumn}; grid-row: ${gridRow}; }`,\n    );\n  }\n\n  return rules.join(\"\\n\");\n}\n\n/**\n * Read item positions from DOM elements\n */\nexport function readItemsFromDOM(container: HTMLElement): ItemRect[] {\n  const elements = container.querySelectorAll(\"[data-egg-item]\");\n  return Array.from(elements).map((el) => {\n    const element = el as HTMLElement;\n    const style = getComputedStyle(element);\n    const column = parseInt(style.gridColumnStart, 10) || 1;\n    const row = parseInt(style.gridRowStart, 10) || 1;\n    const width =\n      parseInt(element.getAttribute(\"data-egg-colspan\") || \"1\", 10) || 1;\n    const height =\n      parseInt(element.getAttribute(\"data-egg-rowspan\") || \"1\", 10) || 1;\n    const id = element.dataset.eggItem || element.dataset.id || \"\";\n\n    return { id, column, row, width, height };\n  });\n}\n\n// ============================================================================\n// Strategy interface\n// ============================================================================\n\nexport interface AlgorithmStrategy {\n  /** Calculate layout after a drag move/end */\n  calculateDragLayout(\n    items: ItemRect[],\n    movedId: string,\n    targetCell: GridCell,\n    columns: number,\n  ): ItemRect[];\n\n  /** Optional hook called after drag-move layout is applied (e.g. emit drop-preview) */\n  afterDragMove?(\n    layout: ItemRect[],\n    movedId: string,\n    gridElement: HTMLElement,\n  ): void;\n\n  /** Calculate layout after a resize move/end. If undefined, resize events are ignored. */\n  calculateResizeLayout?(\n    items: ItemRect[],\n    resizedId: string,\n    cell: GridCell,\n    colspan: number,\n    rowspan: number,\n    columns: number,\n  ): ItemRect[];\n}\n\n// ============================================================================\n// Harness options\n// ============================================================================\n\nexport interface AlgorithmHarnessOptions {\n  selectorPrefix?: string;\n  selectorSuffix?: string;\n  core?: EggCore;\n  layoutModel?: ResponsiveLayoutModel;\n}\n\n// ============================================================================\n// attachAlgorithm — shared DOM integration\n// ============================================================================\n\n/**\n * Attach a layout algorithm strategy to a grid element.\n *\n * Handles all DOM event wiring, View Transitions, CSS injection, layout model\n * persistence, and cleanup. The strategy only needs to provide pure layout\n * calculation functions.\n *\n * @param gridElement - The grid container element\n * @param strategy - Algorithm-specific layout functions\n * @param options - Configuration options\n * @returns Cleanup function to detach the algorithm\n */\nexport function attachAlgorithm(\n  gridElement: HTMLElement,\n  strategy: AlgorithmStrategy,\n  options: AlgorithmHarnessOptions = {},\n): () => void {\n  const {\n    selectorPrefix = '[data-egg-item=\"',\n    selectorSuffix = '\"]',\n    core,\n    layoutModel,\n  } = options;\n  const styles: StyleManager | null = core?.styles ?? null;\n\n  function getCurrentColumnCount(): number {\n    const style = getComputedStyle(gridElement);\n    const columns = style.gridTemplateColumns.split(\" \").filter(Boolean);\n    return Math.max(1, columns.length);\n  }\n\n  let originalPositions: Map<string, { column: number; row: number }> | null =\n    null;\n  let draggedItemId: string | null = null;\n  let draggedElement: HTMLElement | null = null;\n  let dragSource: DragSource | null = null;\n  let layoutVersion = 0;\n  let currentLayout: ItemRect[] | null = null;\n  let dragStartColumnCount: number | null = null;\n\n  // Resize state\n  let resizedItemId: string | null = null;\n  let resizedElement: HTMLElement | null = null;\n  let resizeSource: DragSource | null = null;\n  let resizeOriginalPositions: Map<\n    string,\n    { column: number; row: number; width: number; height: number }\n  > | null = null;\n  let lastResizeLayout: {\n    cell: GridCell;\n    colspan: number;\n    rowspan: number;\n  } | null = null;\n  let resizeStartColumnCount: number | null = null;\n\n  function getItemId(element: HTMLElement): string {\n    return element.dataset.eggItem || element.dataset.id || \"\";\n  }\n\n  /** Read items from DOM with original positions restored (except the actively dragged item) */\n  function getItemsWithOriginals(\n    excludeId: string | null,\n    originals: Map<string, { column: number; row: number }>,\n  ): ItemRect[] {\n    return readItemsFromDOM(gridElement).map((item) => {\n      const original = originals.get(item.id);\n      if (original && item.id !== excludeId) {\n        return { ...item, column: original.column, row: original.row };\n      }\n      return item;\n    });\n  }\n\n  /** Build resize items from original positions, with resized item updated */\n  function getResizeItems(\n    originals: Map<\n      string,\n      { column: number; row: number; width: number; height: number }\n    >,\n    resizedId: string,\n    cell: GridCell,\n    colspan: number,\n    rowspan: number,\n  ): ItemRect[] {\n    const items: ItemRect[] = [];\n    for (const [id, original] of originals) {\n      if (id === resizedId) {\n        items.push({\n          id,\n          column: cell.column,\n          row: cell.row,\n          width: colspan,\n          height: rowspan,\n        });\n      } else {\n        items.push({\n          id,\n          column: original.column,\n          row: original.row,\n          width: original.width,\n          height: original.height,\n        });\n      }\n    }\n    return items;\n  }\n\n  function saveAndClearPreview(\n    layout: ItemRect[],\n    columnCount: number,\n    afterSave?: () => void,\n  ): void {\n    if (!layoutModel || !columnCount) return;\n    const positions = new Map<string, ItemPosition>();\n    for (const item of layout) {\n      positions.set(item.id, { column: item.column, row: item.row });\n    }\n    layoutModel.saveLayout(columnCount, positions);\n    if (afterSave) afterSave();\n    if (styles) {\n      styles.clear(\"preview\");\n      styles.commit();\n    }\n\n    // Emit layout-change only on settled layouts (drag-end / resize-end)\n    if (core) {\n      core.emit<LayoutChangeDetail>(\"layout-change\", {\n        items: layout,\n        columnCount,\n      });\n    }\n  }\n\n  function applyLayout(\n    layout: ItemRect[],\n    excludeId: string | null,\n    useViewTransition: boolean,\n    onApplied?: () => void,\n  ): void {\n    const thisVersion = ++layoutVersion;\n    currentLayout = layout;\n    const capturedColumnCount = dragStartColumnCount ?? resizeStartColumnCount;\n\n    const applyChanges = () => {\n      if (thisVersion !== layoutVersion) return;\n\n      if (styles) {\n        const itemsToStyle = excludeId\n          ? layout.filter((item) => item.id !== excludeId)\n          : layout;\n        const css = layoutToCSS(itemsToStyle, {\n          selectorPrefix,\n          selectorSuffix,\n          maxColumns: capturedColumnCount ?? undefined,\n        });\n        styles.set(\"preview\", css);\n        styles.commit();\n\n        const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n        for (const el of elements) {\n          const element = el as HTMLElement;\n          const id = getItemId(element);\n          const vtn = element.style.viewTransitionName;\n          if (id !== excludeId && vtn !== \"none\") {\n            element.style.gridColumn = \"\";\n            element.style.gridRow = \"\";\n          }\n        }\n      } else {\n        const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n        for (const el of elements) {\n          const element = el as HTMLElement;\n          const id = getItemId(element);\n          if (id === excludeId) continue;\n          const item = layout.find((it) => it.id === id);\n          if (item) {\n            const colspan =\n              parseInt(\n                element.getAttribute(\"data-egg-colspan\") || \"1\",\n                10,\n              ) || 1;\n            const rowspan =\n              parseInt(\n                element.getAttribute(\"data-egg-rowspan\") || \"1\",\n                10,\n              ) || 1;\n            element.style.gridColumn = `${item.column} / span ${colspan}`;\n            element.style.gridRow = `${item.row} / span ${rowspan}`;\n          }\n        }\n      }\n\n      if (onApplied) onApplied();\n    };\n\n    if (useViewTransition && \"startViewTransition\" in document) {\n      if (draggedElement && excludeId) {\n        draggedElement.style.viewTransitionName = \"dragging\";\n      }\n      (document as any).startViewTransition(applyChanges);\n    } else {\n      applyChanges();\n    }\n  }\n\n  // =========================================================================\n  // Drag event handlers\n  // =========================================================================\n\n  const onDragStart = (e: Event) => {\n    const detail = (e as CustomEvent<DragStartDetail>).detail;\n    draggedElement = detail.item;\n    draggedItemId = getItemId(detail.item);\n    dragSource = detail.source;\n    dragStartColumnCount = getCurrentColumnCount();\n\n    const items = readItemsFromDOM(gridElement);\n    originalPositions = new Map();\n    for (const item of items) {\n      originalPositions.set(item.id, { column: item.column, row: item.row });\n    }\n\n    if (styles) {\n      const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n      for (const el of elements) {\n        const element = el as HTMLElement;\n        if (element !== draggedElement) {\n          element.style.gridColumn = \"\";\n          element.style.gridRow = \"\";\n        }\n      }\n      const css = layoutToCSS(items, {\n        selectorPrefix,\n        selectorSuffix,\n        maxColumns: dragStartColumnCount,\n      });\n      styles.set(\"preview\", css);\n      styles.commit();\n    }\n  };\n\n  let pendingCell: GridCell | null = null;\n\n  const onDragMove = (e: Event) => {\n    if (!draggedItemId || !originalPositions) return;\n    const detail = (e as CustomEvent<DragMoveDetail>).detail;\n\n    if (core?.cameraScrolling) {\n      pendingCell = detail.cell;\n      return;\n    }\n    pendingCell = null;\n\n    const items = getItemsWithOriginals(draggedItemId, originalPositions!);\n    const columns = dragStartColumnCount ?? getCurrentColumnCount();\n    const newLayout = strategy.calculateDragLayout(\n      items,\n      draggedItemId,\n      detail.cell,\n      columns,\n    );\n    applyLayout(newLayout, draggedItemId, true);\n\n    if (strategy.afterDragMove) {\n      strategy.afterDragMove(newLayout, draggedItemId, gridElement);\n    }\n  };\n\n  const onDragEnd = (e: Event) => {\n    if (!draggedItemId || !originalPositions) return;\n    const detail = (e as CustomEvent<DragEndDetail>).detail;\n    const items = getItemsWithOriginals(draggedItemId, originalPositions!);\n\n    const columns = dragStartColumnCount ?? getCurrentColumnCount();\n    const finalLayout = strategy.calculateDragLayout(\n      items,\n      draggedItemId,\n      detail.cell,\n      columns,\n    );\n\n    const isPointerDrag = dragSource === \"pointer\";\n    if (\n      draggedElement &&\n      draggedElement.style.viewTransitionName === \"dragging\"\n    ) {\n      draggedElement.style.viewTransitionName = \"\";\n    }\n\n    const useViewTransition = !isPointerDrag;\n    const savedDragStartColumnCount = dragStartColumnCount;\n\n    applyLayout(finalLayout, null, useViewTransition, () =>\n      saveAndClearPreview(finalLayout, savedDragStartColumnCount!),\n    );\n\n    draggedItemId = null;\n    draggedElement = null;\n    dragSource = null;\n    originalPositions = null;\n    pendingCell = null;\n    dragStartColumnCount = null;\n  };\n\n  const onDragCancel = () => {\n    if (!draggedItemId || !originalPositions) return;\n\n    if (\n      draggedElement &&\n      draggedElement.style.viewTransitionName === \"dragging\"\n    ) {\n      draggedElement.style.viewTransitionName = \"\";\n    }\n\n    const restoreLayout = getItemsWithOriginals(null, originalPositions!);\n    const restore = () => applyLayout(restoreLayout, null, false);\n\n    if (\"startViewTransition\" in document) {\n      (document as any).startViewTransition(restore);\n    } else {\n      restore();\n    }\n\n    draggedItemId = null;\n    draggedElement = null;\n    dragSource = null;\n    originalPositions = null;\n    pendingCell = null;\n    dragStartColumnCount = null;\n  };\n\n  const onCameraSettled = () => {\n    if (!draggedItemId || !originalPositions) return;\n\n    let cell = pendingCell;\n    if (!cell && draggedElement) {\n      const rect = draggedElement.getBoundingClientRect();\n      const centerX = rect.left + rect.width / 2;\n      const centerY = rect.top + rect.height / 2;\n      cell = core?.getCellFromPoint(centerX, centerY) ?? null;\n    }\n\n    if (!cell) return;\n    pendingCell = null;\n\n    const items = getItemsWithOriginals(draggedItemId, originalPositions!);\n    const columns = dragStartColumnCount ?? getCurrentColumnCount();\n    const newLayout = strategy.calculateDragLayout(\n      items,\n      draggedItemId!,\n      cell,\n      columns,\n    );\n    applyLayout(newLayout, draggedItemId, true);\n\n    if (strategy.afterDragMove) {\n      strategy.afterDragMove(newLayout, draggedItemId!, gridElement);\n    }\n  };\n\n  // =========================================================================\n  // Resize event handlers (only if strategy supports resize)\n  // =========================================================================\n\n  const onResizeStart = (e: Event) => {\n    if (!strategy.calculateResizeLayout) return;\n    const detail = (e as CustomEvent<ResizeStartDetail>).detail;\n    resizedElement = detail.item;\n    resizedItemId = getItemId(detail.item);\n    resizeSource = detail.source;\n    resizeStartColumnCount = getCurrentColumnCount();\n\n    const items = readItemsFromDOM(gridElement);\n    resizeOriginalPositions = new Map();\n    for (const item of items) {\n      resizeOriginalPositions.set(item.id, {\n        column: item.column,\n        row: item.row,\n        width: item.width,\n        height: item.height,\n      });\n    }\n\n    if (styles) {\n      const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n      for (const el of elements) {\n        const element = el as HTMLElement;\n        if (element !== resizedElement) {\n          element.style.gridColumn = \"\";\n          element.style.gridRow = \"\";\n        }\n      }\n      const css = layoutToCSS(items, {\n        selectorPrefix,\n        selectorSuffix,\n        maxColumns: resizeStartColumnCount,\n      });\n      styles.set(\"preview\", css);\n      styles.commit();\n    }\n\n    lastResizeLayout = null;\n  };\n\n  const onResizeMove = (e: Event) => {\n    if (!strategy.calculateResizeLayout) return;\n    if (!resizedItemId || !resizeOriginalPositions) return;\n    const detail = (e as CustomEvent<ResizeMoveDetail>).detail;\n\n    if (\n      lastResizeLayout &&\n      lastResizeLayout.cell.column === detail.cell.column &&\n      lastResizeLayout.cell.row === detail.cell.row &&\n      lastResizeLayout.colspan === detail.colspan &&\n      lastResizeLayout.rowspan === detail.rowspan\n    ) {\n      return;\n    }\n    lastResizeLayout = {\n      cell: { ...detail.cell },\n      colspan: detail.colspan,\n      rowspan: detail.rowspan,\n    };\n\n    const items = getResizeItems(\n      resizeOriginalPositions,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n    );\n    const columns = resizeStartColumnCount ?? getCurrentColumnCount();\n    const newLayout = strategy.calculateResizeLayout(\n      items,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n      columns,\n    );\n    applyLayout(newLayout, resizedItemId, true);\n  };\n\n  const onResizeEnd = (e: Event) => {\n    if (!strategy.calculateResizeLayout) return;\n    if (!resizedItemId || !resizeOriginalPositions) return;\n    const detail = (e as CustomEvent<ResizeEndDetail>).detail;\n    const items = getResizeItems(\n      resizeOriginalPositions,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n    );\n\n    const columns = resizeStartColumnCount ?? getCurrentColumnCount();\n    const finalLayout = strategy.calculateResizeLayout(\n      items,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n      columns,\n    );\n\n    const isPointerResize = resizeSource === \"pointer\";\n    const useViewTransition = !isPointerResize;\n    const savedResizedItemId = resizedItemId;\n    const savedResizeStartColumnCount = resizeStartColumnCount;\n\n    applyLayout(finalLayout, null, useViewTransition, () =>\n      saveAndClearPreview(finalLayout, savedResizeStartColumnCount!, () => {\n        layoutModel!.updateItemSize(savedResizedItemId!, {\n          width: detail.colspan,\n          height: detail.rowspan,\n        });\n      }),\n    );\n\n    resizedItemId = null;\n    resizedElement = null;\n    resizeSource = null;\n    resizeOriginalPositions = null;\n    lastResizeLayout = null;\n    resizeStartColumnCount = null;\n  };\n\n  const onResizeCancel = () => {\n    if (!resizedItemId || !resizeOriginalPositions) return;\n\n    const restoreLayout = Array.from(resizeOriginalPositions, ([id, o]) => ({\n      id,\n      column: o.column,\n      row: o.row,\n      width: o.width,\n      height: o.height,\n    }));\n    const restore = () => applyLayout(restoreLayout, null, false);\n\n    if (\"startViewTransition\" in document) {\n      (document as any).startViewTransition(restore);\n    } else {\n      restore();\n    }\n\n    resizedItemId = null;\n    resizedElement = null;\n    resizeSource = null;\n    resizeOriginalPositions = null;\n    lastResizeLayout = null;\n    resizeStartColumnCount = null;\n  };\n\n  // =========================================================================\n  // Event listener registration\n  // =========================================================================\n\n  return listenEvents(gridElement, {\n    \"egg-drag-start\": onDragStart,\n    \"egg-drag-move\": onDragMove,\n    \"egg-drag-end\": onDragEnd,\n    \"egg-drag-cancel\": onDragCancel,\n    \"egg-camera-settled\": onCameraSettled,\n    \"egg-resize-start\": onResizeStart,\n    \"egg-resize-move\": onResizeMove,\n    \"egg-resize-end\": onResizeEnd,\n    \"egg-resize-cancel\": onResizeCancel,\n  });\n}\n","/**\n * Reorder layout algorithm for EG Grid\n *\n * Sequence-based reflow: items have a logical order, dragging changes\n * position in that sequence, all items reflow like CSS Grid auto-placement.\n *\n * Usage (pure functions):\n *   import { calculateReorderLayout, reflowItems, layoutToCSS } from 'eg-grid/algorithm-reorder';\n *\n * Usage (DOM integration):\n *   import { attachReorderAlgorithm } from 'eg-grid/algorithm-reorder';\n *   const detach = attachReorderAlgorithm(grid.element, { core });\n */\n\nimport type {\n\tGridCell,\n\tEggCore,\n\tResponsiveLayoutModel,\n} from '../types';\n\nimport {\n\tattachAlgorithm,\n\ttype AlgorithmStrategy,\n\ttype ItemRect,\n} from './algorithm-harness';\n\n// Re-export shared types and functions from harness\nexport {\n\tlayoutToCSS,\n\ttype ItemRect,\n\ttype LayoutToCSSOptions,\n} from './algorithm-harness';\n\n// Also re-export GridCell so consumers don't need to import from types.ts\nexport type { GridCell } from '../types';\n\n// ============================================================================\n// Pure reorder algorithm\n// ============================================================================\n\n/**\n * Sort items into reading order (row-major: row first, then column)\n */\nexport function getItemOrder(items: ItemRect[]): ItemRect[] {\n\treturn [...items].sort((a, b) => a.row - b.row || a.column - b.column);\n}\n\n/**\n * Check if a cell range is available (not occupied)\n */\nfunction rangeAvailable(\n\toccupied: Set<string>,\n\tcolumn: number,\n\trow: number,\n\twidth: number,\n\theight: number,\n\tcolumns: number,\n): boolean {\n\tif (column + width - 1 > columns) return false;\n\n\tfor (let r = row; r < row + height; r++) {\n\t\tfor (let c = column; c < column + width; c++) {\n\t\t\tif (occupied.has(`${c},${r}`)) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Mark cells as occupied\n */\nfunction markOccupied(\n\toccupied: Set<string>,\n\tcolumn: number,\n\trow: number,\n\twidth: number,\n\theight: number,\n): void {\n\tfor (let r = row; r < row + height; r++) {\n\t\tfor (let c = column; c < column + width; c++) {\n\t\t\toccupied.add(`${c},${r}`);\n\t\t}\n\t}\n}\n\n/**\n * Reflow items into grid positions using auto-placement.\n * Scans left-to-right, top-to-bottom for the first position each item fits.\n *\n * @param items - Items in logical order (sequence determines placement priority)\n * @param columns - Number of grid columns\n * @returns New array with updated positions\n */\nexport function reflowItems(items: ItemRect[], columns: number): ItemRect[] {\n\tconst occupied = new Set<string>();\n\tconst result: ItemRect[] = [];\n\n\tfor (const item of items) {\n\t\tconst width = Math.min(item.width, columns);\n\t\tlet placed = false;\n\n\t\tfor (let row = 1; !placed; row++) {\n\t\t\tfor (let col = 1; col <= columns; col++) {\n\t\t\t\tif (rangeAvailable(occupied, col, row, width, item.height, columns)) {\n\t\t\t\t\tmarkOccupied(occupied, col, row, width, item.height);\n\t\t\t\t\tresult.push({ ...item, column: col, row, width });\n\t\t\t\t\tplaced = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Safety: prevent infinite loop on pathological inputs\n\t\t\tif (row > 100) {\n\t\t\t\tresult.push({ ...item, column: 1, row, width });\n\t\t\t\tmarkOccupied(occupied, 1, row, width, item.height);\n\t\t\t\tplaced = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Compare positions in reading order (row-major)\n */\nfunction positionBefore(a: GridCell, b: GridCell): boolean {\n\treturn a.row < b.row || (a.row === b.row && a.column < b.column);\n}\n\n/**\n * Options for calculateReorderLayout\n */\nexport interface CalculateReorderLayoutOptions {\n\t/** Number of grid columns */\n\tcolumns: number;\n}\n\n/**\n * Calculate new layout after reordering an item.\n *\n * 1. Sort items by current position to get logical order\n * 2. Remove moved item from sequence\n * 3. Reflow remaining items to get candidate positions\n * 4. Find insertion index: before the first candidate whose reflowed position\n *    comes after targetCell in reading order\n * 5. Insert moved item at that index\n * 6. Reflow all items\n *\n * @returns New array with updated positions\n */\nexport function calculateReorderLayout(\n\titems: ItemRect[],\n\tmovedId: string,\n\ttargetCell: GridCell,\n\toptions: CalculateReorderLayoutOptions,\n): ItemRect[] {\n\tconst { columns } = options;\n\n\t// Deep copy items\n\tconst all = items.map((item) => ({ ...item }));\n\n\t// Get logical order from current positions\n\tconst ordered = getItemOrder(all);\n\n\t// Extract moved item\n\tconst movedItem = ordered.find((it) => it.id === movedId);\n\tif (!movedItem) return reflowItems(ordered, columns);\n\n\tconst remaining = ordered.filter((it) => it.id !== movedId);\n\n\t// Reflow remaining to get candidate positions\n\tconst reflowed = reflowItems(remaining, columns);\n\n\t// Find insertion index: before the first reflowed item whose position\n\t// comes after targetCell in reading order\n\tlet insertIndex = reflowed.length; // default: append at end\n\tfor (let i = 0; i < reflowed.length; i++) {\n\t\tif (!positionBefore(reflowed[i], targetCell)) {\n\t\t\tinsertIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Build final sequence with moved item inserted\n\tconst finalSequence: ItemRect[] = [\n\t\t...remaining.slice(0, insertIndex),\n\t\tmovedItem,\n\t\t...remaining.slice(insertIndex),\n\t];\n\n\t// Reflow everything\n\treturn reflowItems(finalSequence, columns);\n}\n\n// ============================================================================\n// DOM integration via harness\n// ============================================================================\n\n/**\n * Options for attachReorderAlgorithm\n */\nexport interface AttachReorderAlgorithmOptions {\n\tselectorPrefix?: string;\n\tselectorSuffix?: string;\n\tcore?: EggCore;\n\tlayoutModel?: ResponsiveLayoutModel;\n}\n\n/**\n * Attach reorder algorithm to a grid element.\n *\n * Listens to drag/resize events and reflows items in sequence order.\n * Layout changes are animated via View Transitions.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach the algorithm\n */\nexport function attachReorderAlgorithm(\n\tgridElement: HTMLElement,\n\toptions: AttachReorderAlgorithmOptions = {},\n): () => void {\n\tconst strategy: AlgorithmStrategy = {\n\t\tcalculateDragLayout(items, movedId, targetCell, columns) {\n\t\t\treturn calculateReorderLayout(items, movedId, targetCell, { columns });\n\t\t},\n\n\t\tafterDragMove(layout, movedId, el) {\n\t\t\t// Emit drop-preview so the placeholder knows the actual landing position.\n\t\t\t// Use queueMicrotask to ensure this fires AFTER all drag-move handlers\n\t\t\t// (including the placeholder's) have finished, regardless of listener order.\n\t\t\tconst landingItem = layout.find((it) => it.id === movedId);\n\t\t\tif (landingItem) {\n\t\t\t\tconst previewDetail = {\n\t\t\t\t\tcell: { column: landingItem.column, row: landingItem.row },\n\t\t\t\t\tcolspan: landingItem.width,\n\t\t\t\t\trowspan: landingItem.height,\n\t\t\t\t};\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tel.dispatchEvent(new CustomEvent('egg-drop-preview', {\n\t\t\t\t\t\tdetail: previewDetail,\n\t\t\t\t\t\tbubbles: true,\n\t\t\t\t\t}));\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tcalculateResizeLayout(items, _resizedId, _cell, _colspan, _rowspan, columns) {\n\t\t\t// For resize, reflow all items in their current order with the resized item's new size\n\t\t\tconst ordered = [...items].sort((a, b) => a.row - b.row || a.column - b.column);\n\t\t\treturn reflowItems(ordered, columns);\n\t\t},\n\t};\n\n\treturn attachAlgorithm(gridElement, strategy, options);\n}\n\n"],"mappings":"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"}