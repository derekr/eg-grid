{"version":3,"file":"eg-grid-element.min.js","names":[],"sources":["../src/state-machine.ts","../src/utils/flip.ts","../src/plugins/pointer.ts","../src/plugins/keyboard.ts","../src/plugins/accessibility.ts","../src/plugins/resize.ts","../src/plugins/camera.ts","../src/plugins/placeholder.ts","../src/plugins/algorithm-harness.ts","../src/plugins/algorithm-push.ts","../src/plugins/algorithm-reorder.ts","../src/plugins/responsive.ts","../src/engine.ts","../src/layout-model.ts","../src/eg-grid-element.ts","../src/bundles/element.ts"],"sourcesContent":["/**\n * Centralized State Machine for EG Grid\n *\n * Single source of truth for interaction state.\n *\n * Key invariants:\n * 1. Only ONE interaction can be active at a time (drag OR resize, not both)\n * 2. Column count is captured at interaction start and immutable during interaction\n * 3. Phases: idle → selected → interacting → committing → selected\n */\n\n// ============================================================================\n// State Types\n// ============================================================================\n\nexport type InteractionMode = 'pointer' | 'keyboard';\n\nexport type InteractionType = 'drag' | 'resize';\n\nexport type EggPhase =\n\t| 'idle'\n\t| 'selected'\n\t| 'interacting'  // Active drag or resize\n\t| 'committing';  // Saving to layout model, clearing preview\n\nexport interface InteractionContext {\n\t/** The type of interaction (drag or resize) */\n\ttype: InteractionType;\n\t/** How the interaction was initiated */\n\tmode: InteractionMode;\n\t/** The item being interacted with */\n\titemId: string;\n\t/** The DOM element being interacted with */\n\telement: HTMLElement;\n\t/** Column count at interaction start (immutable during interaction) */\n\tcolumnCount: number;\n}\n\nexport interface EggState {\n\tphase: EggPhase;\n\tselectedItemId: string | null;\n\tinteraction: InteractionContext | null;\n}\n\n// ============================================================================\n// State Machine\n// ============================================================================\n\nexport type StateTransition =\n\t| { type: 'SELECT'; itemId: string; element: HTMLElement }\n\t| { type: 'DESELECT' }\n\t| { type: 'START_INTERACTION'; context: InteractionContext }\n\t| { type: 'COMMIT_INTERACTION' }\n\t| { type: 'CANCEL_INTERACTION' }\n\t| { type: 'FINISH_COMMIT' };\n\nexport interface EggStateMachine {\n\tgetState(): EggState;\n\ttransition(action: StateTransition): EggState;\n}\n\nfunction reducer(state: EggState, action: StateTransition): EggState {\n\tswitch (action.type) {\n\t\tcase 'SELECT': {\n\t\t\tif (state.phase !== 'idle' && state.phase !== 'selected') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'selected',\n\t\t\t\tselectedItemId: action.itemId,\n\t\t\t};\n\t\t}\n\n\t\tcase 'DESELECT': {\n\t\t\tif (state.phase !== 'selected') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'idle',\n\t\t\t\tselectedItemId: null,\n\t\t\t};\n\t\t}\n\n\t\tcase 'START_INTERACTION': {\n\t\t\tif (state.phase !== 'selected') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'interacting',\n\t\t\t\tinteraction: action.context,\n\t\t\t};\n\t\t}\n\n\t\tcase 'COMMIT_INTERACTION': {\n\t\t\tif (state.phase !== 'interacting') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'committing',\n\t\t\t};\n\t\t}\n\n\t\tcase 'CANCEL_INTERACTION': {\n\t\t\tif (state.phase !== 'interacting') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'selected',\n\t\t\t\tinteraction: null,\n\t\t\t};\n\t\t}\n\n\t\tcase 'FINISH_COMMIT': {\n\t\t\tif (state.phase !== 'committing') {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tphase: 'selected',\n\t\t\t\tinteraction: null,\n\t\t\t};\n\t\t}\n\n\t\tdefault:\n\t\t\treturn state;\n\t}\n}\n\n/**\n * Create a state machine instance\n */\nexport function createStateMachine(): EggStateMachine {\n\tlet state: EggState = {\n\t\tphase: 'idle',\n\t\tselectedItemId: null,\n\t\tinteraction: null,\n\t};\n\n\treturn {\n\t\tgetState() {\n\t\t\treturn state;\n\t\t},\n\n\t\ttransition(action: StateTransition) {\n\t\t\tconst nextState = reducer(state, action);\n\t\t\tif (nextState !== state) {\n\t\t\t\tstate = nextState;\n\t\t\t}\n\t\t\treturn state;\n\t\t},\n\t};\n}\n\nexport function isDragging(state: EggState): boolean {\n\treturn (state.phase === 'interacting' || state.phase === 'committing') && state.interaction?.type === 'drag';\n}\n\nexport function isResizing(state: EggState): boolean {\n\treturn (state.phase === 'interacting' || state.phase === 'committing') && state.interaction?.type === 'resize';\n}\n","/**\n * FLIP Animation Utility\n *\n * Provides shared FLIP (First, Last, Invert, Play) animation utilities\n * used by pointer and resize plugins for smooth position/scale transitions.\n */\n\nexport interface FLIPOptions {\n\tduration?: number;\n\teasing?: string;\n\tonStart?: () => void;\n\tonFinish?: () => void;\n}\n\n/**\n * Animate an element from its previous position/size to its new position/size using FLIP.\n *\n * @param element - The element to animate\n * @param firstRect - The element's bounding rect before the DOM change (the \"First\" in FLIP)\n * @param options - Animation options\n * @returns The Animation object, or null if no animation was needed\n *\n * @example\n * ```ts\n * // Capture position before DOM change\n * const firstRect = element.getBoundingClientRect();\n *\n * // Make DOM changes (e.g., update grid position)\n * element.style.gridColumn = '2 / span 2';\n *\n * // Animate from old position to new\n * requestAnimationFrame(() => {\n *   animateFLIP(element, firstRect);\n * });\n * ```\n */\nexport function animateFLIP(\n\telement: HTMLElement,\n\tfirstRect: DOMRect,\n\toptions: FLIPOptions = {},\n): Animation | null {\n\tconst {\n\t\tduration = 200,\n\t\teasing = 'cubic-bezier(0.2, 0, 0, 1)',\n\t\tonStart,\n\t\tonFinish,\n\t} = options;\n\n\tconst lastRect = element.getBoundingClientRect();\n\tconst deltaX = firstRect.left - lastRect.left;\n\tconst deltaY = firstRect.top - lastRect.top;\n\n\tif (Math.abs(deltaX) <= 1 && Math.abs(deltaY) <= 1) {\n\t\tonFinish?.();\n\t\treturn null;\n\t}\n\n\tonStart?.();\n\n\tconst keyframes: Keyframe[] = [\n\t\t{ transform: `translate(${deltaX}px, ${deltaY}px)` },\n\t\t{ transform: 'translate(0, 0)' },\n\t];\n\n\t// Play the animation\n\tconst animation = element.animate(keyframes, {\n\t\tduration,\n\t\teasing,\n\t});\n\n\tanimation.onfinish = () => onFinish?.();\n\n\treturn animation;\n}\n\n/**\n * Get the item's view transition name from various sources.\n * Checks --item-id CSS property, id attribute, and data-id attribute.\n */\nexport function getItemViewTransitionName(element: HTMLElement): string | null {\n\treturn (\n\t\telement.style.getPropertyValue('--item-id') ||\n\t\telement.dataset.eggItem ||\n\t\telement.id ||\n\t\telement.dataset.id ||\n\t\tnull\n\t);\n}\n\n/**\n * FLIP animation with View Transition exclusion and data attribute tracking.\n */\nexport function animateFLIPWithTracking(\n\telement: HTMLElement,\n\tfirstRect: DOMRect,\n\toptions: FLIPOptions & { attributeName?: string } = {},\n): Animation | null {\n\tconst { attributeName = 'data-egg-dropping', ...flipOptions } = options;\n\n\t// Exclude from View Transitions\n\telement.style.viewTransitionName = 'none';\n\n\tconst animation = animateFLIP(element, firstRect, {\n\t\t...flipOptions,\n\t\tonStart: () => {\n\t\t\telement.setAttribute(attributeName, '');\n\t\t\tflipOptions.onStart?.();\n\t\t},\n\t\tonFinish: () => {\n\t\t\telement.removeAttribute(attributeName);\n\t\t\t// Restore view transition name\n\t\t\tconst itemId = getItemViewTransitionName(element);\n\t\t\tif (itemId) {\n\t\t\t\telement.style.viewTransitionName = itemId;\n\t\t\t}\n\t\t\tflipOptions.onFinish?.();\n\t\t},\n\t});\n\n\t// If no animation was needed, clean up immediately\n\tif (!animation) {\n\t\tconst itemId = getItemViewTransitionName(element);\n\t\tif (itemId) {\n\t\t\telement.style.viewTransitionName = itemId;\n\t\t}\n\t}\n\n\treturn animation;\n}\n","import { getItemCell, getItemSize } from '../engine';\nimport type { GridCell, EggCore } from '../types';\nimport { animateFLIPWithTracking } from '../utils/flip';\n\n// Hysteresis: distance in grid units before changing target cell\nconst HYSTERESIS = 0.4;\n// Minimum time (ms) between target changes to prevent jitter\nconst TARGET_CHANGE_DEBOUNCE = 40;\n// Minimum pixels of movement before starting a drag\nconst DRAG_THRESHOLD = 5;\n// Minimum pixels of cumulative movement before applying predictive offset\nconst PREDICTION_THRESHOLD = 30;\n// Fraction of cell to lead ahead when prediction is active (0.5 = half a cell)\nconst PREDICTION_LEAD = 0.5;\n\ninterface PendingDrag {\n\titem: HTMLElement;\n\tpointerId: number;\n\tstartX: number;\n\tstartY: number;\n\trect: DOMRect;\n\tstartCell: GridCell;\n\tcolspan: number;\n\trowspan: number;\n}\n\ninterface DragState {\n\titem: HTMLElement;\n\tpointerId: number;\n\toffsetX: number;\n\toffsetY: number;\n\tinitialRect: DOMRect;\n\tstartCell: GridCell;\n\tlastCell: GridCell;\n\tlastTargetChangeTime: number;\n\tcolspan: number;\n\trowspan: number;\n\t// For predictive placeholder\n\tdragStartX: number;\n\tdragStartY: number;\n}\n\n/**\n * Attach pointer (mouse/touch) drag handling to a EggCore instance.\n * @returns Cleanup function\n */\nexport function attachPointer(core: EggCore): () => void {\n\tlet pendingDrag: PendingDrag | null = null;\n\tlet dragState: DragState | null = null;\n\n\tconst startDrag = (pending: PendingDrag, e: PointerEvent) => {\n\t\tconst { item, pointerId, rect, startCell, colspan, rowspan } = pending;\n\n\t\tdragState = {\n\t\t\titem,\n\t\t\tpointerId,\n\t\t\toffsetX: e.clientX - rect.left,\n\t\t\toffsetY: e.clientY - rect.top,\n\t\t\tinitialRect: rect,\n\t\t\tstartCell,\n\t\t\tlastCell: startCell,\n\t\t\tlastTargetChangeTime: 0,\n\t\t\tcolspan,\n\t\t\trowspan,\n\t\t\tdragStartX: e.clientX,\n\t\t\tdragStartY: e.clientY,\n\t\t};\n\n\t\titem.setAttribute('data-egg-dragging', '');\n\t\tdocument.body.classList.add('is-dragging');\n\n\t\t// Transition state machine to interacting\n\t\tconst itemId = item.id || item.getAttribute('data-egg-item') || '';\n\t\tcore.stateMachine.transition({\n\t\t\ttype: 'START_INTERACTION',\n\t\t\tcontext: { type: 'drag', mode: 'pointer', itemId, element: item, columnCount: core.getGridInfo().columns.length },\n\t\t});\n\n\t\t// Emit drag-start BEFORE changing grid styles so originalPositions captures correct layout\n\t\tcore.emit('drag-start', { item, cell: startCell, colspan, rowspan, source: 'pointer' as const });\n\n\t\t// Switch to fixed positioning - CSS Grid ignores fixed positioned children\n\t\t// No need to move item out of grid container\n\t\titem.style.position = 'fixed';\n\t\titem.style.left = `${rect.left}px`;\n\t\titem.style.top = `${rect.top}px`;\n\t\titem.style.width = `${rect.width}px`;\n\t\titem.style.height = `${rect.height}px`;\n\t\titem.style.zIndex = '100';\n\n\t\tpendingDrag = null;\n\t};\n\n\tconst onPointerDown = (e: PointerEvent) => {\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-egg-item]',\n\t\t) as HTMLElement | null;\n\t\tif (!item) return;\n\n\t\t// Select the item on click\n\t\tcore.select(item);\n\n\t\t// Prevent text selection during potential drag\n\t\te.preventDefault();\n\n\t\tconst rect = item.getBoundingClientRect();\n\t\tconst startCell = getItemCell(item);\n\t\tconst { colspan, rowspan } = getItemSize(item);\n\n\t\t// Store pending drag state - don't start drag until movement\n\t\tpendingDrag = {\n\t\t\titem,\n\t\t\tpointerId: e.pointerId,\n\t\t\tstartX: e.clientX,\n\t\t\tstartY: e.clientY,\n\t\t\trect,\n\t\t\tstartCell,\n\t\t\tcolspan,\n\t\t\trowspan,\n\t\t};\n\n\t\titem.setPointerCapture(e.pointerId);\n\t\titem.addEventListener('pointermove', onPointerMove);\n\t\titem.addEventListener('pointerup', onPointerUp);\n\t\titem.addEventListener('pointercancel', onPointerCancel);\n\t};\n\n\tconst onPointerMove = (e: PointerEvent) => {\n\t\t// Check if we need to start dragging\n\t\tif (pendingDrag && !dragState) {\n\t\t\tconst dx = e.clientX - pendingDrag.startX;\n\t\t\tconst dy = e.clientY - pendingDrag.startY;\n\t\t\tconst distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\tif (distance >= DRAG_THRESHOLD) {\n\t\t\t\tstartDrag(pendingDrag, e);\n\t\t\t} else {\n\t\t\t\treturn; // Not enough movement yet\n\t\t\t}\n\t\t}\n\n\t\tif (!dragState) return;\n\n\t\tconst { item, offsetX, offsetY, initialRect, colspan, rowspan } = dragState;\n\n\t\t// Move item with cursor\n\t\tconst newLeft = e.clientX - offsetX;\n\t\tconst newTop = e.clientY - offsetY;\n\t\titem.style.left = `${newLeft}px`;\n\t\titem.style.top = `${newTop}px`;\n\n\t\t// Calculate target based on card center (feels more natural for multi-cell items)\n\t\tlet cardCenterX = newLeft + initialRect.width / 2;\n\t\tlet cardCenterY = newTop + initialRect.height / 2;\n\n\t\t// Predictive offset: shift the effective center in the direction of movement\n\t\tconst gridInfo = core.getGridInfo();\n\t\tconst cumulativeDx = e.clientX - dragState.dragStartX;\n\t\tconst cumulativeDy = e.clientY - dragState.dragStartY;\n\n\t\t// Apply prediction offset when movement exceeds threshold\n\t\tif (Math.abs(cumulativeDx) > PREDICTION_THRESHOLD) {\n\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellWidth + gridInfo.gap);\n\t\t\tcardCenterX += Math.sign(cumulativeDx) * leadOffset;\n\t\t}\n\t\tif (Math.abs(cumulativeDy) > PREDICTION_THRESHOLD) {\n\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellHeight + gridInfo.gap);\n\t\t\tcardCenterY += Math.sign(cumulativeDy) * leadOffset;\n\t\t}\n\n\t\tconst rawCell = core.getCellFromPoint(cardCenterX, cardCenterY);\n\t\tif (rawCell) {\n\t\t\t// Clamp cell so item fits within grid bounds\n\t\t\tconst gridInfo = core.getGridInfo();\n\t\t\tconst maxColumn = Math.max(1, gridInfo.columns.length - colspan + 1);\n\t\t\tconst maxRow = Math.max(1, gridInfo.rows.length - rowspan + 1);\n\n\t\t\tconst cell: GridCell = {\n\t\t\t\tcolumn: Math.max(1, Math.min(maxColumn, rawCell.column)),\n\t\t\t\trow: Math.max(1, Math.min(maxRow, rawCell.row)),\n\t\t\t};\n\n\t\t\tconst now = performance.now();\n\t\t\tconst timeSinceLastChange = now - dragState.lastTargetChangeTime;\n\n\t\t\t// Check if cell actually changed\n\t\t\tconst cellChanged =\n\t\t\t\tcell.column !== dragState.lastCell.column ||\n\t\t\t\tcell.row !== dragState.lastCell.row;\n\n\t\t\tif (cellChanged && timeSinceLastChange >= TARGET_CHANGE_DEBOUNCE) {\n\t\t\t\tconst cellWidth = gridInfo.cellWidth + gridInfo.gap;\n\t\t\t\tconst cellHeight = gridInfo.cellHeight + gridInfo.gap;\n\n\t\t\t\t// Current cell center in pixels (CSS Grid is 1-indexed)\n\t\t\t\tconst currentCellCenterX =\n\t\t\t\t\tgridInfo.rect.left +\n\t\t\t\t\t(dragState.lastCell.column - 1) * cellWidth +\n\t\t\t\t\tgridInfo.cellWidth / 2;\n\t\t\t\tconst currentCellCenterY =\n\t\t\t\t\tgridInfo.rect.top +\n\t\t\t\t\t(dragState.lastCell.row - 1) * cellHeight +\n\t\t\t\t\tgridInfo.cellHeight / 2;\n\n\t\t\t\t// Signed distance from card center to current cell center (in grid units)\n\t\t\t\tconst offsetFromCellX = (cardCenterX - currentCellCenterX) / cellWidth;\n\t\t\t\tconst offsetFromCellY = (cardCenterY - currentCellCenterY) / cellHeight;\n\n\t\t\t\t// Direction-aware hysteresis\n\t\t\t\tconst newCellIsRight = cell.column > dragState.lastCell.column;\n\t\t\t\tconst newCellIsBelow = cell.row > dragState.lastCell.row;\n\t\t\t\tconst cardIsRight = offsetFromCellX > 0;\n\t\t\t\tconst cardIsBelow = offsetFromCellY > 0;\n\n\t\t\t\tconst alignedX = (newCellIsRight && cardIsRight) || (!newCellIsRight && !cardIsRight);\n\t\t\t\tconst alignedY = (newCellIsBelow && cardIsBelow) || (!newCellIsBelow && !cardIsBelow);\n\n\t\t\t\tconst thresholdX = alignedX ? 0.5 : 0.5 + HYSTERESIS;\n\t\t\t\tconst thresholdY = alignedY ? 0.5 : 0.5 + HYSTERESIS;\n\n\t\t\t\tconst distX = Math.abs(offsetFromCellX);\n\t\t\t\tconst distY = Math.abs(offsetFromCellY);\n\n\t\t\t\tif (distX < thresholdX && distY < thresholdY) {\n\t\t\t\t\treturn; // Stay in current cell\n\t\t\t\t}\n\n\t\t\t\tdragState.lastCell = cell;\n\t\t\t\tdragState.lastTargetChangeTime = now;\n\t\t\t\tcore.emit('drag-move', { item, cell, x: e.clientX, y: e.clientY, colspan, rowspan, source: 'pointer' as const });\n\t\t\t}\n\t\t}\n\t};\n\n\tconst onPointerUp = (e: PointerEvent) => {\n\t\tconst item = pendingDrag?.item || dragState?.item;\n\t\tif (!item) return;\n\n\t\t// If drag never started, this was just a click - nothing more to do\n\t\tif (pendingDrag && !dragState) {\n\t\t\tcleanupListeners(item, pendingDrag.pointerId);\n\t\t\tpendingDrag = null;\n\t\t\treturn;\n\t\t}\n\n\t\tif (!dragState) return;\n\n\t\tconst { initialRect, colspan, rowspan, lastCell, offsetX, offsetY, dragStartX, dragStartY } = dragState;\n\n\t\t// Calculate drop position with same predictive offset as drag-move\n\t\tconst gridInfo = core.getGridInfo();\n\t\tconst cumulativeDx = e.clientX - dragStartX;\n\t\tconst cumulativeDy = e.clientY - dragStartY;\n\n\t\t// Apply prediction offset to get effective center for cell calculation\n\t\tconst newLeft = e.clientX - offsetX;\n\t\tconst newTop = e.clientY - offsetY;\n\t\tlet effectiveCenterX = newLeft + initialRect.width / 2;\n\t\tlet effectiveCenterY = newTop + initialRect.height / 2;\n\n\t\tif (Math.abs(cumulativeDx) > PREDICTION_THRESHOLD) {\n\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellWidth + gridInfo.gap);\n\t\t\teffectiveCenterX += Math.sign(cumulativeDx) * leadOffset;\n\t\t}\n\t\tif (Math.abs(cumulativeDy) > PREDICTION_THRESHOLD) {\n\t\t\tconst leadOffset = PREDICTION_LEAD * (gridInfo.cellHeight + gridInfo.gap);\n\t\t\teffectiveCenterY += Math.sign(cumulativeDy) * leadOffset;\n\t\t}\n\n\t\tconst rawCell = core.getCellFromPoint(effectiveCenterX, effectiveCenterY);\n\n\t\t// FLIP: Capture current visual position (First)\n\t\tconst firstRect = item.getBoundingClientRect();\n\n\t\t// Transition to committing before algorithm processes drag-end\n\t\tcore.stateMachine.transition({ type: 'COMMIT_INTERACTION' });\n\n\t\t// Emit event BEFORE cleanup so algorithm can set final position\n\t\tif (rawCell) {\n\t\t\tconst maxColumn = Math.max(1, gridInfo.columns.length - colspan + 1);\n\t\t\tconst maxRow = Math.max(1, gridInfo.rows.length - rowspan + 1);\n\n\t\t\tconst cell: GridCell = {\n\t\t\t\tcolumn: Math.max(1, Math.min(maxColumn, rawCell.column)),\n\t\t\t\trow: Math.max(1, Math.min(maxRow, rawCell.row)),\n\t\t\t};\n\n\t\t\tcore.emit('drag-end', { item, cell, colspan, rowspan, source: 'pointer' as const });\n\t\t} else {\n\t\t\tcore.emit('drag-end', { item, cell: lastCell, colspan, rowspan, source: 'pointer' as const });\n\t\t}\n\n\t\tcleanup();\n\n\t\t// Commit complete\n\t\tcore.stateMachine.transition({ type: 'FINISH_COMMIT' });\n\n\t\t// FLIP: Animate from visual position to final grid position\n\t\trequestAnimationFrame(() => {\n\t\t\tanimateFLIPWithTracking(item, firstRect);\n\t\t});\n\t};\n\n\tconst onPointerCancel = () => {\n\t\tconst item = pendingDrag?.item || dragState?.item;\n\t\tif (!item) return;\n\n\t\tif (dragState) {\n\t\t\tcore.emit('drag-cancel', { item, source: 'pointer' as const });\n\t\t\tcore.stateMachine.transition({ type: 'CANCEL_INTERACTION' });\n\t\t}\n\t\tcleanup();\n\t};\n\n\tconst cleanupListeners = (item: HTMLElement, pointerId: number) => {\n\t\titem.releasePointerCapture(pointerId);\n\t\titem.removeEventListener('pointermove', onPointerMove);\n\t\titem.removeEventListener('pointerup', onPointerUp);\n\t\titem.removeEventListener('pointercancel', onPointerCancel);\n\t};\n\n\tconst cleanup = () => {\n\t\tif (dragState) {\n\t\t\tconst { item, pointerId } = dragState;\n\n\t\t\titem.removeAttribute('data-egg-dragging');\n\t\t\tdocument.body.classList.remove('is-dragging');\n\t\t\titem.style.position = '';\n\t\t\titem.style.left = '';\n\t\t\titem.style.top = '';\n\t\t\titem.style.width = '';\n\t\t\titem.style.height = '';\n\t\t\titem.style.zIndex = '';\n\n\t\t\tcleanupListeners(item, pointerId);\n\t\t\tdragState = null;\n\t\t}\n\n\t\tif (pendingDrag) {\n\t\t\tcleanupListeners(pendingDrag.item, pendingDrag.pointerId);\n\t\t\tpendingDrag = null;\n\t\t}\n\t};\n\n\t// Deselect when clicking outside the grid\n\tconst onDocumentPointerDown = (e: PointerEvent) => {\n\t\tif (core.element.contains(e.target as Node)) return;\n\t\tif (dragState) return;\n\t\tcore.deselect();\n\t};\n\n\tcore.element.addEventListener('pointerdown', onPointerDown);\n\tdocument.addEventListener('pointerdown', onDocumentPointerDown);\n\n\treturn () => {\n\t\tcore.element.removeEventListener('pointerdown', onPointerDown);\n\t\tdocument.removeEventListener('pointerdown', onDocumentPointerDown);\n\t\tcleanup();\n\t};\n}\n","import { getItemCell, getItemSize } from '../engine';\nimport type { GridCell, EggCore } from '../types';\nimport { isDragging } from '../state-machine';\n\n/**\n * Attach keyboard navigation and drag to a EggCore instance.\n * @returns Cleanup function\n */\nexport function attachKeyboard(core: EggCore): () => void {\n\tconst { stateMachine } = core;\n\n\t// Track keyboard mode locally (Shift+G toggle)\n\tlet keyboardModeActive = false;\n\n\t// Track target cell locally during keyboard drag\n\tlet keyboardTargetCell: GridCell | null = null;\n\n\t// Track pending viewTransitionName restoration to avoid race conditions\n\tlet pendingVtnRestore: { item: HTMLElement; timeoutId: number } | null = null;\n\n\t/**\n\t * Helper to get current column count from grid\n\t */\n\tconst getColumnCount = (): number => {\n\t\treturn core.getGridInfo().columns.length;\n\t};\n\n\t/**\n\t * Check if currently holding an item (keyboard drag in progress)\n\t */\n\tconst isHoldingItem = (): boolean => {\n\t\tconst state = stateMachine.getState();\n\t\treturn isDragging(state) && state.interaction?.mode === 'keyboard';\n\t};\n\n\t/**\n\t * Get the held item element from state machine\n\t */\n\tconst getHeldItem = (): HTMLElement | null => {\n\t\tconst state = stateMachine.getState();\n\t\tif (isDragging(state) && state.interaction?.mode === 'keyboard') {\n\t\t\treturn state.interaction.element;\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Get direction from key, supporting both arrows and vim-style hjkl.\n\t * Uses both e.key and e.code to handle Alt+hjkl on Mac (Alt produces special chars).\n\t */\n\tconst KEY_DIR: Record<string, 'up' | 'down' | 'left' | 'right'> = {\n\t\tArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right',\n\t\tk: 'up', K: 'up', j: 'down', J: 'down', h: 'left', H: 'left', l: 'right', L: 'right',\n\t};\n\t// Fallback to code for Alt+hjkl on Mac (Alt produces special characters)\n\tconst CODE_DIR: Record<string, 'up' | 'down' | 'left' | 'right'> = {\n\t\tKeyK: 'up', KeyJ: 'down', KeyH: 'left', KeyL: 'right',\n\t};\n\tconst getDirection = (key: string, code: string) => KEY_DIR[key] ?? CODE_DIR[code] ?? null;\n\n\t/**\n\t * Get adjacent cell in a direction\n\t */\n\tconst getAdjacentCell = (\n\t\tcell: GridCell,\n\t\tdirection: 'up' | 'down' | 'left' | 'right',\n\t\tamount = 1,\n\t): GridCell => {\n\t\tswitch (direction) {\n\t\t\tcase 'up':\n\t\t\t\treturn { ...cell, row: Math.max(1, cell.row - amount) };\n\t\t\tcase 'down':\n\t\t\t\treturn { ...cell, row: cell.row + amount };\n\t\t\tcase 'left':\n\t\t\t\treturn { ...cell, column: Math.max(1, cell.column - amount) };\n\t\t\tcase 'right':\n\t\t\t\treturn { ...cell, column: cell.column + amount };\n\t\t}\n\t};\n\n\t/**\n\t * Find the item at or closest to a cell position in a direction\n\t */\n\tconst findItemInDirection = (\n\t\tfromCell: GridCell,\n\t\tdirection: 'up' | 'down' | 'left' | 'right',\n\t\texcludeItem: HTMLElement,\n\t): HTMLElement | null => {\n\t\tconst items = Array.from(\n\t\t\tcore.element.querySelectorAll('[data-egg-item]'),\n\t\t) as HTMLElement[];\n\n\t\tlet bestItem: HTMLElement | null = null;\n\t\tlet bestDistance = Infinity;\n\n\t\tfor (const item of items) {\n\t\t\tif (item === excludeItem) continue;\n\n\t\t\tconst cell = getItemCell(item);\n\t\t\tlet distance: number;\n\t\t\tlet isInDirection: boolean;\n\n\t\t\tswitch (direction) {\n\t\t\t\tcase 'up':\n\t\t\t\t\tisInDirection = cell.row < fromCell.row;\n\t\t\t\t\tdistance = fromCell.row - cell.row + Math.abs(cell.column - fromCell.column) * 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'down':\n\t\t\t\t\tisInDirection = cell.row > fromCell.row;\n\t\t\t\t\tdistance = cell.row - fromCell.row + Math.abs(cell.column - fromCell.column) * 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'left':\n\t\t\t\t\tisInDirection = cell.column < fromCell.column;\n\t\t\t\t\tdistance = fromCell.column - cell.column + Math.abs(cell.row - fromCell.row) * 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'right':\n\t\t\t\t\tisInDirection = cell.column > fromCell.column;\n\t\t\t\t\tdistance = cell.column - fromCell.column + Math.abs(cell.row - fromCell.row) * 0.1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isInDirection && distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestItem = item;\n\t\t\t}\n\t\t}\n\n\t\treturn bestItem;\n\t};\n\n\tconst onKeyDown = (e: KeyboardEvent) => {\n\t\t// Toggle keyboard mode with Shift+G (G for Grid)\n\t\tif (e.key === 'G' && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {\n\t\t\te.preventDefault();\n\t\t\tkeyboardModeActive = !keyboardModeActive;\n\t\t\tif (keyboardModeActive) {\n\t\t\t\tcore.element.setAttribute('data-egg-keyboard-mode', '');\n\t\t\t\t// If no item is selected, select the first one\n\t\t\t\tif (!core.selectedItem) {\n\t\t\t\t\tconst firstItem = core.element.querySelector('[data-egg-item]') as HTMLElement | null;\n\t\t\t\t\tif (firstItem) {\n\t\t\t\t\t\tcore.select(firstItem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcore.element.removeAttribute('data-egg-keyboard-mode');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// All other keyboard shortcuts require keyboard mode, selected item, or focus inside grid\n\t\tconst focused = document.activeElement as HTMLElement | null;\n\t\tconst focusInGrid = focused && core.element.contains(focused);\n\t\tconst hasSelection = core.selectedItem !== null;\n\t\tif (!keyboardModeActive && !focusInGrid && !hasSelection) return;\n\n\t\tconst selectedItem = core.selectedItem;\n\t\tconst direction = getDirection(e.key, e.code);\n\n\t\t// Cancel drag or deselect with Escape\n\t\tif (e.key === 'Escape') {\n\t\t\te.preventDefault();\n\t\t\tconst heldItem = getHeldItem();\n\t\t\tif (heldItem) {\n\t\t\t\theldItem.removeAttribute('data-egg-dragging');\n\t\t\t\tcore.emit('drag-cancel', { item: heldItem, source: 'keyboard' as const });\n\t\t\t\tstateMachine.transition({ type: 'CANCEL_INTERACTION' });\n\t\t\t\tkeyboardTargetCell = null;\n\t\t\t} else if (selectedItem) {\n\t\t\t\tcore.deselect();\n\t\t\t}\n\t\t\t// Turn off keyboard mode if it's active\n\t\t\tif (keyboardModeActive) {\n\t\t\t\tkeyboardModeActive = false;\n\t\t\t}\n\t\t\tcore.element.removeAttribute('data-egg-keyboard-mode');\n\t\t\treturn;\n\t\t}\n\n\t\t// Pick up / drop with Enter or Space\n\t\tif (e.key === 'Enter' || e.key === ' ') {\n\t\t\tif (!selectedItem) return;\n\t\t\te.preventDefault();\n\n\t\t\tconst heldItem = getHeldItem();\n\t\t\tif (heldItem) {\n\t\t\t\t// Drop the held item - use locally tracked target cell\n\t\t\t\tconst targetCell = keyboardTargetCell ?? getItemCell(heldItem);\n\t\t\t\tconst size = getItemSize(heldItem);\n\t\t\t\theldItem.removeAttribute('data-egg-dragging');\n\t\t\t\tcore.emit('drag-end', { item: heldItem, cell: targetCell, colspan: size.colspan, rowspan: size.rowspan, source: 'keyboard' as const });\n\t\t\t\tstateMachine.transition({ type: 'COMMIT_INTERACTION' });\n\t\t\t\tstateMachine.transition({ type: 'FINISH_COMMIT' });\n\t\t\t\tkeyboardTargetCell = null;\n\t\t\t} else {\n\t\t\t\t// Pick up the selected item\n\t\t\t\tconst itemId = selectedItem.id || selectedItem.getAttribute('data-egg-item') || '';\n\t\t\t\tconst size = getItemSize(selectedItem);\n\t\t\t\tconst startCell = getItemCell(selectedItem);\n\n\t\t\t\t// Start interaction via state machine\n\t\t\t\tstateMachine.transition({\n\t\t\t\t\ttype: 'START_INTERACTION',\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\ttype: 'drag',\n\t\t\t\t\t\tmode: 'keyboard',\n\t\t\t\t\t\titemId,\n\t\t\t\t\t\telement: selectedItem,\n\t\t\t\t\t\tcolumnCount: getColumnCount(),\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tkeyboardTargetCell = startCell;\n\t\t\t\tselectedItem.setAttribute('data-egg-dragging', '');\n\t\t\t\tcore.emit('drag-start', { item: selectedItem, cell: startCell, colspan: size.colspan, rowspan: size.rowspan, source: 'keyboard' as const });\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Navigation keys\n\t\tif (direction) {\n\t\t\te.preventDefault();\n\n\t\t\t// Alt+nav: Select adjacent item\n\t\t\tif (e.altKey && !e.ctrlKey && !e.shiftKey && selectedItem) {\n\t\t\t\tconst fromCell = getItemCell(selectedItem);\n\t\t\t\tconst adjacentItem = findItemInDirection(fromCell, direction, selectedItem);\n\t\t\t\tif (adjacentItem) {\n\t\t\t\t\tcore.select(adjacentItem);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Must have a selected item for other nav actions\n\t\t\tif (!selectedItem) return;\n\n\t\t\tconst currentCell = getItemCell(selectedItem);\n\t\t\tconst itemSize = getItemSize(selectedItem);\n\t\t\tconst gridInfo = core.getGridInfo();\n\n\t\t\t// Shift+nav: Resize item (change colspan/rowspan)\n\t\t\tif (e.shiftKey && !e.ctrlKey && !e.altKey) {\n\t\t\t\tlet newColspan = itemSize.colspan;\n\t\t\t\tlet newRowspan = itemSize.rowspan;\n\n\t\t\t\t// Calculate new size based on direction\n\t\t\t\tswitch (direction) {\n\t\t\t\t\tcase 'right':\n\t\t\t\t\t\tnewColspan = Math.min(itemSize.colspan + 1, gridInfo.columns.length - currentCell.column + 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'left':\n\t\t\t\t\t\tnewColspan = Math.max(1, itemSize.colspan - 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'down':\n\t\t\t\t\t\tnewRowspan = itemSize.rowspan + 1; // No max for rows (grid auto-grows)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'up':\n\t\t\t\t\t\tnewRowspan = Math.max(1, itemSize.rowspan - 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Skip if size didn't change (already at limit)\n\t\t\t\tif (newColspan === itemSize.colspan && newRowspan === itemSize.rowspan) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Cancel any pending viewTransitionName restoration\n\t\t\t\tif (pendingVtnRestore) {\n\t\t\t\t\tclearTimeout(pendingVtnRestore.timeoutId);\n\t\t\t\t\tpendingVtnRestore.item.style.removeProperty('view-transition-name');\n\t\t\t\t\tpendingVtnRestore = null;\n\t\t\t\t}\n\n\t\t\t\tconst itemId = selectedItem.id || selectedItem.getAttribute('data-egg-item') || '';\n\n\t\t\t\t// Start resize interaction via state machine\n\t\t\t\tstateMachine.transition({\n\t\t\t\t\ttype: 'START_INTERACTION',\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\ttype: 'resize',\n\t\t\t\t\t\tmode: 'keyboard',\n\t\t\t\t\t\titemId,\n\t\t\t\t\t\telement: selectedItem,\n\t\t\t\t\t\tcolumnCount: getColumnCount(),\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\t// Mark item as resizing so CSS can disable its View Transition animation\n\t\t\t\t// (matches pointer resize behavior - item snaps, others animate)\n\t\t\t\t(selectedItem.style as any).viewTransitionName = 'resizing';\n\n\t\t\t\t// Emit resize events for algorithm and other plugins to handle\n\t\t\t\t// Use 'se' handle for increases, appropriate edge for decreases\n\t\t\t\tconst handle = direction === 'right' || direction === 'down' ? 'se' :\n\t\t\t\t               direction === 'left' ? 'w' : 'n';\n\n\t\t\t\tcore.emit('resize-start', {\n\t\t\t\t\titem: selectedItem,\n\t\t\t\t\tcell: currentCell,\n\t\t\t\t\tcolspan: itemSize.colspan,\n\t\t\t\t\trowspan: itemSize.rowspan,\n\t\t\t\t\thandle,\n\t\t\t\t});\n\n\t\t\t\t// Update item data attributes (algorithm reads these for size)\n\t\t\t\tselectedItem.setAttribute('data-egg-colspan', String(newColspan));\n\t\t\t\tselectedItem.setAttribute('data-egg-rowspan', String(newRowspan));\n\n\t\t\t\t// Don't set inline grid styles - let algorithm handle layout via CSS rules\n\t\t\t\t// This allows View Transitions to animate other items smoothly\n\n\t\t\t\tcore.emit('resize-end', {\n\t\t\t\t\titem: selectedItem,\n\t\t\t\t\tcell: currentCell,\n\t\t\t\t\tcolspan: newColspan,\n\t\t\t\t\trowspan: newRowspan,\n\t\t\t\t});\n\n\t\t\t\t// Complete the interaction via state machine\n\t\t\t\tstateMachine.transition({ type: 'COMMIT_INTERACTION' });\n\t\t\t\tstateMachine.transition({ type: 'FINISH_COMMIT' });\n\n\t\t\t\t// Restore viewTransitionName after View Transition completes (200ms)\n\t\t\t\t// Track the timeout so we can cancel it if another resize starts\n\t\t\t\tconst itemToRestore = selectedItem;\n\t\t\t\tconst timeoutId = window.setTimeout(() => {\n\t\t\t\t\titemToRestore.style.removeProperty('view-transition-name');\n\t\t\t\t\tif (pendingVtnRestore?.item === itemToRestore) {\n\t\t\t\t\t\tpendingVtnRestore = null;\n\t\t\t\t\t}\n\t\t\t\t}, 250);\n\t\t\t\tpendingVtnRestore = { item: itemToRestore, timeoutId };\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Calculate move amount\n\t\t\tlet amount = 1;\n\t\t\tif (e.ctrlKey || e.metaKey) {\n\t\t\t\t// Ctrl+nav: Jump by item size\n\t\t\t\tamount = direction === 'up' || direction === 'down'\n\t\t\t\t\t? itemSize.rowspan\n\t\t\t\t\t: itemSize.colspan;\n\t\t\t}\n\n\t\t\tconst rawCell = getAdjacentCell(currentCell, direction, amount);\n\n\t\t\t// Clamp cell so item fits within grid bounds\n\t\t\tconst maxColumn = Math.max(1, gridInfo.columns.length - itemSize.colspan + 1);\n\t\t\tconst maxRow = Math.max(1, gridInfo.rows.length - itemSize.rowspan + 1);\n\t\t\tconst targetCell = {\n\t\t\t\tcolumn: Math.max(1, Math.min(maxColumn, rawCell.column)),\n\t\t\t\trow: Math.max(1, Math.min(maxRow, rawCell.row)),\n\t\t\t};\n\n\t\t\t// Skip if clamped position is same as current (at edge, can't move further)\n\t\t\tif (targetCell.column === currentCell.column && targetCell.row === currentCell.row) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst heldItem = getHeldItem();\n\t\t\tif (heldItem) {\n\t\t\t\t// Moving a held item - update locally tracked target cell\n\t\t\t\tkeyboardTargetCell = targetCell;\n\t\t\t\tcore.emit('drag-move', { item: heldItem, cell: targetCell, x: 0, y: 0, colspan: itemSize.colspan, rowspan: itemSize.rowspan, source: 'keyboard' as const });\n\t\t\t} else {\n\t\t\t\t// Nudge: Move item directly\n\t\t\t\t// Emit drag-start then drag-end (skip drag-move since we don't need preview)\n\t\t\t\tcore.emit('drag-start', { item: selectedItem, cell: currentCell, colspan: itemSize.colspan, rowspan: itemSize.rowspan, source: 'keyboard' as const });\n\t\t\t\tcore.emit('drag-end', { item: selectedItem, cell: targetCell, colspan: itemSize.colspan, rowspan: itemSize.rowspan, source: 'keyboard' as const });\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t};\n\n\tdocument.addEventListener('keydown', onKeyDown);\n\n\treturn () => {\n\t\tdocument.removeEventListener('keydown', onKeyDown);\n\t\tcore.element.removeAttribute('data-egg-keyboard-mode');\n\t};\n}\n","import { listenEvents } from '../engine';\nimport type {\n\tDragCancelDetail,\n\tDragEndDetail,\n\tDragMoveDetail,\n\tDragStartDetail,\n\tGridCell,\n\tEggCore,\n\tResizeCancelDetail,\n\tResizeEndDetail,\n\tResizeMoveDetail,\n\tResizeStartDetail,\n} from '../types';\n\nexport function attachAccessibility(core: EggCore): () => void {\n\t// Create live region for screen reader announcements\n\tconst liveRegion = document.createElement('div');\n\tliveRegion.setAttribute('aria-live', 'assertive');\n\tliveRegion.setAttribute('aria-atomic', 'true');\n\t// Visually hidden but accessible to screen readers\n\tObject.assign(liveRegion.style, {\n\t\tposition: 'absolute',\n\t\twidth: '1px',\n\t\theight: '1px',\n\t\tpadding: '0',\n\t\tmargin: '-1px',\n\t\toverflow: 'hidden',\n\t\tclip: 'rect(0, 0, 0, 0)',\n\t\twhiteSpace: 'nowrap',\n\t\tborder: '0',\n\t});\n\tcore.element.appendChild(liveRegion);\n\n\tlet lastCell: GridCell | null = null;\n\tlet lastResizeSize: { colspan: number; rowspan: number } | null = null;\n\n\tfunction announce(message: string) {\n\t\t// Clear and re-set to force re-announcement\n\t\tliveRegion.textContent = '';\n\t\trequestAnimationFrame(() => {\n\t\t\tliveRegion.textContent = message;\n\t\t});\n\t}\n\n\tfunction getLabel(item: HTMLElement): string {\n\t\treturn (\n\t\t\titem.getAttribute('data-egg-label') ||\n\t\t\titem.getAttribute('aria-label') ||\n\t\t\titem.id ||\n\t\t\t'Item'\n\t\t);\n\t}\n\n\tfunction formatPosition(cell: GridCell): string {\n\t\treturn `row ${cell.row}, column ${cell.column}`;\n\t}\n\n\tfunction resolveTemplate(\n\t\titem: HTMLElement,\n\t\tevent: string,\n\t\tvars: Record<string, string>,\n\t\tfallback: string,\n\t): string {\n\t\tconst template =\n\t\t\titem.getAttribute(`data-egg-announce-${event}`) ||\n\t\t\tcore.element.getAttribute(`data-egg-announce-${event}`);\n\t\tif (!template) return fallback;\n\t\treturn template.replace(/\\{(\\w+)\\}/g, (_, key) => vars[key] ?? '');\n\t}\n\n\tfunction getAnnouncement(\n\t\titem: HTMLElement,\n\t\tevent: 'grab' | 'move' | 'drop' | 'cancel',\n\t\tcell?: GridCell,\n\t): string {\n\t\tconst label = getLabel(item);\n\t\tconst pos = cell ? formatPosition(cell) : '';\n\t\tconst vars = { label, row: String(cell?.row ?? ''), column: String(cell?.column ?? '') };\n\n\t\tconst defaults: Record<string, string> = {\n\t\t\tgrab: `${label} grabbed. Position ${pos}. Use arrow keys to move, Enter to drop, Escape to cancel.`,\n\t\t\tmove: `Moved to ${pos}.`,\n\t\t\tdrop: `${label} dropped at ${pos}.`,\n\t\t\tcancel: `${label} drag cancelled.`,\n\t\t};\n\t\treturn resolveTemplate(item, event, vars, defaults[event]);\n\t}\n\n\tfunction getResizeAnnouncement(\n\t\titem: HTMLElement,\n\t\tevent: 'resize-start' | 'resize-move' | 'resize-end' | 'resize-cancel',\n\t\topts?: { cell?: GridCell; colspan?: number; rowspan?: number },\n\t): string {\n\t\tconst label = getLabel(item);\n\t\tconst size = opts?.colspan != null && opts?.rowspan != null\n\t\t\t? `${opts.colspan} columns by ${opts.rowspan} rows`\n\t\t\t: '';\n\t\tconst pos = opts?.cell ? formatPosition(opts.cell) : '';\n\t\tconst vars = {\n\t\t\tlabel,\n\t\t\tcolspan: String(opts?.colspan ?? ''),\n\t\t\trowspan: String(opts?.rowspan ?? ''),\n\t\t\trow: String(opts?.cell?.row ?? ''),\n\t\t\tcolumn: String(opts?.cell?.column ?? ''),\n\t\t};\n\n\t\tconst defaults: Record<string, string> = {\n\t\t\t'resize-start': `${label} resize started. Size ${size}. Use pointer to resize, Escape to cancel.`,\n\t\t\t'resize-move': `Resized to ${size}.`,\n\t\t\t'resize-end': `${label} resized to ${size} at ${pos}.`,\n\t\t\t'resize-cancel': `${label} resize cancelled.`,\n\t\t};\n\t\treturn resolveTemplate(item, event, vars, defaults[event]);\n\t}\n\n\tconst onDragStart = (e: CustomEvent<DragStartDetail>) => {\n\t\tlastCell = e.detail.cell;\n\t\tannounce(getAnnouncement(e.detail.item, 'grab', e.detail.cell));\n\t};\n\n\tconst onDragMove = (e: CustomEvent<DragMoveDetail>) => {\n\t\t// Only announce if cell actually changed\n\t\tconst { cell } = e.detail;\n\t\tif (\n\t\t\tlastCell &&\n\t\t\tcell.row === lastCell.row &&\n\t\t\tcell.column === lastCell.column\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\tlastCell = cell;\n\t\tannounce(getAnnouncement(e.detail.item, 'move', cell));\n\t};\n\n\tconst onDragEnd = (e: CustomEvent<DragEndDetail>) => {\n\t\tlastCell = null;\n\t\tannounce(getAnnouncement(e.detail.item, 'drop', e.detail.cell));\n\t};\n\n\tconst onDragCancel = (e: CustomEvent<DragCancelDetail>) => {\n\t\tlastCell = null;\n\t\tannounce(getAnnouncement(e.detail.item, 'cancel'));\n\t};\n\n\tconst onResizeStart = (e: CustomEvent<ResizeStartDetail>) => {\n\t\tconst { item, colspan, rowspan } = e.detail;\n\t\tlastResizeSize = { colspan, rowspan };\n\t\tannounce(getResizeAnnouncement(item, 'resize-start', { colspan, rowspan }));\n\t};\n\n\tconst onResizeMove = (e: CustomEvent<ResizeMoveDetail>) => {\n\t\tconst { item, cell, colspan, rowspan } = e.detail;\n\t\t// Only announce if size actually changed\n\t\tif (\n\t\t\tlastResizeSize &&\n\t\t\tcolspan === lastResizeSize.colspan &&\n\t\t\trowspan === lastResizeSize.rowspan\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\tlastResizeSize = { colspan, rowspan };\n\t\tannounce(getResizeAnnouncement(item, 'resize-move', { cell, colspan, rowspan }));\n\t};\n\n\tconst onResizeEnd = (e: CustomEvent<ResizeEndDetail>) => {\n\t\tconst { item, cell, colspan, rowspan } = e.detail;\n\t\tlastResizeSize = null;\n\t\tannounce(getResizeAnnouncement(item, 'resize-end', { cell, colspan, rowspan }));\n\t};\n\n\tconst onResizeCancel = (e: CustomEvent<ResizeCancelDetail>) => {\n\t\tlastResizeSize = null;\n\t\tannounce(getResizeAnnouncement(e.detail.item, 'resize-cancel'));\n\t};\n\n\tconst unlisten = listenEvents(core.element, {\n\t\t'egg-drag-start': onDragStart as EventListener,\n\t\t'egg-drag-move': onDragMove as EventListener,\n\t\t'egg-drag-end': onDragEnd as EventListener,\n\t\t'egg-drag-cancel': onDragCancel as EventListener,\n\t\t'egg-resize-start': onResizeStart as EventListener,\n\t\t'egg-resize-move': onResizeMove as EventListener,\n\t\t'egg-resize-end': onResizeEnd as EventListener,\n\t\t'egg-resize-cancel': onResizeCancel as EventListener,\n\t});\n\n\treturn () => {\n\t\tunlisten();\n\t\tliveRegion.remove();\n\t};\n}\n","/**\n * Resize plugin for EG Grid\n *\n * Pure input plugin — detects resize gestures on grid item corners/edges\n * and emits resize-start/move/end/cancel events. Does NOT persist layout.\n * A behavior plugin (e.g., Algorithm) listens for resize-end and handles persistence.\n *\n * Usage:\n *   import { attachResize } from 'eg-grid/resize';\n *\n *   const detach = attachResize(gridElement, {\n *     core,                 // EggCore instance (required)\n *     handles: 'corners',   // 'corners' | 'edges' | 'all'\n *     handleSize: 12,\n *     minSize: { colspan: 1, rowspan: 1 },\n *     maxSize: { colspan: 6, rowspan: 6 },\n *   });\n */\n\nimport { getItemSize } from '../engine';\nimport type {\n\tGridCell,\n\tEggCore,\n\tResizeCancelDetail,\n\tResizeEndDetail,\n\tResizeHandle,\n\tResizeMoveDetail,\n\tResizeStartDetail,\n} from '../types';\n\n\nexport interface ResizeOptions {\n\t/** EggCore instance (required) */\n\tcore: EggCore;\n\t/** Which handles to show: 'corners' | 'edges' | 'all' (default: 'corners') */\n\thandles?: 'corners' | 'edges' | 'all';\n\t/** Size of the hit zone for handles in pixels (default: 12) */\n\thandleSize?: number;\n\t/** Minimum size in grid cells (default: { colspan: 1, rowspan: 1 }) */\n\tminSize?: { colspan: number; rowspan: number };\n\t/** Maximum size in grid cells (default: { colspan: 6, rowspan: 6 }) */\n\tmaxSize?: { colspan: number; rowspan: number };\n\t/** Show size label during resize (default: true) */\n\tshowSizeLabel?: boolean;\n}\n\ninterface ActiveResize {\n\titem: HTMLElement;\n\tpointerId: number;\n\thandle: ResizeHandle;\n\t/** Original cell position at start of resize - never changes */\n\tstartCell: GridCell;\n\t/** Original size at start of resize - never changes */\n\toriginalSize: { colspan: number; rowspan: number };\n\t/** Current position (may differ from startCell for NW/NE/SW handles) */\n\tcurrentCell: GridCell;\n\t/** Current size during resize */\n\tcurrentSize: { colspan: number; rowspan: number };\n\tsizeLabel: HTMLElement | null;\n\t/** Initial bounding rect for smooth resize */\n\tinitialRect: DOMRect;\n\t/** Pointer position at start */\n\tstartPointerX: number;\n\tstartPointerY: number;\n}\n\n\n/**\n * Detect which resize handle (if any) is under the pointer\n */\nfunction detectHandle(\n\te: PointerEvent,\n\titem: HTMLElement,\n\tsize: number,\n\tmode: 'corners' | 'edges' | 'all',\n): ResizeHandle | null {\n\tconst rect = item.getBoundingClientRect();\n\tconst x = e.clientX - rect.left;\n\tconst y = e.clientY - rect.top;\n\n\tconst nearLeft = x < size;\n\tconst nearRight = x > rect.width - size;\n\tconst nearTop = y < size;\n\tconst nearBottom = y > rect.height - size;\n\n\t// Corners\n\tif (mode === 'corners' || mode === 'all') {\n\t\tif (nearTop && nearLeft) return 'nw';\n\t\tif (nearTop && nearRight) return 'ne';\n\t\tif (nearBottom && nearLeft) return 'sw';\n\t\tif (nearBottom && nearRight) return 'se';\n\t}\n\n\t// Edges (only if not at corners)\n\tif (mode === 'edges' || mode === 'all') {\n\t\tif (nearTop) return 'n';\n\t\tif (nearBottom) return 's';\n\t\tif (nearLeft) return 'w';\n\t\tif (nearRight) return 'e';\n\t}\n\n\treturn null;\n}\n\nconst CURSOR: Record<string, string> = {\n\tnw: 'nwse-resize', se: 'nwse-resize',\n\tne: 'nesw-resize', sw: 'nesw-resize',\n\tn: 'ns-resize', s: 'ns-resize',\n\te: 'ew-resize', w: 'ew-resize',\n};\n\n/**\n * Create a size label element\n */\nfunction createSizeLabel(): HTMLElement {\n\tconst label = document.createElement('div');\n\tlabel.className = 'egg-resize-label';\n\tlabel.style.cssText = `\n\t\tposition: absolute;\n\t\ttop: 50%;\n\t\tleft: 50%;\n\t\ttransform: translate(-50%, -50%);\n\t\tbackground: rgba(0, 0, 0, 0.8);\n\t\tcolor: white;\n\t\tpadding: 4px 8px;\n\t\tborder-radius: 4px;\n\t\tfont-size: 14px;\n\t\tfont-weight: 600;\n\t\tfont-family: system-ui, sans-serif;\n\t\tpointer-events: none;\n\t\tz-index: 1000;\n\t\twhite-space: nowrap;\n\t`;\n\treturn label;\n}\n\n/**\n * Attach resize functionality to a grid element.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach resize\n */\nexport function attachResize(\n\tgridElement: HTMLElement,\n\toptions: ResizeOptions,\n): { destroy(): void } {\n\tconst {\n\t\tcore,\n\t\thandles = 'corners',\n\t\thandleSize = 12,\n\t\tminSize = { colspan: 1, rowspan: 1 },\n\t\tmaxSize = { colspan: 6, rowspan: 6 },\n\t\tshowSizeLabel = true,\n\t} = options;\n\n\tlet activeResize: ActiveResize | null = null;\n\tlet hoveredItem: HTMLElement | null = null;\n\tlet hoveredHandle: ResizeHandle | null = null;\n\n\tfunction emit<T>(event: string, detail: T): void {\n\t\tgridElement.dispatchEvent(\n\t\t\tnew CustomEvent(`egg-${event}`, {\n\t\t\t\tbubbles: true,\n\t\t\t\tdetail,\n\t\t\t}),\n\t\t);\n\t}\n\n\tfunction startResize(item: HTMLElement, handle: ResizeHandle, e: PointerEvent) {\n\t\tconst { colspan, rowspan } = getItemSize(item);\n\n\t\tconst style = getComputedStyle(item);\n\t\tconst column = parseInt(style.gridColumnStart, 10) || 1;\n\t\tconst row = parseInt(style.gridRowStart, 10) || 1;\n\n\t\tconst originalSize = { colspan, rowspan };\n\t\tconst startCell = { column, row };\n\t\tconst initialRect = item.getBoundingClientRect();\n\n\t\t// Create size label if enabled\n\t\tlet sizeLabel: HTMLElement | null = null;\n\t\tif (showSizeLabel) {\n\t\t\tsizeLabel = createSizeLabel();\n\t\t\tsizeLabel.textContent = `${colspan}×${rowspan}`;\n\t\t\titem.appendChild(sizeLabel);\n\t\t}\n\n\t\tactiveResize = {\n\t\t\titem,\n\t\t\tpointerId: e.pointerId,\n\t\t\thandle,\n\t\t\tstartCell,\n\t\t\toriginalSize,\n\t\t\tcurrentCell: { ...startCell },\n\t\t\tcurrentSize: { ...originalSize },\n\t\t\tsizeLabel,\n\t\t\tinitialRect,\n\t\t\tstartPointerX: e.clientX,\n\t\t\tstartPointerY: e.clientY,\n\t\t};\n\n\t\titem.setAttribute('data-egg-resizing', '');\n\t\titem.setAttribute('data-egg-handle-active', handle);\n\t\titem.removeAttribute('data-egg-handle-hover'); // Clear hover state\n\t\titem.setPointerCapture(e.pointerId);\n\n\t\t// Add event listeners to item (pointer capture sends events to this element)\n\t\titem.addEventListener('pointermove', onItemPointerMove);\n\t\titem.addEventListener('pointerup', onItemPointerUp);\n\t\titem.addEventListener('pointercancel', onItemPointerCancel);\n\n\t\t// Transition state machine to interacting\n\t\tconst itemId = item.id || item.getAttribute('data-egg-item') || '';\n\t\tcore.stateMachine.transition({\n\t\t\ttype: 'START_INTERACTION',\n\t\t\tcontext: { type: 'resize', mode: 'pointer', itemId, element: item, columnCount: core.getGridInfo().columns.length },\n\t\t});\n\n\t\t// Emit resize-start BEFORE changing grid styles so originalPositions captures correct layout\n\t\temit<ResizeStartDetail>('resize-start', {\n\t\t\titem,\n\t\t\tcell: startCell,\n\t\t\tcolspan: originalSize.colspan,\n\t\t\trowspan: originalSize.rowspan,\n\t\t\thandle,\n\t\t\tsource: 'pointer',\n\t\t});\n\n\t\t// Switch to fixed positioning - item follows cursor in viewport coordinates\n\t\t// CSS Grid ignores fixed positioned children, allowing the grid to reflow\n\t\titem.style.position = 'fixed';\n\t\titem.style.left = `${initialRect.left}px`;\n\t\titem.style.top = `${initialRect.top}px`;\n\t\titem.style.width = `${initialRect.width}px`;\n\t\titem.style.height = `${initialRect.height}px`;\n\t\titem.style.zIndex = '100';\n\t\t// Exclude from view transitions during resize\n\t\titem.style.viewTransitionName = 'resizing';\n\t}\n\n\tfunction updateResize(e: PointerEvent) {\n\t\tif (!activeResize) return;\n\n\t\tconst { item, handle, startCell, originalSize, currentCell, currentSize, sizeLabel, initialRect, startPointerX, startPointerY } =\n\t\t\tactiveResize;\n\n\t\tconst gridInfo = core.getGridInfo();\n\n\t\t// Calculate pointer delta\n\t\tconst deltaX = e.clientX - startPointerX;\n\t\tconst deltaY = e.clientY - startPointerY;\n\n\t\t// Calculate new visual dimensions based on handle\n\t\tlet newWidth = initialRect.width;\n\t\tlet newHeight = initialRect.height;\n\t\tlet newLeft = initialRect.left;\n\t\tlet newTop = initialRect.top;\n\n\t\t// Minimum visual size (1 cell)\n\t\tconst minWidth = gridInfo.cellWidth;\n\t\tconst minHeight = gridInfo.cellHeight;\n\t\t// Maximum visual size (clamped by maxSize config)\n\t\tconst maxWidthByConfig = maxSize.colspan * gridInfo.cellWidth + (maxSize.colspan - 1) * gridInfo.gap;\n\t\tconst maxHeightByConfig = maxSize.rowspan * gridInfo.cellHeight + (maxSize.rowspan - 1) * gridInfo.gap;\n\t\t// Maximum visual size (clamped by grid bounds)\n\t\tconst maxWidthByGrid = gridInfo.rect.right - initialRect.left;\n\t\tconst maxHeightByGrid = gridInfo.rect.bottom - initialRect.top;\n\t\tconst maxWidth = Math.min(maxWidthByConfig, maxWidthByGrid);\n\t\tconst maxHeight = Math.min(maxHeightByConfig, maxHeightByGrid);\n\n\t\t// Apply delta based on handle direction\n\t\tif (handle === 'e' || handle === 'se' || handle === 'ne') {\n\t\t\tnewWidth = Math.max(minWidth, Math.min(maxWidth, initialRect.width + deltaX));\n\t\t}\n\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t\t// For left edge, clamp to grid left\n\t\t\tconst maxLeftShift = initialRect.left - gridInfo.rect.left;\n\t\t\tconst maxWidthFromLeft = Math.min(maxWidthByConfig, initialRect.width + maxLeftShift);\n\t\t\tconst widthChange = Math.max(-initialRect.width + minWidth, Math.min(maxWidthFromLeft - initialRect.width, -deltaX));\n\t\t\tnewWidth = initialRect.width + widthChange;\n\t\t\tnewLeft = initialRect.left - widthChange;\n\t\t}\n\t\tif (handle === 's' || handle === 'se' || handle === 'sw') {\n\t\t\tnewHeight = Math.max(minHeight, Math.min(maxHeight, initialRect.height + deltaY));\n\t\t}\n\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t\t// For top edge, clamp to grid top\n\t\t\tconst maxTopShift = initialRect.top - gridInfo.rect.top;\n\t\t\tconst maxHeightFromTop = Math.min(maxHeightByConfig, initialRect.height + maxTopShift);\n\t\t\tconst heightChange = Math.max(-initialRect.height + minHeight, Math.min(maxHeightFromTop - initialRect.height, -deltaY));\n\t\t\tnewHeight = initialRect.height + heightChange;\n\t\t\tnewTop = initialRect.top - heightChange;\n\t\t}\n\n\t\t// Apply smooth visual size (fixed positioning uses viewport coordinates)\n\t\titem.style.left = `${newLeft}px`;\n\t\titem.style.top = `${newTop}px`;\n\t\titem.style.width = `${newWidth}px`;\n\t\titem.style.height = `${newHeight}px`;\n\n\t\t// Calculate projected final grid size (what it will snap to)\n\t\tconst cellPlusGap = gridInfo.cellWidth + gridInfo.gap;\n\t\tconst rowPlusGap = gridInfo.cellHeight + gridInfo.gap;\n\n\t\t// Calculate raw ratios\n\t\tconst rawColspanRatio = (newWidth + gridInfo.gap) / cellPlusGap;\n\t\tconst rawRowspanRatio = (newHeight + gridInfo.gap) / rowPlusGap;\n\n\t\t// Snap when 30% into the next cell (works symmetrically for grow and shrink)\n\t\tconst RESIZE_SNAP = 0.3;\n\t\tlet projectedColspan = Math.floor(rawColspanRatio + (1 - RESIZE_SNAP));\n\t\tlet projectedRowspan = Math.floor(rawRowspanRatio + (1 - RESIZE_SNAP));\n\n\t\t// Apply min/max constraints\n\t\tprojectedColspan = Math.max(minSize.colspan, Math.min(maxSize.colspan, projectedColspan));\n\t\tprojectedRowspan = Math.max(minSize.rowspan, Math.min(maxSize.rowspan, projectedRowspan));\n\n\t\t// Calculate cell position: anchor corner stays fixed, opposite edge moves\n\t\tlet projectedColumn = startCell.column;\n\t\tlet projectedRow = startCell.row;\n\n\t\t// For handles that move the left edge, calculate column from the right anchor\n\t\tif (handle === 'w' || handle === 'sw' || handle === 'nw') {\n\t\t\tconst rightEdge = startCell.column + originalSize.colspan - 1;\n\t\t\tprojectedColumn = rightEdge - projectedColspan + 1;\n\t\t}\n\n\t\t// For handles that move the top edge, calculate row from the bottom anchor\n\t\tif (handle === 'n' || handle === 'ne' || handle === 'nw') {\n\t\t\tconst bottomEdge = startCell.row + originalSize.rowspan - 1;\n\t\t\tprojectedRow = bottomEdge - projectedRowspan + 1;\n\t\t}\n\n\t\t// Update tracking\n\t\tactiveResize.currentSize = { colspan: projectedColspan, rowspan: projectedRowspan };\n\t\tactiveResize.currentCell = { column: projectedColumn, row: projectedRow };\n\n\t\t// Update size label with projected final size\n\t\tif (sizeLabel) {\n\t\t\tsizeLabel.textContent = `${projectedColspan}×${projectedRowspan}`;\n\t\t}\n\n\t\t// Calculate anchor cell (the corner that stays fixed during resize)\n\t\tlet anchorCell: GridCell;\n\t\tif (handle === 'se' || handle === 's' || handle === 'e') {\n\t\t\t// NW corner is anchor\n\t\t\tanchorCell = { column: startCell.column, row: startCell.row };\n\t\t} else if (handle === 'nw' || handle === 'n' || handle === 'w') {\n\t\t\t// SE corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column + originalSize.colspan - 1,\n\t\t\t\trow: startCell.row + originalSize.rowspan - 1,\n\t\t\t};\n\t\t} else if (handle === 'ne') {\n\t\t\t// SW corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column,\n\t\t\t\trow: startCell.row + originalSize.rowspan - 1,\n\t\t\t};\n\t\t} else {\n\t\t\t// SW handle: NE corner is anchor\n\t\t\tanchorCell = {\n\t\t\t\tcolumn: startCell.column + originalSize.colspan - 1,\n\t\t\t\trow: startCell.row,\n\t\t\t};\n\t\t}\n\n\t\temit<ResizeMoveDetail>('resize-move', {\n\t\t\titem,\n\t\t\tcell: { column: projectedColumn, row: projectedRow },\n\t\t\tanchorCell,\n\t\t\tstartCell,\n\t\t\tcolspan: projectedColspan,\n\t\t\trowspan: projectedRowspan,\n\t\t\thandle,\n\t\t\tsource: 'pointer',\n\t\t});\n\t}\n\n\tfunction cleanupResizeListeners(item: HTMLElement, pointerId: number) {\n\t\titem.releasePointerCapture(pointerId);\n\t\titem.removeEventListener('pointermove', onItemPointerMove);\n\t\titem.removeEventListener('pointerup', onItemPointerUp);\n\t\titem.removeEventListener('pointercancel', onItemPointerCancel);\n\t}\n\n\tfunction resetItem(item: HTMLElement, pointerId: number, sizeLabel: HTMLElement | null) {\n\t\tcleanupResizeListeners(item, pointerId);\n\t\tif (sizeLabel) sizeLabel.remove();\n\t\titem.style.position = '';\n\t\titem.style.left = '';\n\t\titem.style.top = '';\n\t\titem.style.width = '';\n\t\titem.style.height = '';\n\t\titem.style.zIndex = '';\n\t\tconst itemId = item.style.getPropertyValue('--item-id') || item.dataset.eggItem || item.id || item.dataset.id;\n\t\titem.style.viewTransitionName = itemId || '';\n\t\titem.removeAttribute('data-egg-resizing');\n\t\titem.removeAttribute('data-egg-handle-active');\n\t}\n\n\tfunction finishResize() {\n\t\tif (!activeResize) return;\n\t\tconst { item, pointerId, currentSize, currentCell, sizeLabel } = activeResize;\n\t\titem.setAttribute('data-egg-colspan', String(currentSize.colspan));\n\t\titem.setAttribute('data-egg-rowspan', String(currentSize.rowspan));\n\t\tcore.stateMachine.transition({ type: 'COMMIT_INTERACTION' });\n\t\temit<ResizeEndDetail>('resize-end', {\n\t\t\titem, cell: currentCell,\n\t\t\tcolspan: currentSize.colspan, rowspan: currentSize.rowspan,\n\t\t\tsource: 'pointer',\n\t\t});\n\t\tresetItem(item, pointerId, sizeLabel);\n\t\tactiveResize = null;\n\t\tcore.stateMachine.transition({ type: 'FINISH_COMMIT' });\n\t}\n\n\tfunction cancelResize() {\n\t\tif (!activeResize) return;\n\t\tconst { item, pointerId, sizeLabel } = activeResize;\n\t\temit<ResizeCancelDetail>('resize-cancel', { item, source: 'pointer' });\n\t\tcore.stateMachine.transition({ type: 'CANCEL_INTERACTION' });\n\t\tresetItem(item, pointerId, sizeLabel);\n\t\tactiveResize = null;\n\t}\n\n\t// --- Event handlers ---\n\n\t// Use capture phase to intercept before pointer plugin\n\tconst onPointerDown = (e: PointerEvent) => {\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-egg-item]',\n\t\t) as HTMLElement | null;\n\t\tif (!item) return;\n\n\t\tconst handle = detectHandle(e, item, handleSize, handles);\n\t\tif (!handle) return; // Not on handle - let pointer plugin handle drag\n\n\t\t// Stop event from reaching pointer plugin\n\t\te.stopPropagation();\n\t\te.preventDefault();\n\n\t\t// Select the item (resize captures before pointer plugin, so pointer's select never fires)\n\t\tcore.select(item);\n\n\t\tstartResize(item, handle, e);\n\t};\n\n\t// Item-specific handlers (added during resize, removed on finish/cancel)\n\tconst onItemPointerMove = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tupdateResize(e);\n\t\t}\n\t};\n\n\tconst onItemPointerUp = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tfinishResize();\n\t\t}\n\t};\n\n\tconst onItemPointerCancel = (e: PointerEvent) => {\n\t\tif (activeResize && e.pointerId === activeResize.pointerId) {\n\t\t\tcancelResize();\n\t\t}\n\t};\n\n\t// Grid-level hover handler for cursor changes and handle hover state\n\tconst onPointerMove = (e: PointerEvent) => {\n\t\t// Skip hover handling during active resize\n\t\tif (activeResize) return;\n\n\t\t// Handle hover cursor changes\n\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t'[data-egg-item]',\n\t\t) as HTMLElement | null;\n\n\t\tif (item) {\n\t\t\tconst handle = detectHandle(e, item, handleSize, handles);\n\n\t\t\tif (handle !== hoveredHandle || item !== hoveredItem) {\n\t\t\t\t// Clear previous item's hover state\n\t\t\t\tif (hoveredItem && hoveredItem !== item) {\n\t\t\t\t\thoveredItem.style.cursor = '';\n\t\t\t\t\thoveredItem.removeAttribute('data-egg-handle-hover');\n\t\t\t\t}\n\n\t\t\t\t// Clear hover attribute if handle changed on same item\n\t\t\t\tif (hoveredItem === item && hoveredHandle && !handle) {\n\t\t\t\t\titem.removeAttribute('data-egg-handle-hover');\n\t\t\t\t}\n\n\t\t\t\thoveredItem = item;\n\t\t\t\thoveredHandle = handle;\n\n\t\t\t\t// Set cursor and hover attribute based on handle\n\t\t\t\titem.style.cursor = (handle ? CURSOR[handle] : '') || '';\n\t\t\t\tif (handle) {\n\t\t\t\t\titem.setAttribute('data-egg-handle-hover', handle);\n\t\t\t\t} else {\n\t\t\t\t\titem.removeAttribute('data-egg-handle-hover');\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (hoveredItem) {\n\t\t\thoveredItem.style.cursor = '';\n\t\t\thoveredItem.removeAttribute('data-egg-handle-hover');\n\t\t\thoveredItem = null;\n\t\t\thoveredHandle = null;\n\t\t}\n\t};\n\n\tconst onKeyDown = (e: KeyboardEvent) => {\n\t\tif (e.key === 'Escape' && activeResize) {\n\t\t\tcancelResize();\n\t\t}\n\t};\n\n\t// Register event listeners\n\tgridElement.addEventListener('pointerdown', onPointerDown, { capture: true });\n\tgridElement.addEventListener('pointermove', onPointerMove);\n\tdocument.addEventListener('keydown', onKeyDown);\n\n\tfunction destroy() {\n\t\tgridElement.removeEventListener('pointerdown', onPointerDown, {\n\t\t\tcapture: true,\n\t\t});\n\t\tgridElement.removeEventListener('pointermove', onPointerMove);\n\t\tdocument.removeEventListener('keydown', onKeyDown);\n\n\t\tif (activeResize) {\n\t\t\tcancelResize();\n\t\t}\n\t}\n\n\treturn { destroy };\n}\n\nexport type { ResizeHandle };\n","/**\n * Camera plugin for EG Grid\n *\n * Handles viewport scrolling to keep the active item visible:\n * - Auto-scroll when dragging near viewport edges\n * - Scroll into view when selecting items via keyboard\n *\n * The \"active item\" is: the dragged item during drag, or the selected item otherwise.\n */\n\nimport { listenEvents } from '../engine';\nimport type {\n\tDragStartDetail,\n\tDragMoveDetail,\n\tDragEndDetail,\n\tDragCancelDetail,\n\tSelectDetail,\n\tEggCore,\n} from '../types';\n\nexport type CameraMode = 'contain' | 'center' | 'off';\n\nexport interface CameraOptions {\n\t/**\n\t * Scroll behavior mode:\n\t * - 'contain': Only scroll when item would leave viewport (default)\n\t * - 'center': Keep active item centered (can feel jarring)\n\t * - 'off': Disable camera scrolling\n\t */\n\tmode?: CameraMode;\n\n\t/**\n\t * The scrollable container. Defaults to the grid's scroll parent.\n\t * Pass `window` to scroll the document.\n\t */\n\tscrollContainer?: HTMLElement | Window;\n\n\t/**\n\t * Size of edge zones that trigger auto-scroll during drag (in pixels).\n\t * @default 60\n\t */\n\tedgeSize?: number;\n\n\t/**\n\t * Maximum scroll speed in pixels per frame.\n\t * @default 15\n\t */\n\tscrollSpeed?: number;\n\n\t/**\n\t * Scroll behavior for selection changes.\n\t * @default 'smooth'\n\t */\n\tscrollBehavior?: ScrollBehavior;\n\n\t/**\n\t * Margin around item when scrolling into view (in pixels).\n\t * @default 20\n\t */\n\tscrollMargin?: number;\n\n\t/**\n\t * Whether to scroll on selection changes (keyboard nav).\n\t * @default true\n\t */\n\tscrollOnSelect?: boolean;\n\n\t/**\n\t * Whether to auto-scroll during drag.\n\t * @default true\n\t */\n\tautoScrollOnDrag?: boolean;\n\n\t/**\n\t * Time in ms after scrolling stops before considered \"settled\".\n\t * Other plugins can check isScrolling() to defer updates.\n\t * @default 150\n\t */\n\tsettleDelay?: number;\n\n\t/**\n\t * EG Grid core instance for provider registration.\n\t * If provided, registers a 'camera' provider.\n\t */\n\tcore?: EggCore;\n}\n\n/**\n * Camera state exposed via provider registry.\n */\nexport interface CameraState {\n\t/** Whether the camera is actively auto-scrolling */\n\tisScrolling: boolean;\n\t/** Current camera mode */\n\tmode: CameraMode;\n}\n\nexport interface CameraInstance {\n\t/** Change the camera mode */\n\tsetMode(mode: CameraMode): void;\n\t/** Get current mode */\n\tgetMode(): CameraMode;\n\t/** Manually scroll an item into view */\n\tscrollTo(item: HTMLElement, behavior?: ScrollBehavior): void;\n\t/** Stop any active auto-scrolling */\n\tstop(): void;\n\t/** Clean up and remove event listeners */\n\tdestroy(): void;\n}\n\n/**\n * Find the nearest scrollable ancestor of an element.\n */\nfunction findScrollParent(element: HTMLElement): HTMLElement | Window {\n\tlet parent = element.parentElement;\n\n\twhile (parent) {\n\t\tconst style = getComputedStyle(parent);\n\t\tconst overflowY = style.overflowY;\n\t\tconst overflowX = style.overflowX;\n\n\t\tif (\n\t\t\toverflowY === 'auto' ||\n\t\t\toverflowY === 'scroll' ||\n\t\t\toverflowX === 'auto' ||\n\t\t\toverflowX === 'scroll'\n\t\t) {\n\t\t\treturn parent;\n\t\t}\n\n\t\tparent = parent.parentElement;\n\t}\n\n\treturn window;\n}\n\n/**\n * Get viewport rect for a scroll container.\n */\nfunction getViewportRect(\n\tcontainer: HTMLElement | Window\n): { top: number; left: number; width: number; height: number } {\n\tif (container === window) {\n\t\treturn {\n\t\t\ttop: 0,\n\t\t\tleft: 0,\n\t\t\twidth: window.innerWidth,\n\t\t\theight: window.innerHeight,\n\t\t};\n\t}\n\tconst rect = (container as HTMLElement).getBoundingClientRect();\n\treturn {\n\t\ttop: rect.top,\n\t\tleft: rect.left,\n\t\twidth: rect.width,\n\t\theight: rect.height,\n\t};\n}\n\n/**\n * Attach camera behavior to a EG Grid grid element.\n */\nexport function attachCamera(\n\tgridElement: HTMLElement,\n\toptions: CameraOptions = {}\n): CameraInstance {\n\tconst {\n\t\tmode: initialMode = 'contain',\n\t\tscrollContainer: customContainer,\n\t\tedgeSize = 60,\n\t\tscrollSpeed = 15,\n\t\tscrollBehavior = 'smooth',\n\t\tscrollMargin = 20,\n\t\tscrollOnSelect = true,\n\t\tautoScrollOnDrag = true,\n\t\tsettleDelay = 150,\n\t\tcore,\n\t} = options;\n\n\tlet mode = initialMode;\n\tlet scrollContainer = customContainer ?? findScrollParent(gridElement);\n\tlet animationFrameId: number | null = null;\n\tlet isDragging = false;\n\tlet dragSource: 'pointer' | 'keyboard' | null = null;\n\tlet lastPointerX = 0;\n\tlet lastPointerY = 0;\n\tlet isScrolling = false;\n\tlet settleTimeoutId: ReturnType<typeof setTimeout> | null = null;\n\n\t// Expose scrolling state on core\n\tif (core) {\n\t\tcore.cameraScrolling = false;\n\t}\n\n\t/**\n\t * Mark scrolling as active, with settle timeout.\n\t */\n\tfunction setScrolling(active: boolean): void {\n\t\tif (active) {\n\t\t\tisScrolling = true;\n\t\t\tif (core) core.cameraScrolling = true;\n\t\t\tif (settleTimeoutId) {\n\t\t\t\tclearTimeout(settleTimeoutId);\n\t\t\t\tsettleTimeoutId = null;\n\t\t\t}\n\t\t} else {\n\t\t\t// Start settle timer\n\t\t\tif (settleTimeoutId) clearTimeout(settleTimeoutId);\n\t\t\tsettleTimeoutId = setTimeout(() => {\n\t\t\t\tisScrolling = false;\n\t\t\t\tif (core) core.cameraScrolling = false;\n\t\t\t\tsettleTimeoutId = null;\n\t\t\t\t// Emit settle event so algorithm can recalculate\n\t\t\t\tgridElement.dispatchEvent(\n\t\t\t\t\tnew CustomEvent('egg-camera-settled', { bubbles: true })\n\t\t\t\t);\n\t\t\t}, settleDelay);\n\t\t}\n\t}\n\n\t/**\n\t * Scroll an item into view based on current mode.\n\t */\n\tfunction scrollTo(item: HTMLElement, behavior: ScrollBehavior = scrollBehavior): void {\n\t\tif (mode === 'off') return;\n\n\t\tconst itemRect = item.getBoundingClientRect();\n\t\tconst viewport = getViewportRect(scrollContainer);\n\n\t\tif (mode === 'center') {\n\t\t\t// Center the item in the viewport\n\t\t\tconst targetScrollTop =\n\t\t\t\tscrollContainer === window\n\t\t\t\t\t? window.scrollY + itemRect.top - viewport.height / 2 + itemRect.height / 2\n\t\t\t\t\t: (scrollContainer as HTMLElement).scrollTop +\n\t\t\t\t\t\titemRect.top -\n\t\t\t\t\t\tviewport.top -\n\t\t\t\t\t\tviewport.height / 2 +\n\t\t\t\t\t\titemRect.height / 2;\n\n\t\t\tconst targetScrollLeft =\n\t\t\t\tscrollContainer === window\n\t\t\t\t\t? window.scrollX + itemRect.left - viewport.width / 2 + itemRect.width / 2\n\t\t\t\t\t: (scrollContainer as HTMLElement).scrollLeft +\n\t\t\t\t\t\titemRect.left -\n\t\t\t\t\t\tviewport.left -\n\t\t\t\t\t\tviewport.width / 2 +\n\t\t\t\t\t\titemRect.width / 2;\n\n\t\t\tif (scrollContainer === window) {\n\t\t\t\twindow.scrollTo({ top: targetScrollTop, left: targetScrollLeft, behavior });\n\t\t\t} else {\n\t\t\t\t(scrollContainer as HTMLElement).scrollTo({\n\t\t\t\t\ttop: targetScrollTop,\n\t\t\t\t\tleft: targetScrollLeft,\n\t\t\t\t\tbehavior,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t// 'contain' mode - use CSS scroll-margin with scrollIntoView\n\t\t\t// The scroll-margin should be set in CSS on items (or we set it here)\n\t\t\t// This lets the browser handle all the positioning math\n\n\t\t\titem.scrollIntoView({\n\t\t\t\tbehavior,\n\t\t\t\tblock: 'nearest',\n\t\t\t\tinline: 'nearest',\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Calculate scroll velocity based on pointer position relative to edges.\n\t */\n\tfunction getEdgeScrollVelocity(\n\t\tpointerX: number,\n\t\tpointerY: number\n\t): { x: number; y: number } {\n\t\tconst viewport = getViewportRect(scrollContainer);\n\t\tlet velocityX = 0;\n\t\tlet velocityY = 0;\n\n\t\t// Pointer position relative to viewport\n\t\tconst relativeX = pointerX - viewport.left;\n\t\tconst relativeY = pointerY - viewport.top;\n\n\t\t// Check horizontal edges\n\t\tif (relativeX < edgeSize) {\n\t\t\t// Near left edge - scroll left (negative)\n\t\t\tvelocityX = -scrollSpeed * (1 - relativeX / edgeSize);\n\t\t} else if (relativeX > viewport.width - edgeSize) {\n\t\t\t// Near right edge - scroll right (positive)\n\t\t\tvelocityX = scrollSpeed * (1 - (viewport.width - relativeX) / edgeSize);\n\t\t}\n\n\t\t// Check vertical edges\n\t\tif (relativeY < edgeSize) {\n\t\t\t// Near top edge - scroll up (negative)\n\t\t\tvelocityY = -scrollSpeed * (1 - relativeY / edgeSize);\n\t\t} else if (relativeY > viewport.height - edgeSize) {\n\t\t\t// Near bottom edge - scroll down (positive)\n\t\t\tvelocityY = scrollSpeed * (1 - (viewport.height - relativeY) / edgeSize);\n\t\t}\n\n\t\treturn { x: velocityX, y: velocityY };\n\t}\n\n\t/**\n\t * Animation loop for edge scrolling during drag.\n\t */\n\tlet wasScrollingLastFrame = false;\n\n\tfunction scrollLoop(): void {\n\t\tif (!isDragging || !autoScrollOnDrag || mode === 'off') {\n\t\t\tanimationFrameId = null;\n\t\t\tif (wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(false);\n\t\t\t\twasScrollingLastFrame = false;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconst velocity = getEdgeScrollVelocity(lastPointerX, lastPointerY);\n\t\tconst isNearEdge = velocity.x !== 0 || velocity.y !== 0;\n\n\t\tif (isNearEdge) {\n\t\t\tif (!wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(true);\n\t\t\t}\n\t\t\twasScrollingLastFrame = true;\n\t\t\tif (scrollContainer === window) {\n\t\t\t\twindow.scrollBy(velocity.x, velocity.y);\n\t\t\t} else {\n\t\t\t\t(scrollContainer as HTMLElement).scrollLeft += velocity.x;\n\t\t\t\t(scrollContainer as HTMLElement).scrollTop += velocity.y;\n\t\t\t}\n\t\t} else {\n\t\t\t// Not near edge\n\t\t\tif (wasScrollingLastFrame) {\n\t\t\t\tsetScrolling(false);\n\t\t\t\twasScrollingLastFrame = false;\n\t\t\t}\n\t\t}\n\n\t\tanimationFrameId = requestAnimationFrame(scrollLoop);\n\t}\n\n\t/**\n\t * Start the scroll loop.\n\t */\n\tfunction startScrollLoop(): void {\n\t\tif (animationFrameId === null) {\n\t\t\tanimationFrameId = requestAnimationFrame(scrollLoop);\n\t\t}\n\t}\n\n\t/**\n\t * Stop the scroll loop.\n\t */\n\tfunction stopScrollLoop(): void {\n\t\tif (animationFrameId !== null) {\n\t\t\tcancelAnimationFrame(animationFrameId);\n\t\t\tanimationFrameId = null;\n\t\t}\n\t\tsetScrolling(false);\n\t}\n\n\t// Track pointer position continuously during drag (not just on cell change)\n\tfunction onPointerMove(e: PointerEvent): void {\n\t\tif (!isDragging || !autoScrollOnDrag || mode === 'off') return;\n\n\t\tlastPointerX = e.clientX;\n\t\tlastPointerY = e.clientY;\n\t\tstartScrollLoop();\n\t}\n\n\t// Event handlers\n\tfunction onDragStart(e: CustomEvent<DragStartDetail>): void {\n\t\tisDragging = true;\n\t\tdragSource = e.detail.source;\n\t\t// Only listen for raw pointer moves during pointer drags (for edge-scroll detection)\n\t\tif (dragSource === 'pointer') {\n\t\t\twindow.addEventListener('pointermove', onPointerMove);\n\t\t}\n\t}\n\n\tfunction onDragMove(e: CustomEvent<DragMoveDetail>): void {\n\t\tif (mode === 'off') return;\n\n\t\tif (e.detail.source === 'pointer') {\n\t\t\t// Pointer drag: update position for edge detection\n\t\t\tlastPointerX = e.detail.x;\n\t\t\tlastPointerY = e.detail.y;\n\t\t} else {\n\t\t\t// Keyboard drag - scroll to keep item visible\n\t\t\t// Use requestAnimationFrame to let the DOM update first\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tscrollTo(e.detail.item, 'smooth');\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction onDragEnd(e: CustomEvent<DragEndDetail>): void {\n\t\tconst wasPointerDrag = dragSource === 'pointer';\n\t\tisDragging = false;\n\t\tdragSource = null;\n\t\tstopScrollLoop();\n\t\tif (wasPointerDrag) {\n\t\t\twindow.removeEventListener('pointermove', onPointerMove);\n\t\t}\n\n\t\t// For keyboard moves (nudge), scroll to keep item visible after it moves\n\t\t// Pointer drags handle their own scrolling via edge detection\n\t\tif (!wasPointerDrag && scrollOnSelect) {\n\t\t\t// Wait for layout to settle (view transitions may be animating)\n\t\t\t// Use setTimeout + rAF to ensure DOM has updated\n\t\t\tsetTimeout(() => {\n\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\tscrollTo(e.detail.item, 'smooth');\n\t\t\t\t});\n\t\t\t}, 100);\n\t\t}\n\t}\n\n\tfunction onDragCancel(e: CustomEvent<DragCancelDetail>): void {\n\t\tconst wasPointerDrag = dragSource === 'pointer';\n\t\tisDragging = false;\n\t\tdragSource = null;\n\t\tstopScrollLoop();\n\t\tif (wasPointerDrag) {\n\t\t\twindow.removeEventListener('pointermove', onPointerMove);\n\t\t}\n\t}\n\n\tfunction onSelect(e: CustomEvent<SelectDetail>): void {\n\t\tif (!scrollOnSelect || mode === 'off') return;\n\n\t\t// Don't scroll during drag - the drag handles its own scrolling\n\t\tif (isDragging) return;\n\n\t\tscrollTo(e.detail.item);\n\t}\n\n\tconst removeListeners = listenEvents(gridElement, {\n\t\t'egg-drag-start': onDragStart as EventListener,\n\t\t'egg-drag-move': onDragMove as EventListener,\n\t\t'egg-drag-end': onDragEnd as EventListener,\n\t\t'egg-drag-cancel': onDragCancel as EventListener,\n\t\t'egg-select': onSelect as EventListener,\n\t});\n\n\tfunction destroy(): void {\n\t\tstopScrollLoop();\n\t\tremoveListeners();\n\t}\n\n\treturn {\n\t\tsetMode(newMode: CameraMode): void {\n\t\t\tmode = newMode;\n\t\t\tif (mode === 'off') {\n\t\t\t\tstopScrollLoop();\n\t\t\t}\n\t\t},\n\t\tgetMode(): CameraMode {\n\t\t\treturn mode;\n\t\t},\n\t\tscrollTo,\n\t\tstop: stopScrollLoop,\n\t\tdestroy,\n\t};\n}\n\n","/**\n * Placeholder plugin for EG Grid\n *\n * Shows a visual placeholder where the dragged item will land.\n * Handles creation, positioning, and cleanup automatically.\n */\n\nimport { listenEvents } from '../engine';\nimport type {\n\tDragStartDetail,\n\tDragMoveDetail,\n\tDragEndDetail,\n\tDragCancelDetail,\n\tDropPreviewDetail,\n\tResizeStartDetail,\n\tResizeMoveDetail,\n\tResizeEndDetail,\n\tResizeCancelDetail,\n} from '../types';\n\nexport interface PlaceholderOptions {\n\t/**\n\t * CSS class name for the placeholder element.\n\t * @default 'egg-placeholder'\n\t */\n\tclassName?: string;\n\n\t/**\n\t * Custom element to use as placeholder instead of creating one.\n\t * If provided, className is ignored.\n\t */\n\telement?: HTMLElement;\n\n\t/**\n\t * Whether to disable view-transition-name on the placeholder.\n\t * Set to true to prevent the placeholder from animating with View Transitions.\n\t * @default true\n\t */\n\tdisableViewTransition?: boolean;\n}\n\nexport interface PlaceholderInstance {\n\t/** Manually show the placeholder at a position */\n\tshow(column: number, row: number, colspan?: number, rowspan?: number): void;\n\t/** Manually hide the placeholder */\n\thide(): void;\n\t/** Remove event listeners and clean up */\n\tdestroy(): void;\n}\n\n/**\n * Attach a placeholder to a EG Grid grid element.\n *\n * @example\n * ```js\n * import { init } from './eg-grid.js';\n * import { attachPlaceholder } from './placeholder.js';\n *\n * const grid = init(document.getElementById('grid'));\n * const placeholder = attachPlaceholder(grid.element);\n *\n * // Later, to clean up:\n * placeholder.destroy();\n * ```\n */\nexport function attachPlaceholder(\n\tgridElement: HTMLElement,\n\toptions: PlaceholderOptions = {}\n): PlaceholderInstance {\n\tconst {\n\t\tclassName = 'egg-placeholder',\n\t\telement: customElement,\n\t\tdisableViewTransition = true,\n\t} = options;\n\n\tlet placeholder: HTMLElement | null = null;\n\tlet isCustomElement = false;\n\n\tfunction create(): void {\n\t\tif (placeholder) return;\n\n\t\tif (customElement) {\n\t\t\tplaceholder = customElement;\n\t\t\tisCustomElement = true;\n\t\t} else {\n\t\t\tplaceholder = document.createElement('div');\n\t\t\tplaceholder.className = className;\n\t\t}\n\n\t\t// Prevent placeholder from interfering with pointer events\n\t\tplaceholder.style.pointerEvents = 'none';\n\n\t\t// Disable view transitions on placeholder to prevent animation artifacts\n\t\tif (disableViewTransition) {\n\t\t\tplaceholder.style.viewTransitionName = 'none';\n\t\t}\n\n\t\tgridElement.appendChild(placeholder);\n\t}\n\n\tfunction update(\n\t\tcolumn: number,\n\t\trow: number,\n\t\tcolspan: number = 1,\n\t\trowspan: number = 1\n\t): void {\n\t\tif (!placeholder) return;\n\t\tplaceholder.style.gridColumn = `${column} / span ${colspan}`;\n\t\tplaceholder.style.gridRow = `${row} / span ${rowspan}`;\n\t}\n\n\tfunction remove(): void {\n\t\tif (placeholder) {\n\t\t\tplaceholder.remove();\n\t\t\t// Only null out if we created it; keep reference if custom\n\t\t\tif (!isCustomElement) {\n\t\t\t\tplaceholder = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Event handlers\n\tfunction handleDragStart(e: CustomEvent<DragStartDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tcreate();\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleDragMove(e: CustomEvent<DragMoveDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\t// Algorithm plugins (e.g. reorder) emit drop-preview when the actual\n\t// landing position differs from the raw pointer cell. Override the\n\t// placeholder position so it shows where the item will really land.\n\tfunction handleDropPreview(e: CustomEvent<DropPreviewDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleDragEnd(_e: CustomEvent<DragEndDetail>): void {\n\t\tremove();\n\t}\n\n\tfunction handleDragCancel(_e: CustomEvent<DragCancelDetail>): void {\n\t\tremove();\n\t}\n\n\t// Resize event handlers\n\t// The placeholder shows where the item will land after resize. For handles that\n\t// change position (NW, NE, SW, N, W), the cell position changes but the anchor\n\t// corner stays fixed. This is correct - the placeholder shows the final landing spot.\n\tfunction handleResizeStart(e: CustomEvent<ResizeStartDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tcreate();\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleResizeMove(e: CustomEvent<ResizeMoveDetail>): void {\n\t\tconst { cell, colspan, rowspan } = e.detail;\n\t\tupdate(cell.column, cell.row, colspan, rowspan);\n\t}\n\n\tfunction handleResizeEnd(_e: CustomEvent<ResizeEndDetail>): void {\n\t\tremove();\n\t}\n\n\tfunction handleResizeCancel(_e: CustomEvent<ResizeCancelDetail>): void {\n\t\tremove();\n\t}\n\n\t// Fallback cleanup for edge cases (pointer released outside window, etc.)\n\tfunction handlePointerUp(): void {\n\t\trequestAnimationFrame(() => {\n\t\t\tif (\n\t\t\t\tplaceholder &&\n\t\t\t\t!document.querySelector('[data-egg-dragging]') &&\n\t\t\t\t!document.querySelector('[data-egg-resizing]')\n\t\t\t) {\n\t\t\t\tremove();\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction handlePointerCancel(): void {\n\t\tremove();\n\t}\n\n\t// Attach listeners\n\tconst removeGridListeners = listenEvents(gridElement, {\n\t\t'egg-drag-start': handleDragStart as EventListener,\n\t\t'egg-drag-move': handleDragMove as EventListener,\n\t\t'egg-drag-end': handleDragEnd as EventListener,\n\t\t'egg-drag-cancel': handleDragCancel as EventListener,\n\t\t'egg-drop-preview': handleDropPreview as EventListener,\n\t\t'egg-resize-start': handleResizeStart as EventListener,\n\t\t'egg-resize-move': handleResizeMove as EventListener,\n\t\t'egg-resize-end': handleResizeEnd as EventListener,\n\t\t'egg-resize-cancel': handleResizeCancel as EventListener,\n\t});\n\tconst removeDocListeners = listenEvents(document, {\n\t\tpointerup: handlePointerUp,\n\t\tpointercancel: handlePointerCancel,\n\t});\n\n\t// Public API\n\treturn {\n\t\tshow(\n\t\t\tcolumn: number,\n\t\t\trow: number,\n\t\t\tcolspan: number = 1,\n\t\t\trowspan: number = 1\n\t\t): void {\n\t\t\tcreate();\n\t\t\tupdate(column, row, colspan, rowspan);\n\t\t},\n\n\t\thide(): void {\n\t\t\tremove();\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tremove();\n\t\t\tremoveGridListeners();\n\t\t\tremoveDocListeners();\n\t\t},\n\t};\n}\n\n","/**\n * Shared DOM integration harness for layout algorithms.\n *\n * Provides the boilerplate that every algorithm needs: event listeners for\n * drag/resize, View Transitions, CSS injection via StyleManager, layout\n * provider registration, camera-settled handling, and cleanup.\n *\n * Individual algorithms implement AlgorithmStrategy and call attachAlgorithm().\n */\n\nimport { listenEvents } from \"../engine\";\nimport type {\n  DragEndDetail,\n  DragMoveDetail,\n  DragStartDetail,\n  DragSource,\n  GridCell,\n  EggCore,\n  ItemPosition,\n  LayoutChangeDetail,\n  ResizeCancelDetail,\n  ResizeEndDetail,\n  ResizeMoveDetail,\n  ResizeStartDetail,\n  ResponsiveLayoutModel,\n  StyleManager,\n} from \"../types\";\n\n// ============================================================================\n// Shared types (originally in algorithm-push-core.ts)\n// ============================================================================\n\nexport interface ItemRect {\n  id: string;\n  column: number;\n  row: number;\n  width: number;\n  height: number;\n}\n\n/**\n * Options for CSS generation\n */\nexport interface LayoutToCSSOptions {\n  selectorPrefix?: string;\n  selectorSuffix?: string;\n  excludeSelector?: string;\n  maxColumns?: number;\n}\n\n// ============================================================================\n// Shared pure functions\n// ============================================================================\n\n/**\n * Convert layout to CSS rules for injection into a <style> tag.\n */\nexport function layoutToCSS(\n  items: ItemRect[],\n  options: LayoutToCSSOptions = {},\n): string {\n  const {\n    selectorPrefix = '[data-egg-item=\"',\n    selectorSuffix = '\"]',\n    excludeSelector = \"\",\n    maxColumns,\n  } = options;\n\n  const rules: string[] = [];\n\n  for (const item of items) {\n    const width = maxColumns ? Math.min(item.width, maxColumns) : item.width;\n    const column = maxColumns\n      ? Math.max(1, Math.min(item.column, maxColumns - width + 1))\n      : item.column;\n    const selector = `${selectorPrefix}${item.id}${selectorSuffix}${excludeSelector}`;\n    const gridColumn = `${column} / span ${width}`;\n    const gridRow = `${item.row} / span ${item.height}`;\n\n    rules.push(\n      `${selector} { grid-column: ${gridColumn}; grid-row: ${gridRow}; }`,\n    );\n  }\n\n  return rules.join(\"\\n\");\n}\n\n/**\n * Read item positions from DOM elements\n */\nexport function readItemsFromDOM(container: HTMLElement): ItemRect[] {\n  const elements = container.querySelectorAll(\"[data-egg-item]\");\n  return Array.from(elements).map((el) => {\n    const element = el as HTMLElement;\n    const style = getComputedStyle(element);\n    const column = parseInt(style.gridColumnStart, 10) || 1;\n    const row = parseInt(style.gridRowStart, 10) || 1;\n    const width =\n      parseInt(element.getAttribute(\"data-egg-colspan\") || \"1\", 10) || 1;\n    const height =\n      parseInt(element.getAttribute(\"data-egg-rowspan\") || \"1\", 10) || 1;\n    const id = element.dataset.eggItem || element.dataset.id || \"\";\n\n    return { id, column, row, width, height };\n  });\n}\n\n// ============================================================================\n// Strategy interface\n// ============================================================================\n\nexport interface AlgorithmStrategy {\n  /** Calculate layout after a drag move/end */\n  calculateDragLayout(\n    items: ItemRect[],\n    movedId: string,\n    targetCell: GridCell,\n    columns: number,\n  ): ItemRect[];\n\n  /** Optional hook called after drag-move layout is applied (e.g. emit drop-preview) */\n  afterDragMove?(\n    layout: ItemRect[],\n    movedId: string,\n    gridElement: HTMLElement,\n  ): void;\n\n  /** Calculate layout after a resize move/end. If undefined, resize events are ignored. */\n  calculateResizeLayout?(\n    items: ItemRect[],\n    resizedId: string,\n    cell: GridCell,\n    colspan: number,\n    rowspan: number,\n    columns: number,\n  ): ItemRect[];\n}\n\n// ============================================================================\n// Harness options\n// ============================================================================\n\nexport interface AlgorithmHarnessOptions {\n  selectorPrefix?: string;\n  selectorSuffix?: string;\n  core?: EggCore;\n  layoutModel?: ResponsiveLayoutModel;\n}\n\n// ============================================================================\n// attachAlgorithm — shared DOM integration\n// ============================================================================\n\n/**\n * Attach a layout algorithm strategy to a grid element.\n *\n * Handles all DOM event wiring, View Transitions, CSS injection, layout model\n * persistence, and cleanup. The strategy only needs to provide pure layout\n * calculation functions.\n *\n * @param gridElement - The grid container element\n * @param strategy - Algorithm-specific layout functions\n * @param options - Configuration options\n * @returns Cleanup function to detach the algorithm\n */\nexport function attachAlgorithm(\n  gridElement: HTMLElement,\n  strategy: AlgorithmStrategy,\n  options: AlgorithmHarnessOptions = {},\n): () => void {\n  const {\n    selectorPrefix = '[data-egg-item=\"',\n    selectorSuffix = '\"]',\n    core,\n    layoutModel,\n  } = options;\n  const styles: StyleManager | null = core?.styles ?? null;\n\n  function getCurrentColumnCount(): number {\n    const style = getComputedStyle(gridElement);\n    const columns = style.gridTemplateColumns.split(\" \").filter(Boolean);\n    return Math.max(1, columns.length);\n  }\n\n  let originalPositions: Map<string, { column: number; row: number }> | null =\n    null;\n  let draggedItemId: string | null = null;\n  let draggedElement: HTMLElement | null = null;\n  let dragSource: DragSource | null = null;\n  let layoutVersion = 0;\n  let currentLayout: ItemRect[] | null = null;\n  let dragStartColumnCount: number | null = null;\n\n  // Resize state\n  let resizedItemId: string | null = null;\n  let resizedElement: HTMLElement | null = null;\n  let resizeSource: DragSource | null = null;\n  let resizeOriginalPositions: Map<\n    string,\n    { column: number; row: number; width: number; height: number }\n  > | null = null;\n  let lastResizeLayout: {\n    cell: GridCell;\n    colspan: number;\n    rowspan: number;\n  } | null = null;\n  let resizeStartColumnCount: number | null = null;\n\n  function getItemId(element: HTMLElement): string {\n    return element.dataset.eggItem || element.dataset.id || \"\";\n  }\n\n  /** Read items from DOM with original positions restored (except the actively dragged item) */\n  function getItemsWithOriginals(\n    excludeId: string | null,\n    originals: Map<string, { column: number; row: number }>,\n  ): ItemRect[] {\n    return readItemsFromDOM(gridElement).map((item) => {\n      const original = originals.get(item.id);\n      if (original && item.id !== excludeId) {\n        return { ...item, column: original.column, row: original.row };\n      }\n      return item;\n    });\n  }\n\n  /** Build resize items from original positions, with resized item updated */\n  function getResizeItems(\n    originals: Map<\n      string,\n      { column: number; row: number; width: number; height: number }\n    >,\n    resizedId: string,\n    cell: GridCell,\n    colspan: number,\n    rowspan: number,\n  ): ItemRect[] {\n    const items: ItemRect[] = [];\n    for (const [id, original] of originals) {\n      if (id === resizedId) {\n        items.push({\n          id,\n          column: cell.column,\n          row: cell.row,\n          width: colspan,\n          height: rowspan,\n        });\n      } else {\n        items.push({\n          id,\n          column: original.column,\n          row: original.row,\n          width: original.width,\n          height: original.height,\n        });\n      }\n    }\n    return items;\n  }\n\n  function saveAndClearPreview(\n    layout: ItemRect[],\n    columnCount: number,\n    afterSave?: () => void,\n  ): void {\n    if (!layoutModel || !columnCount) return;\n    const positions = new Map<string, ItemPosition>();\n    for (const item of layout) {\n      positions.set(item.id, { column: item.column, row: item.row });\n    }\n    layoutModel.saveLayout(columnCount, positions);\n    if (afterSave) afterSave();\n    if (styles) {\n      styles.clear(\"preview\");\n      styles.commit();\n    }\n\n    // Emit layout-change only on settled layouts (drag-end / resize-end)\n    if (core) {\n      core.emit<LayoutChangeDetail>(\"layout-change\", {\n        items: layout,\n        columnCount,\n      });\n    }\n  }\n\n  function applyLayout(\n    layout: ItemRect[],\n    excludeId: string | null,\n    useViewTransition: boolean,\n    onApplied?: () => void,\n  ): void {\n    const thisVersion = ++layoutVersion;\n    currentLayout = layout;\n    const capturedColumnCount = dragStartColumnCount ?? resizeStartColumnCount;\n\n    const applyChanges = () => {\n      if (thisVersion !== layoutVersion) return;\n\n      if (styles) {\n        const itemsToStyle = excludeId\n          ? layout.filter((item) => item.id !== excludeId)\n          : layout;\n        const css = layoutToCSS(itemsToStyle, {\n          selectorPrefix,\n          selectorSuffix,\n          maxColumns: capturedColumnCount ?? undefined,\n        });\n        styles.set(\"preview\", css);\n        styles.commit();\n\n        const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n        for (const el of elements) {\n          const element = el as HTMLElement;\n          const id = getItemId(element);\n          const vtn = element.style.viewTransitionName;\n          if (id !== excludeId && vtn !== \"none\") {\n            element.style.gridColumn = \"\";\n            element.style.gridRow = \"\";\n          }\n        }\n      } else {\n        const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n        for (const el of elements) {\n          const element = el as HTMLElement;\n          const id = getItemId(element);\n          if (id === excludeId) continue;\n          const item = layout.find((it) => it.id === id);\n          if (item) {\n            const colspan =\n              parseInt(\n                element.getAttribute(\"data-egg-colspan\") || \"1\",\n                10,\n              ) || 1;\n            const rowspan =\n              parseInt(\n                element.getAttribute(\"data-egg-rowspan\") || \"1\",\n                10,\n              ) || 1;\n            element.style.gridColumn = `${item.column} / span ${colspan}`;\n            element.style.gridRow = `${item.row} / span ${rowspan}`;\n          }\n        }\n      }\n\n      if (onApplied) onApplied();\n    };\n\n    if (useViewTransition && \"startViewTransition\" in document) {\n      if (draggedElement && excludeId) {\n        draggedElement.style.viewTransitionName = \"dragging\";\n      }\n      (document as any).startViewTransition(applyChanges);\n    } else {\n      applyChanges();\n    }\n  }\n\n  // =========================================================================\n  // Drag event handlers\n  // =========================================================================\n\n  const onDragStart = (e: Event) => {\n    const detail = (e as CustomEvent<DragStartDetail>).detail;\n    draggedElement = detail.item;\n    draggedItemId = getItemId(detail.item);\n    dragSource = detail.source;\n    dragStartColumnCount = getCurrentColumnCount();\n\n    const items = readItemsFromDOM(gridElement);\n    originalPositions = new Map();\n    for (const item of items) {\n      originalPositions.set(item.id, { column: item.column, row: item.row });\n    }\n\n    if (styles) {\n      const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n      for (const el of elements) {\n        const element = el as HTMLElement;\n        if (element !== draggedElement) {\n          element.style.gridColumn = \"\";\n          element.style.gridRow = \"\";\n        }\n      }\n      const css = layoutToCSS(items, {\n        selectorPrefix,\n        selectorSuffix,\n        maxColumns: dragStartColumnCount,\n      });\n      styles.set(\"preview\", css);\n      styles.commit();\n    }\n  };\n\n  let pendingCell: GridCell | null = null;\n\n  const onDragMove = (e: Event) => {\n    if (!draggedItemId || !originalPositions) return;\n    const detail = (e as CustomEvent<DragMoveDetail>).detail;\n\n    if (core?.cameraScrolling) {\n      pendingCell = detail.cell;\n      return;\n    }\n    pendingCell = null;\n\n    const items = getItemsWithOriginals(draggedItemId, originalPositions!);\n    const columns = dragStartColumnCount ?? getCurrentColumnCount();\n    const newLayout = strategy.calculateDragLayout(\n      items,\n      draggedItemId,\n      detail.cell,\n      columns,\n    );\n    applyLayout(newLayout, draggedItemId, true);\n\n    if (strategy.afterDragMove) {\n      strategy.afterDragMove(newLayout, draggedItemId, gridElement);\n    }\n  };\n\n  const onDragEnd = (e: Event) => {\n    if (!draggedItemId || !originalPositions) return;\n    const detail = (e as CustomEvent<DragEndDetail>).detail;\n    const items = getItemsWithOriginals(draggedItemId, originalPositions!);\n\n    const columns = dragStartColumnCount ?? getCurrentColumnCount();\n    const finalLayout = strategy.calculateDragLayout(\n      items,\n      draggedItemId,\n      detail.cell,\n      columns,\n    );\n\n    const isPointerDrag = dragSource === \"pointer\";\n    if (\n      draggedElement &&\n      draggedElement.style.viewTransitionName === \"dragging\"\n    ) {\n      draggedElement.style.viewTransitionName = \"\";\n    }\n\n    const useViewTransition = !isPointerDrag;\n    const savedDragStartColumnCount = dragStartColumnCount;\n\n    applyLayout(finalLayout, null, useViewTransition, () =>\n      saveAndClearPreview(finalLayout, savedDragStartColumnCount!),\n    );\n\n    draggedItemId = null;\n    draggedElement = null;\n    dragSource = null;\n    originalPositions = null;\n    pendingCell = null;\n    dragStartColumnCount = null;\n  };\n\n  const onDragCancel = () => {\n    if (!draggedItemId || !originalPositions) return;\n\n    if (\n      draggedElement &&\n      draggedElement.style.viewTransitionName === \"dragging\"\n    ) {\n      draggedElement.style.viewTransitionName = \"\";\n    }\n\n    const restoreLayout = getItemsWithOriginals(null, originalPositions!);\n    const restore = () => applyLayout(restoreLayout, null, false);\n\n    if (\"startViewTransition\" in document) {\n      (document as any).startViewTransition(restore);\n    } else {\n      restore();\n    }\n\n    draggedItemId = null;\n    draggedElement = null;\n    dragSource = null;\n    originalPositions = null;\n    pendingCell = null;\n    dragStartColumnCount = null;\n  };\n\n  const onCameraSettled = () => {\n    if (!draggedItemId || !originalPositions) return;\n\n    let cell = pendingCell;\n    if (!cell && draggedElement) {\n      const rect = draggedElement.getBoundingClientRect();\n      const centerX = rect.left + rect.width / 2;\n      const centerY = rect.top + rect.height / 2;\n      cell = core?.getCellFromPoint(centerX, centerY) ?? null;\n    }\n\n    if (!cell) return;\n    pendingCell = null;\n\n    const items = getItemsWithOriginals(draggedItemId, originalPositions!);\n    const columns = dragStartColumnCount ?? getCurrentColumnCount();\n    const newLayout = strategy.calculateDragLayout(\n      items,\n      draggedItemId!,\n      cell,\n      columns,\n    );\n    applyLayout(newLayout, draggedItemId, true);\n\n    if (strategy.afterDragMove) {\n      strategy.afterDragMove(newLayout, draggedItemId!, gridElement);\n    }\n  };\n\n  // =========================================================================\n  // Resize event handlers (only if strategy supports resize)\n  // =========================================================================\n\n  const onResizeStart = (e: Event) => {\n    if (!strategy.calculateResizeLayout) return;\n    const detail = (e as CustomEvent<ResizeStartDetail>).detail;\n    resizedElement = detail.item;\n    resizedItemId = getItemId(detail.item);\n    resizeSource = detail.source;\n    resizeStartColumnCount = getCurrentColumnCount();\n\n    const items = readItemsFromDOM(gridElement);\n    resizeOriginalPositions = new Map();\n    for (const item of items) {\n      resizeOriginalPositions.set(item.id, {\n        column: item.column,\n        row: item.row,\n        width: item.width,\n        height: item.height,\n      });\n    }\n\n    if (styles) {\n      const elements = gridElement.querySelectorAll(\"[data-egg-item]\");\n      for (const el of elements) {\n        const element = el as HTMLElement;\n        if (element !== resizedElement) {\n          element.style.gridColumn = \"\";\n          element.style.gridRow = \"\";\n        }\n      }\n      const css = layoutToCSS(items, {\n        selectorPrefix,\n        selectorSuffix,\n        maxColumns: resizeStartColumnCount,\n      });\n      styles.set(\"preview\", css);\n      styles.commit();\n    }\n\n    lastResizeLayout = null;\n  };\n\n  const onResizeMove = (e: Event) => {\n    if (!strategy.calculateResizeLayout) return;\n    if (!resizedItemId || !resizeOriginalPositions) return;\n    const detail = (e as CustomEvent<ResizeMoveDetail>).detail;\n\n    if (\n      lastResizeLayout &&\n      lastResizeLayout.cell.column === detail.cell.column &&\n      lastResizeLayout.cell.row === detail.cell.row &&\n      lastResizeLayout.colspan === detail.colspan &&\n      lastResizeLayout.rowspan === detail.rowspan\n    ) {\n      return;\n    }\n    lastResizeLayout = {\n      cell: { ...detail.cell },\n      colspan: detail.colspan,\n      rowspan: detail.rowspan,\n    };\n\n    const items = getResizeItems(\n      resizeOriginalPositions,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n    );\n    const columns = resizeStartColumnCount ?? getCurrentColumnCount();\n    const newLayout = strategy.calculateResizeLayout(\n      items,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n      columns,\n    );\n    applyLayout(newLayout, resizedItemId, true);\n  };\n\n  const onResizeEnd = (e: Event) => {\n    if (!strategy.calculateResizeLayout) return;\n    if (!resizedItemId || !resizeOriginalPositions) return;\n    const detail = (e as CustomEvent<ResizeEndDetail>).detail;\n    const items = getResizeItems(\n      resizeOriginalPositions,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n    );\n\n    const columns = resizeStartColumnCount ?? getCurrentColumnCount();\n    const finalLayout = strategy.calculateResizeLayout(\n      items,\n      resizedItemId,\n      detail.cell,\n      detail.colspan,\n      detail.rowspan,\n      columns,\n    );\n\n    const isPointerResize = resizeSource === \"pointer\";\n    const useViewTransition = !isPointerResize;\n    const savedResizedItemId = resizedItemId;\n    const savedResizeStartColumnCount = resizeStartColumnCount;\n\n    applyLayout(finalLayout, null, useViewTransition, () =>\n      saveAndClearPreview(finalLayout, savedResizeStartColumnCount!, () => {\n        layoutModel!.updateItemSize(savedResizedItemId!, {\n          width: detail.colspan,\n          height: detail.rowspan,\n        });\n      }),\n    );\n\n    resizedItemId = null;\n    resizedElement = null;\n    resizeSource = null;\n    resizeOriginalPositions = null;\n    lastResizeLayout = null;\n    resizeStartColumnCount = null;\n  };\n\n  const onResizeCancel = () => {\n    if (!resizedItemId || !resizeOriginalPositions) return;\n\n    const restoreLayout = Array.from(resizeOriginalPositions, ([id, o]) => ({\n      id,\n      column: o.column,\n      row: o.row,\n      width: o.width,\n      height: o.height,\n    }));\n    const restore = () => applyLayout(restoreLayout, null, false);\n\n    if (\"startViewTransition\" in document) {\n      (document as any).startViewTransition(restore);\n    } else {\n      restore();\n    }\n\n    resizedItemId = null;\n    resizedElement = null;\n    resizeSource = null;\n    resizeOriginalPositions = null;\n    lastResizeLayout = null;\n    resizeStartColumnCount = null;\n  };\n\n  // =========================================================================\n  // Event listener registration\n  // =========================================================================\n\n  return listenEvents(gridElement, {\n    \"egg-drag-start\": onDragStart,\n    \"egg-drag-move\": onDragMove,\n    \"egg-drag-end\": onDragEnd,\n    \"egg-drag-cancel\": onDragCancel,\n    \"egg-camera-settled\": onCameraSettled,\n    \"egg-resize-start\": onResizeStart,\n    \"egg-resize-move\": onResizeMove,\n    \"egg-resize-end\": onResizeEnd,\n    \"egg-resize-cancel\": onResizeCancel,\n  });\n}\n","/**\n * Push-down layout algorithm for EG Grid\n *\n * This module provides both:\n * 1. Pure algorithm functions (overlap detection, push-down, compaction)\n * 2. DOM integration via the shared algorithm harness\n *\n * Usage (pure functions):\n *   import { calculateLayout, layoutToCSS } from 'eg-grid/algorithm-push';\n *   const newLayout = calculateLayout(items, movedId, targetCell);\n *   core.styles.set('preview', layoutToCSS(newLayout));\n *   core.styles.commit();\n *\n * Usage (DOM integration):\n *   import { init } from 'eg-grid';\n *   import { attachPushAlgorithm } from 'eg-grid/algorithm-push';\n *\n *   const grid = init(element);\n *   const detach = attachPushAlgorithm(grid.element);\n */\n\nimport type {\n\tGridCell,\n\tEggCore,\n\tResponsiveLayoutModel,\n} from '../types';\n\nimport {\n\tattachAlgorithm,\n\ttype AlgorithmHarnessOptions,\n\ttype AlgorithmStrategy,\n\ttype ItemRect,\n} from './algorithm-harness';\n\n// Re-export shared types and functions from harness\nexport {\n\tlayoutToCSS,\n\treadItemsFromDOM,\n\ttype ItemRect,\n\ttype LayoutToCSSOptions,\n} from './algorithm-harness';\n\n// Also re-export GridCell so consumers don't need to import from types.ts\nexport type { GridCell } from '../types';\n\n// ============================================================================\n// Pure push-down algorithm\n// ============================================================================\n\n/**\n * Check if two items overlap\n */\nexport function itemsOverlap(a: ItemRect, b: ItemRect): boolean {\n\treturn !(\n\t\ta.column + a.width <= b.column ||\n\t\tb.column + b.width <= a.column ||\n\t\ta.row + a.height <= b.row ||\n\t\tb.row + b.height <= a.row\n\t);\n}\n\n/**\n * Check if any items in the layout overlap\n * @returns Array of overlapping pairs, empty if no overlaps\n */\nexport function findOverlaps(items: ItemRect[]): Array<[ItemRect, ItemRect]> {\n\tconst overlaps: Array<[ItemRect, ItemRect]> = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tfor (let j = i + 1; j < items.length; j++) {\n\t\t\tif (itemsOverlap(items[i], items[j])) {\n\t\t\t\toverlaps.push([items[i], items[j]]);\n\t\t\t}\n\t\t}\n\t}\n\treturn overlaps;\n}\n\n/**\n * Push items down recursively to resolve collisions\n * Mutates the items array in place\n */\nexport function pushDown(\n\titems: ItemRect[],\n\tmoved: ItemRect,\n\tmovedId: string,\n\tdepth = 0,\n): void {\n\tif (depth > 50) {\n\t\treturn;\n\t}\n\n\t// Sort by row descending - push bottom items first so upper items settle on top\n\t// This preserves the original relative ordering of items\n\tconst colliders = items\n\t\t.filter((it) => it.id !== movedId && it.id !== moved.id && itemsOverlap(moved, it))\n\t\t.sort((a, b) => b.row - a.row || a.column - b.column);\n\n\tfor (const collider of colliders) {\n\t\tconst newRow = moved.row + moved.height;\n\t\tif (collider.row < newRow) {\n\t\t\tcollider.row = newRow;\n\t\t\tpushDown(items, collider, movedId, depth + 1);\n\t\t}\n\t}\n}\n\n/**\n * Compact items upward to fill gaps\n * Mutates the items array in place\n */\nexport function compactUp(items: ItemRect[], excludeId: string): void {\n\tconst sorted = [...items]\n\t\t.filter((it) => it.id !== excludeId)\n\t\t.sort((a, b) => a.row - b.row || a.column - b.column);\n\n\tfor (const item of sorted) {\n\t\tlet iterations = 0;\n\t\twhile (item.row > 1 && iterations < 100) {\n\t\t\titerations++;\n\t\t\titem.row -= 1;\n\t\t\tconst hasCollision = items.some(\n\t\t\t\t(other) => other.id !== item.id && itemsOverlap(item, other),\n\t\t\t);\n\t\t\tif (hasCollision) {\n\t\t\t\titem.row += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Options for calculateLayout\n */\nexport interface CalculateLayoutOptions {\n\t/**\n\t * Whether to compact items upward after resolving collisions (default: true)\n\t */\n\tcompact?: boolean;\n}\n\n/**\n * Calculate new layout after moving an item\n * Returns a new array with updated positions\n */\nexport function calculateLayout(\n\titems: ItemRect[],\n\tmovedId: string,\n\ttargetCell: GridCell,\n\toptions: CalculateLayoutOptions = {},\n): ItemRect[] {\n\tconst { compact = true } = options;\n\n\t// Deep copy items\n\tconst result = items.map((item) => ({ ...item }));\n\n\tconst movedItem = result.find((it) => it.id === movedId);\n\tif (!movedItem) return result;\n\n\tmovedItem.column = targetCell.column;\n\tmovedItem.row = targetCell.row;\n\n\tpushDown(result, movedItem, movedId);\n\tif (compact) {\n\t\tcompactUp(result, movedId);\n\t}\n\n\treturn result;\n}\n\n// ============================================================================\n// DOM integration via harness\n// ============================================================================\n\n/**\n * Options for attachPushAlgorithm\n */\nexport interface AttachPushAlgorithmOptions {\n\tselectorPrefix?: string;\n\tselectorSuffix?: string;\n\t/**\n\t * Whether to compact items upward after resolving collisions (default: true)\n\t * When false, items only get pushed down but won't float back up to fill gaps.\n\t */\n\tcompaction?: boolean;\n\tcore?: EggCore;\n\tlayoutModel?: ResponsiveLayoutModel;\n}\n\n/**\n * Attach push-down algorithm to a grid element.\n *\n * This creates event listeners for eg-grid drag events and updates\n * the layout when items are moved. Layout changes are animated\n * via View Transitions.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach the algorithm\n */\nexport function attachPushAlgorithm(\n\tgridElement: HTMLElement,\n\toptions: AttachPushAlgorithmOptions = {},\n): () => void {\n\tconst { compaction = true, ...harnessOptions } = options;\n\n\tconst strategy: AlgorithmStrategy = {\n\t\tcalculateDragLayout(items, movedId, targetCell) {\n\t\t\treturn calculateLayout(items, movedId, targetCell, { compact: compaction });\n\t\t},\n\t\tcalculateResizeLayout(items, resizedId, cell) {\n\t\t\treturn calculateLayout(items, resizedId, cell, { compact: compaction });\n\t\t},\n\t};\n\n\treturn attachAlgorithm(gridElement, strategy, harnessOptions);\n}\n\n","/**\n * Reorder layout algorithm for EG Grid\n *\n * Sequence-based reflow: items have a logical order, dragging changes\n * position in that sequence, all items reflow like CSS Grid auto-placement.\n *\n * Usage (pure functions):\n *   import { calculateReorderLayout, reflowItems, layoutToCSS } from 'eg-grid/algorithm-reorder';\n *\n * Usage (DOM integration):\n *   import { attachReorderAlgorithm } from 'eg-grid/algorithm-reorder';\n *   const detach = attachReorderAlgorithm(grid.element, { core });\n */\n\nimport type {\n\tGridCell,\n\tEggCore,\n\tResponsiveLayoutModel,\n} from '../types';\n\nimport {\n\tattachAlgorithm,\n\ttype AlgorithmStrategy,\n\ttype ItemRect,\n} from './algorithm-harness';\n\n// Re-export shared types and functions from harness\nexport {\n\tlayoutToCSS,\n\ttype ItemRect,\n\ttype LayoutToCSSOptions,\n} from './algorithm-harness';\n\n// Also re-export GridCell so consumers don't need to import from types.ts\nexport type { GridCell } from '../types';\n\n// ============================================================================\n// Pure reorder algorithm\n// ============================================================================\n\n/**\n * Sort items into reading order (row-major: row first, then column)\n */\nexport function getItemOrder(items: ItemRect[]): ItemRect[] {\n\treturn [...items].sort((a, b) => a.row - b.row || a.column - b.column);\n}\n\n/**\n * Check if a cell range is available (not occupied)\n */\nfunction rangeAvailable(\n\toccupied: Set<string>,\n\tcolumn: number,\n\trow: number,\n\twidth: number,\n\theight: number,\n\tcolumns: number,\n): boolean {\n\tif (column + width - 1 > columns) return false;\n\n\tfor (let r = row; r < row + height; r++) {\n\t\tfor (let c = column; c < column + width; c++) {\n\t\t\tif (occupied.has(`${c},${r}`)) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Mark cells as occupied\n */\nfunction markOccupied(\n\toccupied: Set<string>,\n\tcolumn: number,\n\trow: number,\n\twidth: number,\n\theight: number,\n): void {\n\tfor (let r = row; r < row + height; r++) {\n\t\tfor (let c = column; c < column + width; c++) {\n\t\t\toccupied.add(`${c},${r}`);\n\t\t}\n\t}\n}\n\n/**\n * Reflow items into grid positions using auto-placement.\n * Scans left-to-right, top-to-bottom for the first position each item fits.\n *\n * @param items - Items in logical order (sequence determines placement priority)\n * @param columns - Number of grid columns\n * @returns New array with updated positions\n */\nexport function reflowItems(items: ItemRect[], columns: number): ItemRect[] {\n\tconst occupied = new Set<string>();\n\tconst result: ItemRect[] = [];\n\n\tfor (const item of items) {\n\t\tconst width = Math.min(item.width, columns);\n\t\tlet placed = false;\n\n\t\tfor (let row = 1; !placed; row++) {\n\t\t\tfor (let col = 1; col <= columns; col++) {\n\t\t\t\tif (rangeAvailable(occupied, col, row, width, item.height, columns)) {\n\t\t\t\t\tmarkOccupied(occupied, col, row, width, item.height);\n\t\t\t\t\tresult.push({ ...item, column: col, row, width });\n\t\t\t\t\tplaced = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Safety: prevent infinite loop on pathological inputs\n\t\t\tif (row > 100) {\n\t\t\t\tresult.push({ ...item, column: 1, row, width });\n\t\t\t\tmarkOccupied(occupied, 1, row, width, item.height);\n\t\t\t\tplaced = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Compare positions in reading order (row-major)\n */\nfunction positionBefore(a: GridCell, b: GridCell): boolean {\n\treturn a.row < b.row || (a.row === b.row && a.column < b.column);\n}\n\n/**\n * Options for calculateReorderLayout\n */\nexport interface CalculateReorderLayoutOptions {\n\t/** Number of grid columns */\n\tcolumns: number;\n}\n\n/**\n * Calculate new layout after reordering an item.\n *\n * 1. Sort items by current position to get logical order\n * 2. Remove moved item from sequence\n * 3. Reflow remaining items to get candidate positions\n * 4. Find insertion index: before the first candidate whose reflowed position\n *    comes after targetCell in reading order\n * 5. Insert moved item at that index\n * 6. Reflow all items\n *\n * @returns New array with updated positions\n */\nexport function calculateReorderLayout(\n\titems: ItemRect[],\n\tmovedId: string,\n\ttargetCell: GridCell,\n\toptions: CalculateReorderLayoutOptions,\n): ItemRect[] {\n\tconst { columns } = options;\n\n\t// Deep copy items\n\tconst all = items.map((item) => ({ ...item }));\n\n\t// Get logical order from current positions\n\tconst ordered = getItemOrder(all);\n\n\t// Extract moved item\n\tconst movedItem = ordered.find((it) => it.id === movedId);\n\tif (!movedItem) return reflowItems(ordered, columns);\n\n\tconst remaining = ordered.filter((it) => it.id !== movedId);\n\n\t// Reflow remaining to get candidate positions\n\tconst reflowed = reflowItems(remaining, columns);\n\n\t// Find insertion index: before the first reflowed item whose position\n\t// comes after targetCell in reading order\n\tlet insertIndex = reflowed.length; // default: append at end\n\tfor (let i = 0; i < reflowed.length; i++) {\n\t\tif (!positionBefore(reflowed[i], targetCell)) {\n\t\t\tinsertIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Build final sequence with moved item inserted\n\tconst finalSequence: ItemRect[] = [\n\t\t...remaining.slice(0, insertIndex),\n\t\tmovedItem,\n\t\t...remaining.slice(insertIndex),\n\t];\n\n\t// Reflow everything\n\treturn reflowItems(finalSequence, columns);\n}\n\n// ============================================================================\n// DOM integration via harness\n// ============================================================================\n\n/**\n * Options for attachReorderAlgorithm\n */\nexport interface AttachReorderAlgorithmOptions {\n\tselectorPrefix?: string;\n\tselectorSuffix?: string;\n\tcore?: EggCore;\n\tlayoutModel?: ResponsiveLayoutModel;\n}\n\n/**\n * Attach reorder algorithm to a grid element.\n *\n * Listens to drag/resize events and reflows items in sequence order.\n * Layout changes are animated via View Transitions.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach the algorithm\n */\nexport function attachReorderAlgorithm(\n\tgridElement: HTMLElement,\n\toptions: AttachReorderAlgorithmOptions = {},\n): () => void {\n\tconst strategy: AlgorithmStrategy = {\n\t\tcalculateDragLayout(items, movedId, targetCell, columns) {\n\t\t\treturn calculateReorderLayout(items, movedId, targetCell, { columns });\n\t\t},\n\n\t\tafterDragMove(layout, movedId, el) {\n\t\t\t// Emit drop-preview so the placeholder knows the actual landing position.\n\t\t\t// Use queueMicrotask to ensure this fires AFTER all drag-move handlers\n\t\t\t// (including the placeholder's) have finished, regardless of listener order.\n\t\t\tconst landingItem = layout.find((it) => it.id === movedId);\n\t\t\tif (landingItem) {\n\t\t\t\tconst previewDetail = {\n\t\t\t\t\tcell: { column: landingItem.column, row: landingItem.row },\n\t\t\t\t\tcolspan: landingItem.width,\n\t\t\t\t\trowspan: landingItem.height,\n\t\t\t\t};\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tel.dispatchEvent(new CustomEvent('egg-drop-preview', {\n\t\t\t\t\t\tdetail: previewDetail,\n\t\t\t\t\t\tbubbles: true,\n\t\t\t\t\t}));\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tcalculateResizeLayout(items, _resizedId, _cell, _colspan, _rowspan, columns) {\n\t\t\t// For resize, reflow all items in their current order with the resized item's new size\n\t\t\tconst ordered = [...items].sort((a, b) => a.row - b.row || a.column - b.column);\n\t\t\treturn reflowItems(ordered, columns);\n\t\t},\n\t};\n\n\treturn attachAlgorithm(gridElement, strategy, options);\n}\n\n","/**\n * Responsive Plugin\n *\n * Handles responsive column detection and CSS injection for different breakpoints.\n *\n * Responsibilities:\n * - Detect column count changes via ResizeObserver\n * - Inject CSS for all breakpoints using container queries\n * - Register 'columnCount' provider for other plugins\n * - Emit 'egg-column-count-change' events\n * - Regenerate CSS when layout model changes\n *\n * CSS is injected once on init and regenerated when the layout model changes.\n * The actual responsive layout switching is handled by CSS container queries.\n */\n\nimport type {\n\tColumnCountChangeDetail,\n\tEggCore,\n\tResponsivePluginOptions,\n\tStyleManager,\n} from '../types';\n\n/**\n * Responsive state exposed via provider registry\n */\nexport interface ResponsiveState {\n\tcolumnCount: number;\n\tmaxColumns: number;\n\tminColumns: number;\n\thasOverride: boolean;\n}\n\n/**\n * Attach the responsive plugin to a grid element.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options including layout model and style element\n * @param core - Optional EggCore for provider registration\n * @returns Cleanup function to detach the plugin\n */\nexport function attachResponsive(\n\tgridElement: HTMLElement,\n\toptions: ResponsivePluginOptions,\n\tcore?: EggCore,\n): () => void {\n\tconst { layoutModel } = options;\n\tconst styles: StyleManager | null = core?.styles ?? null;\n\n\t// Infer cell size and gap from CSS if not provided\n\tlet cellSize = options.cellSize;\n\tlet gap = options.gap;\n\n\tfunction inferGridMetrics(): void {\n\t\tif (cellSize !== undefined && gap !== undefined) return;\n\n\t\tconst style = getComputedStyle(gridElement);\n\n\t\tif (gap === undefined) {\n\t\t\tgap = parseFloat(style.columnGap) || parseFloat(style.gap) || 16;\n\t\t}\n\n\t\tif (cellSize === undefined) {\n\t\t\t// Try to infer from grid-auto-rows or first track\n\t\t\tconst autoRows = parseFloat(style.gridAutoRows) || 0;\n\t\t\tif (autoRows > 0) {\n\t\t\t\tcellSize = autoRows;\n\t\t\t} else {\n\t\t\t\t// Fall back to first column track width\n\t\t\t\tconst columns = style.gridTemplateColumns.split(' ');\n\t\t\t\tcellSize = parseFloat(columns[0] ?? '184') || 184;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Detect current column count from computed grid style\n\t */\n\tfunction detectColumnCount(): number {\n\t\tconst style = getComputedStyle(gridElement);\n\t\tconst columns = style.gridTemplateColumns.split(' ').filter(Boolean);\n\t\treturn Math.max(1, columns.length);\n\t}\n\n\t/**\n\t * Inject CSS for all breakpoints\n\t */\n\tfunction injectCSS(): void {\n\t\tif (!styles) return;\n\n\t\tinferGridMetrics();\n\n\t\t// Use the grid element's class or ID as the selector\n\t\tconst gridSelector = gridElement.id\n\t\t\t? `#${gridElement.id}`\n\t\t\t: gridElement.className\n\t\t\t\t? `.${gridElement.className.split(' ')[0]}`\n\t\t\t\t: '.grid';\n\n\t\tconst css = layoutModel.generateAllBreakpointCSS({\n\t\t\tcellSize: cellSize!,\n\t\t\tgap: gap!,\n\t\t\tgridSelector,\n\t\t});\n\n\t\tstyles.set('base', css);\n\t\tstyles.commit();\n\t}\n\n\t// Track if server-rendered CSS was detected\n\t// When true, we only inject CSS for explicit user overrides, not derived layouts\n\tconst hasServerRenderedCSS = !!(styles?.get('base')?.trim());\n\n\t// Only inject CSS if base layer is empty (not server-rendered)\n\t// This prevents flash when server has already provided initial CSS\n\tif (!hasServerRenderedCSS) {\n\t\tinjectCSS();\n\t}\n\n\t// Subscribe to layout model changes\n\t// The subscription only fires on user actions (saveLayout/clearOverride),\n\t// so we always inject CSS here - the initial hasServerRenderedCSS check\n\t// prevents injection on page load, this handles user interactions.\n\tconst unsubscribe = layoutModel.subscribe(() => injectCSS());\n\n\t// Watch for resize to update column count tracking\n\tlet lastColumnCount = layoutModel.currentColumnCount;\n\n\tconst resizeObserver = new ResizeObserver(() => {\n\t\tconst newColumnCount = detectColumnCount();\n\n\t\tif (newColumnCount !== lastColumnCount) {\n\t\t\tconst previousCount = lastColumnCount;\n\t\t\tlastColumnCount = newColumnCount;\n\n\t\t\t// Update layout model\n\t\t\tlayoutModel.setCurrentColumnCount(newColumnCount);\n\n\t\t\tgridElement.dispatchEvent(\n\t\t\t\tnew CustomEvent('egg-column-count-change', {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail: { previousCount, currentCount: newColumnCount },\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t});\n\n\tresizeObserver.observe(gridElement);\n\n\t// Cleanup function\n\treturn () => {\n\t\tresizeObserver.disconnect();\n\t\tunsubscribe();\n\t};\n}\n\n","import type { GridCell, EggCore, InitOptions, StyleManager } from './types';\nimport { createStateMachine } from './state-machine';\nimport { attachPointer } from './plugins/pointer';\nimport { attachKeyboard } from './plugins/keyboard';\nimport { attachAccessibility } from './plugins/accessibility';\nimport { attachResize } from './plugins/resize';\nimport { attachCamera } from './plugins/camera';\nimport { attachPlaceholder } from './plugins/placeholder';\nimport { attachPushAlgorithm } from './plugins/algorithm-push';\nimport { attachReorderAlgorithm } from './plugins/algorithm-reorder';\nimport { attachResponsive } from './plugins/responsive';\n\n/**\n * Initialize EG Grid on a CSS Grid element\n *\n * @param element - The CSS Grid container element\n * @param options - Configuration options\n */\nexport function init(element: HTMLElement, options: InitOptions = {}): EggCore {\n\tconst {\n\t\tlayoutModel,\n\t\tstyleElement,\n\t} = options;\n\n\tconst cleanups: (() => void)[] = [];\n\n\t// Create centralized state machine\n\tconst stateMachine = createStateMachine();\n\n\t// Track selected element (state machine stores itemId, we need the element)\n\tlet selectedElement: HTMLElement | null = null;\n\n\t// StyleManager: single style element, multiple named layers\n\tconst styleLayers = new Map<string, string>(); // layer name → CSS\n\tconst layerOrder: string[] = []; // insertion order\n\tconst managedStyleElement = styleElement ?? document.createElement('style');\n\tif (!styleElement) {\n\t\tdocument.head.appendChild(managedStyleElement);\n\t\tcleanups.push(() => managedStyleElement.remove());\n\t}\n\n\t// Pre-populate 'base' layer with any existing content (e.g. server-rendered CSS)\n\tconst existingCSS = managedStyleElement.textContent?.trim();\n\tif (existingCSS) {\n\t\tstyleLayers.set('base', existingCSS);\n\t\tlayerOrder.push('base');\n\t}\n\n\tconst styles: StyleManager = {\n\t\tset(layer: string, css: string): void {\n\t\t\tif (!styleLayers.has(layer)) {\n\t\t\t\tlayerOrder.push(layer);\n\t\t\t}\n\t\t\tstyleLayers.set(layer, css);\n\t\t},\n\t\tget(layer: string): string {\n\t\t\treturn styleLayers.get(layer) ?? '';\n\t\t},\n\t\tclear(layer: string): void {\n\t\t\tif (styleLayers.has(layer)) {\n\t\t\t\tstyleLayers.set(layer, '');\n\t\t\t}\n\t\t},\n\t\tcommit(): void {\n\t\t\tconst parts: string[] = [];\n\t\t\tfor (const layer of layerOrder) {\n\t\t\t\tconst css = styleLayers.get(layer);\n\t\t\t\tif (css) parts.push(css);\n\t\t\t}\n\t\t\tmanagedStyleElement.textContent = parts.join('\\n\\n');\n\t\t},\n\t};\n\n\tconst core: EggCore = {\n\t\telement,\n\t\tstateMachine,\n\t\tstyles,\n\t\tcameraScrolling: false,\n\n\t\t// Selection state (backed by state machine)\n\t\tget selectedItem() {\n\t\t\treturn selectedElement;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedElement) return;\n\n\t\t\tconst previousItem = selectedElement;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-egg-selected');\n\t\t\t}\n\n\t\t\t// Update state machine and local element reference\n\t\t\tif (item) {\n\t\t\t\tconst itemId = item.id || item.getAttribute('data-egg-item') || '';\n\t\t\t\tstateMachine.transition({ type: 'SELECT', itemId, element: item });\n\t\t\t\tselectedElement = item;\n\t\t\t\titem.setAttribute('data-egg-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else {\n\t\t\t\tstateMachine.transition({ type: 'DESELECT' });\n\t\t\t\tselectedElement = null;\n\t\t\t\tif (previousItem) {\n\t\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`egg-${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Direct initialization — no registry, no loop\n\tif (options.pointer !== false) {\n\t\tcleanups.push(attachPointer(core));\n\t}\n\tif (options.keyboard !== false) {\n\t\tcleanups.push(attachKeyboard(core));\n\t}\n\tif (options.accessibility !== false) {\n\t\tcleanups.push(attachAccessibility(core));\n\t}\n\n\tif (options.resize !== false) {\n\t\tconst resizeOpts = typeof options.resize === 'object' ? options.resize : {};\n\t\tconst inst = attachResize(element, { ...resizeOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.camera !== false) {\n\t\tconst cameraOpts = typeof options.camera === 'object' ? options.camera : {};\n\t\tconst inst = attachCamera(element, { ...cameraOpts, core });\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\tif (options.placeholder !== false) {\n\t\tconst placeholderOpts = typeof options.placeholder === 'object' ? options.placeholder : {};\n\t\tconst inst = attachPlaceholder(element, placeholderOpts);\n\t\tcleanups.push(() => inst.destroy());\n\t}\n\n\t// Algorithm: push (default) or reorder\n\tif (options.algorithm !== false) {\n\t\tconst algoOpts = options.algorithmOptions ?? {};\n\t\tif (options.algorithm === 'reorder') {\n\t\t\tcleanups.push(attachReorderAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t} else {\n\t\t\tcleanups.push(attachPushAlgorithm(element, { ...algoOpts, core, layoutModel }));\n\t\t}\n\t}\n\n\tif (options.responsive) {\n\t\tcleanups.push(attachResponsive(element, options.responsive, core));\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Get the size of an item from its data attributes\n */\nexport function getItemSize(item: HTMLElement): { colspan: number; rowspan: number } {\n\treturn {\n\t\tcolspan: parseInt(item.getAttribute('data-egg-colspan') || '1', 10) || 1,\n\t\trowspan: parseInt(item.getAttribute('data-egg-rowspan') || '1', 10) || 1,\n\t};\n}\n\n/**\n * Attach multiple event listeners and return a cleanup function to remove them all\n */\nexport function listenEvents(\n\telement: EventTarget,\n\tevents: Record<string, EventListenerOrEventListenerObject>,\n): () => void {\n\tfor (const [name, handler] of Object.entries(events)) {\n\t\telement.addEventListener(name, handler);\n\t}\n\treturn () => {\n\t\tfor (const [name, handler] of Object.entries(events)) {\n\t\t\telement.removeEventListener(name, handler);\n\t\t}\n\t};\n}\n","/**\n * Responsive Layout Model\n *\n * Manages layouts across different column counts with a three-tier system:\n * 1. Canonical layout - source of truth at maxColumns\n * 2. Per-column-count overrides - user customizations at specific breakpoints\n * 3. Auto-derived layouts - calculated via compaction for other column counts\n *\n * This module is pure data/logic with no DOM dependencies, making it suitable\n * for use with backend-driven state (e.g., Datastar integration).\n */\n\nimport type {\n\tBreakpointCSSOptions,\n\tCreateLayoutModelOptions,\n\tItemDefinition,\n\tItemPosition,\n\tLayoutItem,\n\tResponsiveLayoutModel,\n} from './types';\n\nconst MAX_ROWS = 100; // Safety limit for layout derivation\n\n/**\n * Create a responsive layout model\n */\nexport function createLayoutModel(\n\toptions: CreateLayoutModelOptions,\n): ResponsiveLayoutModel {\n\tconst { maxColumns, minColumns = 1, items: itemDefs } = options;\n\n\t// Store item definitions\n\tconst items = new Map<string, ItemDefinition>();\n\tfor (const item of itemDefs) {\n\t\titems.set(item.id, { id: item.id, width: item.width, height: item.height });\n\t}\n\n\t// Store canonical positions (at maxColumns)\n\tlet canonicalPositions = new Map<string, ItemPosition>(\n\t\toptions.canonicalPositions,\n\t);\n\n\t// Store per-column-count overrides\n\tconst overrides = new Map<number, Map<string, ItemPosition>>(\n\t\toptions.overrides,\n\t);\n\n\t// Current column count (updated by responsive plugin)\n\tlet currentColumnCount = maxColumns;\n\n\t// Subscribers for layout changes\n\tconst subscribers = new Set<() => void>();\n\n\tfunction notifySubscribers(): void {\n\t\tfor (const callback of Array.from(subscribers)) {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * Get items sorted by position (top-to-bottom, left-to-right)\n\t * Used for consistent ordering in layout derivation\n\t */\n\tfunction getItemsInPositionOrder(\n\t\tpositions: Map<string, ItemPosition>,\n\t): ItemDefinition[] {\n\t\treturn Array.from(items.values()).sort((a, b) => {\n\t\t\tconst posA = positions.get(a.id) ?? { column: 0, row: 0 };\n\t\t\tconst posB = positions.get(b.id) ?? { column: 0, row: 0 };\n\t\t\t// Sort by row first, then column\n\t\t\treturn posA.row - posB.row || posA.column - posB.column;\n\t\t});\n\t}\n\n\t/**\n\t * Derive layout for a given column count using first-fit compaction.\n\t * Items are placed in position order (top-to-bottom, left-to-right)\n\t * into the first available space that fits.\n\t */\n\tfunction deriveLayoutForColumns(\n\t\tcols: number,\n\t\tsourcePositions: Map<string, ItemPosition>,\n\t): Map<string, ItemPosition> {\n\t\tconst sorted = getItemsInPositionOrder(sourcePositions);\n\t\tconst result = new Map<string, ItemPosition>();\n\n\t\t// 2D occupancy grid: occupied[row][col] = itemId or null\n\t\tconst occupied: (string | null)[][] = [];\n\t\tfor (let r = 0; r < MAX_ROWS; r++) {\n\t\t\toccupied.push(new Array(cols).fill(null));\n\t\t}\n\n\t\tfor (const itemDef of sorted) {\n\t\t\t// Clamp width to available columns\n\t\t\tconst w = Math.min(itemDef.width, cols);\n\t\t\tconst h = itemDef.height;\n\n\t\t\t// Find first available position (first-fit)\n\t\t\tlet placed = false;\n\t\t\tfor (let row = 0; row < MAX_ROWS && !placed; row++) {\n\t\t\t\tfor (let col = 0; col <= cols - w && !placed; col++) {\n\t\t\t\t\t// Check if space is available\n\t\t\t\t\tlet canFit = true;\n\t\t\t\t\tfor (let dy = 0; dy < h && canFit; dy++) {\n\t\t\t\t\t\tfor (let dx = 0; dx < w && canFit; dx++) {\n\t\t\t\t\t\t\tif (occupied[row + dy]?.[col + dx] !== null) {\n\t\t\t\t\t\t\t\tcanFit = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (canFit) {\n\t\t\t\t\t\tresult.set(itemDef.id, { column: col + 1, row: row + 1 }); // 1-indexed for CSS Grid\n\t\t\t\t\t\t// Mark cells as occupied\n\t\t\t\t\t\tfor (let dy = 0; dy < h; dy++) {\n\t\t\t\t\t\t\tfor (let dx = 0; dx < w; dx++) {\n\t\t\t\t\t\t\t\tif (occupied[row + dy]) {\n\t\t\t\t\t\t\t\t\toccupied[row + dy]![col + dx] = itemDef.id;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplaced = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!placed) {\n\t\t\t\t// Fallback: place at bottom (shouldn't happen with reasonable MAX_ROWS)\n\t\t\t\tresult.set(itemDef.id, { column: 1, row: MAX_ROWS });\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Calculate breakpoint width for a given column count.\n\t * n columns needs: n * cellSize + (n - 1) * gap pixels\n\t */\n\tfunction getBreakpointWidth(cols: number, cellSize: number, gap: number): number {\n\t\treturn cols * cellSize + (cols - 1) * gap;\n\t}\n\n\tconst model: ResponsiveLayoutModel = {\n\t\tget maxColumns() {\n\t\t\treturn maxColumns;\n\t\t},\n\t\tget minColumns() {\n\t\t\treturn minColumns;\n\t\t},\n\t\tget items() {\n\t\t\treturn items;\n\t\t},\n\t\tget currentColumnCount() {\n\t\t\treturn currentColumnCount;\n\t\t},\n\n\t\tgetLayoutForColumns(columnCount: number): Map<string, ItemPosition> {\n\t\t\t// Clamp to valid range\n\t\t\tconst cols = Math.max(minColumns, Math.min(maxColumns, columnCount));\n\n\t\t\tif (cols === maxColumns) {\n\t\t\t\treturn new Map(canonicalPositions);\n\t\t\t}\n\n\t\t\t// Check for explicit override\n\t\t\tconst override = overrides.get(cols);\n\t\t\tif (override) {\n\t\t\t\treturn new Map(override);\n\t\t\t}\n\n\t\t\t// Auto-derive from canonical\n\t\t\treturn deriveLayoutForColumns(cols, canonicalPositions);\n\t\t},\n\n\t\tgetCurrentLayout(): Map<string, ItemPosition> {\n\t\t\treturn this.getLayoutForColumns(currentColumnCount);\n\t\t},\n\n\t\thasOverride(columnCount: number): boolean {\n\t\t\treturn overrides.has(columnCount);\n\t\t},\n\n\t\tgetOverrideColumnCounts(): number[] {\n\t\t\treturn Array.from(overrides.keys()).sort((a, b) => b - a);\n\t\t},\n\n\t\tsaveLayout(columnCount: number, positions: Map<string, ItemPosition>): void {\n\t\t\tconst cols = Math.max(minColumns, Math.min(maxColumns, columnCount));\n\n\t\t\tif (cols === maxColumns) {\n\t\t\t\t// Update canonical layout\n\t\t\t\tcanonicalPositions = new Map(positions);\n\t\t\t} else {\n\t\t\t\t// Create/update override\n\t\t\t\toverrides.set(cols, new Map(positions));\n\t\t\t}\n\n\t\t\tnotifySubscribers();\n\t\t},\n\n\t\tclearOverride(columnCount: number): void {\n\t\t\tif (columnCount === maxColumns) {\n\t\t\t\t// Can't clear canonical layout\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (overrides.delete(columnCount)) {\n\t\t\t\tnotifySubscribers();\n\t\t\t}\n\t\t},\n\n\t\tupdateItemSize(itemId: string, size: { width: number; height: number }): void {\n\t\t\tconst existing = items.get(itemId);\n\t\t\tif (!existing) {\n\t\t\t\tconsole.warn(`[layout-model] updateItemSize: item \"${itemId}\" not found in items Map. Available IDs:`, Array.from(items.keys()));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Update the item definition\n\t\t\titems.set(itemId, {\n\t\t\t\tid: itemId,\n\t\t\t\twidth: size.width,\n\t\t\t\theight: size.height,\n\t\t\t});\n\n\t\t\tnotifySubscribers();\n\t\t},\n\n\t\tsetCurrentColumnCount(columnCount: number): void {\n\t\t\tconst newCount = Math.max(minColumns, Math.min(maxColumns, columnCount));\n\t\t\tif (newCount !== currentColumnCount) {\n\t\t\t\tcurrentColumnCount = newCount;\n\t\t\t\t// Note: We don't notify here because this is just tracking state.\n\t\t\t\t// The responsive plugin will emit an event for UI updates.\n\t\t\t}\n\t\t},\n\n\t\tgenerateAllBreakpointCSS(options?: BreakpointCSSOptions): string {\n\t\t\tconst {\n\t\t\t\tselectorPrefix = '[data-egg-item=\"',\n\t\t\t\tselectorSuffix = '\"]',\n\t\t\t\tcellSize,\n\t\t\t\tgap,\n\t\t\t\tgridSelector = '.grid-container',\n\t\t\t} = options ?? { cellSize: 184, gap: 16 };\n\n\t\t\tconst cssRules: string[] = [];\n\n\t\t\t// Generate fallback rules (canonical layout, no container query)\n\t\t\t// These apply immediately before container queries are evaluated\n\t\t\tcssRules.push('/* Fallback: canonical layout (before container queries evaluate) */');\n\t\t\tfor (const [id, pos] of Array.from(canonicalPositions)) {\n\t\t\t\tconst itemDef = items.get(id);\n\t\t\t\tif (!itemDef) continue;\n\t\t\t\tcssRules.push(\n\t\t\t\t\t`${selectorPrefix}${id}${selectorSuffix} { grid-column: ${pos.column} / span ${itemDef.width}; grid-row: ${pos.row} / span ${itemDef.height}; }`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tcssRules.push('');\n\n\t\t\t// Generate rules for each column count (maxColumns down to minColumns)\n\t\t\tfor (let cols = maxColumns; cols >= minColumns; cols--) {\n\t\t\t\tconst positions = this.getLayoutForColumns(cols);\n\t\t\t\tconst minWidth = getBreakpointWidth(cols, cellSize, gap);\n\t\t\t\tconst hasOverride = overrides.has(cols);\n\n\t\t\t\t// Build container query\n\t\t\t\tlet containerQuery: string;\n\t\t\t\tif (cols === maxColumns) {\n\t\t\t\t\tcontainerQuery = `@container (min-width: ${minWidth}px)`;\n\t\t\t\t} else if (cols === minColumns) {\n\t\t\t\t\t// Smallest size is the default/fallback\n\t\t\t\t\tconst maxWidth = getBreakpointWidth(cols + 1, cellSize, gap) - 1;\n\t\t\t\t\tcontainerQuery = `@container (max-width: ${maxWidth}px)`;\n\t\t\t\t} else {\n\t\t\t\t\tconst maxWidth = getBreakpointWidth(cols + 1, cellSize, gap) - 1;\n\t\t\t\t\tcontainerQuery = `@container (min-width: ${minWidth}px) and (max-width: ${maxWidth}px)`;\n\t\t\t\t}\n\n\t\t\t\t// Build rules for this column count\n\t\t\t\tconst itemRules: string[] = [];\n\n\t\t\t\t// Grid template\n\t\t\t\titemRules.push(\n\t\t\t\t\t`${gridSelector} { grid-template-columns: repeat(${cols}, 1fr); }`,\n\t\t\t\t);\n\n\t\t\t\t// Item positions\n\t\t\t\tfor (const [id, pos] of positions) {\n\t\t\t\t\tconst itemDef = items.get(id);\n\t\t\t\t\tif (!itemDef) continue;\n\n\t\t\t\t\t// Clamp width to current column count\n\t\t\t\t\tconst w = Math.min(itemDef.width, cols);\n\t\t\t\t\titemRules.push(\n\t\t\t\t\t\t`${selectorPrefix}${id}${selectorSuffix} { grid-column: ${pos.column} / span ${w}; grid-row: ${pos.row} / span ${itemDef.height}; }`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Add comment and rules\n\t\t\t\tconst layoutType =\n\t\t\t\t\tcols === maxColumns\n\t\t\t\t\t\t? '(canonical)'\n\t\t\t\t\t\t: hasOverride\n\t\t\t\t\t\t\t? '(override)'\n\t\t\t\t\t\t\t: '(derived)';\n\t\t\t\tcssRules.push(`/* ${cols} columns ${layoutType} */`);\n\t\t\t\tcssRules.push(`${containerQuery} {`);\n\t\t\t\tcssRules.push(itemRules.map((r) => '  ' + r).join('\\n'));\n\t\t\t\tcssRules.push('}');\n\t\t\t\tcssRules.push('');\n\t\t\t}\n\n\t\t\treturn cssRules.join('\\n');\n\t\t},\n\n\t\tsubscribe(callback: () => void): () => void {\n\t\t\tsubscribers.add(callback);\n\t\t\treturn () => subscribers.delete(callback);\n\t\t},\n\t};\n\n\treturn model;\n}\n\n","/**\n * <eg-grid> Web Component\n *\n * Progressive enhancement wrapper for EG Grid. The element IS the grid\n * container — no Shadow DOM (items need parent CSS, View Transitions are\n * document-scoped).\n *\n * Usage (zero JS required):\n *\n *   <style>\n *     [data-egg-item=\"item-a\"] { grid-column: 1 / span 2; grid-row: 1; }\n *     [data-egg-item=\"item-b\"] { grid-column: 3; grid-row: 1; }\n *   </style>\n *   <eg-grid columns=\"4\" cell-size=\"120\" gap=\"8\" algorithm=\"push\" resize-handles=\"all\">\n *     <div data-egg-item=\"item-a\">A</div>\n *     <div data-egg-item=\"item-b\">B</div>\n *   </eg-grid>\n */\n\nimport type {\n\tEggCore,\n\tInitOptions,\n\tItemDefinition,\n\tItemPosition,\n\tResponsiveLayoutModel,\n} from './types';\nimport { init } from './engine';\nimport { createLayoutModel } from './layout-model';\n\nlet nextId = 0;\n\n/**\n * Parse the span (width or height in cells) from grid-column/row start+end.\n * getComputedStyle returns: \"auto\", \"3\" (line number), or \"span 2\".\n */\nfunction parseGridSpan(startStr: string, endStr: string): number {\n\t// \"span 2\" → 2\n\tconst spanMatch = endStr.match(/span\\s+(\\d+)/);\n\tif (spanMatch) return parseInt(spanMatch[1]!, 10) || 1;\n\t// \"3\" with start \"1\" → 3 - 1 = 2\n\tconst endNum = parseInt(endStr, 10);\n\tconst startNum = parseInt(startStr, 10) || 1;\n\tif (!isNaN(endNum) && endNum > startNum) return endNum - startNum;\n\t// \"auto\" or anything else → 1\n\treturn 1;\n}\n\n/**\n * Resolve an item element's ID for the layout model.\n *\n * Priority: data-egg-item > data-id > id\n * (data-egg-item=\"\" means \"is an item but no explicit ID\", so skip empty strings)\n */\nfunction resolveItemId(el: HTMLElement): string {\n\treturn el.dataset.eggItem || el.dataset.id || el.id || '';\n}\n\nexport class EgGridElement extends HTMLElement {\n\tstatic observedAttributes = [\n\t\t'columns',\n\t\t'cell-size',\n\t\t'gap',\n\t\t'algorithm',\n\t\t'resize-handles',\n\t\t'no-camera',\n\t\t'no-placeholder',\n\t\t'no-keyboard',\n\t\t'no-accessibility',\n\t\t'placeholder-class',\n\t];\n\n\t/** The EggCore instance. Available after connectedCallback. */\n\tcore: EggCore | null = null;\n\n\t/** The responsive layout model (if columns + cell-size are set). */\n\tlayoutModel: ResponsiveLayoutModel | null = null;\n\n\tprivate _styleEl: HTMLStyleElement | null = null;\n\tprivate _initialized = false;\n\tprivate _rafId = 0;\n\tprivate _observer: MutationObserver | null = null;\n\n\tconnectedCallback(): void {\n\t\tif (this._initialized) return;\n\t\tthis._init();\n\t}\n\n\tdisconnectedCallback(): void {\n\t\tthis._teardown();\n\t}\n\n\tattributeChangedCallback(): void {\n\t\tif (!this._initialized) return;\n\t\tthis._teardown();\n\t\tthis._init();\n\t}\n\n\tprivate _init(): void {\n\t\tthis._initialized = true;\n\n\t\t// Ensure this element has an id (needed for CSS selectors like #my-grid)\n\t\tif (!this.id) {\n\t\t\tthis.id = `egg-${++nextId}`;\n\t\t}\n\n\t\t// 1. Ensure this element is a grid container\n\t\tconst computed = getComputedStyle(this);\n\t\tif (computed.display !== 'grid' && computed.display !== 'inline-grid') {\n\t\t\tthis.style.display = 'grid';\n\t\t}\n\n\t\t// 2. Read attribute values\n\t\tconst columnsAttr = this.getAttribute('columns');\n\t\tconst gapAttr = this.getAttribute('gap');\n\t\tconst cellSizeAttr = this.getAttribute('cell-size');\n\t\tconst algorithmAttr = this.getAttribute('algorithm');\n\t\tconst resizeHandlesAttr = this.getAttribute('resize-handles');\n\n\t\tconst maxColumns = columnsAttr ? parseInt(columnsAttr, 10) || 4 : this._detectColumnCount();\n\t\tconst cellSize = cellSizeAttr ? parseInt(cellSizeAttr, 10) || 120 : 0;\n\t\tconst gap = gapAttr ? parseInt(gapAttr, 10) || 0 : parseFloat(computed.columnGap) || parseFloat(computed.gap) || 0;\n\t\tconst responsive = cellSize > 0 && !!columnsAttr;\n\n\t\t// 3. Apply CSS shortcut attributes via inline styles.\n\t\t//    For responsive mode, grid-template-columns is set via container query CSS,\n\t\t//    not inline styles (inline styles can't be overridden by @container rules).\n\t\t//    For non-responsive, inline styles are fine.\n\t\tif (columnsAttr && !responsive) {\n\t\t\tconst cols = parseInt(columnsAttr, 10);\n\t\t\tif (cols > 0) {\n\t\t\t\tthis.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;\n\t\t\t}\n\t\t}\n\n\t\tif (gapAttr) {\n\t\t\tthis.style.gap = /^\\d+$/.test(gapAttr) ? `${gapAttr}px` : gapAttr;\n\t\t}\n\n\t\t// 4. Container query context for responsive mode.\n\t\t//    @container queries match the nearest ancestor with containment, so the\n\t\t//    parent of <eg-grid> needs container-type, not <eg-grid> itself.\n\t\tif (responsive && this.parentElement) {\n\t\t\tthis.parentElement.style.containerType = 'inline-size';\n\t\t}\n\n\t\t// 5. Create <style> element for CSS injection\n\t\tthis._styleEl = document.createElement('style');\n\t\tthis.prepend(this._styleEl);\n\n\t\t// 6. Auto-setup items — set tabindex, --item-id, derive span from CSS\n\t\tconst items = this.querySelectorAll<HTMLElement>('[data-egg-item]');\n\t\tconst itemDefs: ItemDefinition[] = [];\n\t\tconst canonicalPositions = new Map<string, ItemPosition>();\n\n\t\tfor (const item of items) {\n\t\t\tif (!item.hasAttribute('tabindex')) {\n\t\t\t\titem.setAttribute('tabindex', '0');\n\t\t\t}\n\n\t\t\tconst id = resolveItemId(item);\n\t\t\tif (!id) continue;\n\n\t\t\t// Set --item-id for View Transitions\n\t\t\titem.style.setProperty('--item-id', id);\n\n\t\t\t// Read position and span from computed styles.\n\t\t\t// gridColumnEnd can be \"auto\", \"3\" (line number), or \"span 2\".\n\t\t\t// parseInt(\"span 2\") → NaN, so we must parse span notation explicitly.\n\t\t\tconst itemStyle = getComputedStyle(item);\n\t\t\tconst colStart = parseInt(itemStyle.gridColumnStart, 10) || 1;\n\t\t\tconst rowStart = parseInt(itemStyle.gridRowStart, 10) || 1;\n\n\t\t\tconst cssWidth = parseGridSpan(itemStyle.gridColumnStart, itemStyle.gridColumnEnd);\n\t\t\tconst cssHeight = parseGridSpan(itemStyle.gridRowStart, itemStyle.gridRowEnd);\n\n\t\t\t// Derive span: prefer data attribute, fall back to CSS\n\t\t\tconst width = parseInt(item.getAttribute('data-egg-colspan') || '0', 10) || cssWidth;\n\t\t\tconst height = parseInt(item.getAttribute('data-egg-rowspan') || '0', 10) || cssHeight;\n\n\t\t\t// Ensure data-egg-colspan/rowspan are set for algorithm's readItemsFromDOM\n\t\t\t// (during drag, item is position:fixed so CSS grid values aren't reliable)\n\t\t\tif (!item.hasAttribute('data-egg-colspan') && width > 1) {\n\t\t\t\titem.setAttribute('data-egg-colspan', String(width));\n\t\t\t}\n\t\t\tif (!item.hasAttribute('data-egg-rowspan') && height > 1) {\n\t\t\t\titem.setAttribute('data-egg-rowspan', String(height));\n\t\t\t}\n\n\t\t\titemDefs.push({ id, width, height });\n\t\t\tcanonicalPositions.set(id, { column: colStart, row: rowStart });\n\t\t}\n\n\t\t// 7. Pack items if no explicit CSS positions were set.\n\t\t//    When items lack grid-column/grid-row CSS, getComputedStyle returns \"auto\"\n\t\t//    which resolves to (1,1) for every item. Detect this overlap and run\n\t\t//    first-fit compaction so items don't stack on top of each other.\n\t\tif (canonicalPositions.size > 1) {\n\t\t\tconst allOverlap = Array.from(canonicalPositions.values())\n\t\t\t\t.every(p => p.column === 1 && p.row === 1);\n\t\t\tif (allOverlap) {\n\t\t\t\tconst occupied: (string | null)[][] = [];\n\t\t\t\tfor (let r = 0; r < 100; r++) occupied.push(new Array(maxColumns).fill(null));\n\t\t\t\tfor (const def of itemDefs) {\n\t\t\t\t\tconst w = Math.min(def.width, maxColumns);\n\t\t\t\t\tconst h = def.height;\n\t\t\t\t\tlet placed = false;\n\t\t\t\t\tfor (let row = 0; row < 100 && !placed; row++) {\n\t\t\t\t\t\tfor (let col = 0; col <= maxColumns - w && !placed; col++) {\n\t\t\t\t\t\t\tlet fits = true;\n\t\t\t\t\t\t\tfor (let dy = 0; dy < h && fits; dy++)\n\t\t\t\t\t\t\t\tfor (let dx = 0; dx < w && fits; dx++)\n\t\t\t\t\t\t\t\t\tif (occupied[row + dy]?.[col + dx] !== null) fits = false;\n\t\t\t\t\t\t\tif (fits) {\n\t\t\t\t\t\t\t\tcanonicalPositions.set(def.id, { column: col + 1, row: row + 1 });\n\t\t\t\t\t\t\t\tfor (let dy = 0; dy < h; dy++)\n\t\t\t\t\t\t\t\t\tfor (let dx = 0; dx < w; dx++)\n\t\t\t\t\t\t\t\t\t\tif (occupied[row + dy]) occupied[row + dy]![col + dx] = def.id;\n\t\t\t\t\t\t\t\tplaced = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 8. Build layout model\n\t\tif (itemDefs.length > 0) {\n\t\t\tthis.layoutModel = createLayoutModel({\n\t\t\t\tmaxColumns,\n\t\t\t\tminColumns: 1,\n\t\t\t\titems: itemDefs,\n\t\t\t\tcanonicalPositions,\n\t\t\t});\n\t\t}\n\n\t\t// 9. Build InitOptions from attributes\n\t\tconst options: InitOptions = {\n\t\t\tstyleElement: this._styleEl,\n\t\t\tlayoutModel: this.layoutModel ?? undefined,\n\t\t\talgorithm: algorithmAttr === 'none' ? false : (algorithmAttr === 'reorder' ? 'reorder' : 'push'),\n\t\t\tkeyboard: this.hasAttribute('no-keyboard') ? false : undefined,\n\t\t\taccessibility: this.hasAttribute('no-accessibility') ? false : undefined,\n\t\t\tcamera: this.hasAttribute('no-camera') ? false : undefined,\n\t\t\tplaceholder: this.hasAttribute('no-placeholder')\n\t\t\t\t? false\n\t\t\t\t: this.getAttribute('placeholder-class')\n\t\t\t\t\t? { className: this.getAttribute('placeholder-class')! }\n\t\t\t\t\t: undefined,\n\t\t\tresize: resizeHandlesAttr\n\t\t\t\t? { handles: resizeHandlesAttr as 'corners' | 'edges' | 'all' }\n\t\t\t\t: false,\n\t\t};\n\n\t\tif (responsive && this.layoutModel) {\n\t\t\toptions.responsive = {\n\t\t\t\tlayoutModel: this.layoutModel,\n\t\t\t\tcellSize,\n\t\t\t\tgap,\n\t\t\t};\n\t\t}\n\n\t\t// 10. Initialize\n\t\tthis.core = init(this, options);\n\n\t\t// 11. Clear inline grid-column/grid-row so CSS injection works\n\t\tfor (const item of items) {\n\t\t\titem.style.removeProperty('grid-column');\n\t\t\titem.style.removeProperty('grid-row');\n\t\t}\n\n\t\t// 12. Set data-pointer-active (pointer is always enabled)\n\t\tthis.setAttribute('data-pointer-active', '');\n\n\t\t// 13. MutationObserver for React compat (childList changes)\n\t\tthis._observeChildren();\n\t}\n\n\tprivate _teardown(): void {\n\t\tif (!this._initialized) return;\n\n\t\tif (this._rafId) {\n\t\t\tcancelAnimationFrame(this._rafId);\n\t\t\tthis._rafId = 0;\n\t\t}\n\n\t\tif (this._observer) {\n\t\t\tthis._observer.disconnect();\n\t\t\tthis._observer = null;\n\t\t}\n\n\t\tif (this.core) {\n\t\t\tthis.core.destroy();\n\t\t\tthis.core = null;\n\t\t}\n\n\t\tif (this._styleEl) {\n\t\t\tthis._styleEl.remove();\n\t\t\tthis._styleEl = null;\n\t\t}\n\n\t\tthis.layoutModel = null;\n\t\tthis._initialized = false;\n\t}\n\n\tprivate _observeChildren(): void {\n\t\tthis._observer = new MutationObserver((mutations) => {\n\t\t\t// Only re-init when data-egg-item elements are added/removed.\n\t\t\t// Ignore internal DOM changes (style elements, placeholder, aria-live regions).\n\t\t\tlet itemsChanged = false;\n\t\t\tfor (const m of mutations) {\n\t\t\t\tfor (const node of m.addedNodes) {\n\t\t\t\t\tif (node instanceof HTMLElement && node.hasAttribute('data-egg-item')) {\n\t\t\t\t\t\titemsChanged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const node of m.removedNodes) {\n\t\t\t\t\tif (node instanceof HTMLElement && node.hasAttribute('data-egg-item')) {\n\t\t\t\t\t\titemsChanged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!itemsChanged) return;\n\n\t\t\tif (this._rafId) return;\n\t\t\tthis._rafId = requestAnimationFrame(() => {\n\t\t\t\tthis._rafId = 0;\n\t\t\t\tif (this.core?.stateMachine.getState().phase === 'interacting') return;\n\t\t\t\tthis._teardown();\n\t\t\t\tthis._init();\n\t\t\t});\n\t\t});\n\n\t\tthis._observer.observe(this, { childList: true });\n\t}\n\n\tprivate _detectColumnCount(): number {\n\t\tconst style = getComputedStyle(this);\n\t\tconst cols = style.gridTemplateColumns.split(' ').filter(Boolean);\n\t\treturn Math.max(1, cols.length);\n\t}\n}\n","// Web component bundle — full library + <eg-grid> custom element auto-registration\n\nexport * from './index';\nexport { EgGridElement } from '../eg-grid-element';\n\nimport { EgGridElement } from '../eg-grid-element';\n\n// Auto-register the custom element\nif (!customElements.get('eg-grid')) {\n\tcustomElements.define('eg-grid', EgGridElement);\n}\n"],"mappings":"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"}