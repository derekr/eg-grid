{
  "version": 3,
  "sources": ["../engine.ts", "../plugins/pointer.ts"],
  "sourcesContent": ["import type { GridCell, GridiotCore, Plugin } from './types';\n\n// Global plugin registry\nconst plugins = new Map<string, Plugin>();\n\nexport function registerPlugin(plugin: Plugin): void {\n\tplugins.set(plugin.name, plugin);\n}\n\nexport function getPlugin(name: string): Plugin | undefined {\n\treturn plugins.get(name);\n}\n\n/**\n * Initialize Gridiot on a CSS Grid element\n */\nexport function init(element: HTMLElement): GridiotCore {\n\tconst cleanups: (() => void)[] = [];\n\n\tconst core: GridiotCore = {\n\t\telement,\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`gridiot:${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tobserver.disconnect();\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Observe position changes and animate with View Transitions\n\tconst observer = new MutationObserver((mutations) => {\n\t\t// Collect items that changed position\n\t\tconst changedItems = new Set<HTMLElement>();\n\n\t\tfor (const mutation of mutations) {\n\t\t\tif (\n\t\t\t\tmutation.type === 'attributes' &&\n\t\t\t\tmutation.target instanceof HTMLElement\n\t\t\t) {\n\t\t\t\tconst item = mutation.target.closest(\n\t\t\t\t\t'[data-gridiot-item]',\n\t\t\t\t) as HTMLElement | null;\n\t\t\t\tif (item && element.contains(item)) {\n\t\t\t\t\tchangedItems.add(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Animate changes with View Transitions if available\n\t\tif (changedItems.size > 0 && 'startViewTransition' in document) {\n\t\t\t// Items already moved - View Transitions will handle animation\n\t\t\t// The browser captures before/after states automatically\n\t\t}\n\t});\n\n\tobserver.observe(element, {\n\t\tsubtree: true,\n\t\tattributes: true,\n\t\tattributeFilter: ['style', 'class'],\n\t});\n\n\t// Initialize all registered plugins\n\tfor (const plugin of plugins.values()) {\n\t\tconst cleanup = plugin.init(core);\n\t\tif (cleanup) {\n\t\t\tcleanups.push(cleanup);\n\t\t}\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\tconst trackEnd = accumulated + track;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated = trackEnd + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Set an item's grid position\n */\nexport function setItemCell(item: HTMLElement, cell: GridCell): void {\n\titem.style.gridColumn = String(cell.column);\n\titem.style.gridRow = String(cell.row);\n}\n", "import { getItemCell, registerPlugin } from '../engine';\nimport type { GridCell } from '../types';\n\n// Hysteresis: distance in grid units before changing target cell\nconst HYSTERESIS = 0.4;\n// Minimum time (ms) between target changes to prevent jitter\nconst TARGET_CHANGE_DEBOUNCE = 40;\n\nconst DEBUG = true;\nfunction log(...args: unknown[]) {\n\tif (DEBUG) console.log('[pointer]', ...args);\n}\n\ninterface DragState {\n\titem: HTMLElement;\n\tpointerId: number;\n\toffsetX: number;\n\toffsetY: number;\n\tinitialRect: DOMRect;\n\tstartCell: GridCell;\n\tlastCell: GridCell;\n\tlastTargetChangeTime: number;\n\tcolspan: number;\n\trowspan: number;\n\t// For direction-based prediction\n\tlastPointerX: number;\n\tlastPointerY: number;\n}\n\nregisterPlugin({\n\tname: 'pointer',\n\tinit(core) {\n\t\tlet dragState: DragState | null = null;\n\n\t\tconst onPointerDown = (e: PointerEvent) => {\n\t\t\tconst item = (e.target as HTMLElement).closest(\n\t\t\t\t'[data-gridiot-item]',\n\t\t\t) as HTMLElement | null;\n\t\t\tif (!item) return;\n\n\t\t\t// Prevent text selection during drag\n\t\t\te.preventDefault();\n\n\t\t\tconst rect = item.getBoundingClientRect();\n\n\t\t\t// IMPORTANT: Capture cell BEFORE changing styles\n\t\t\tconst startCell = getItemCell(item);\n\n\t\t\t// Get item's size for clamping calculations\n\t\t\tconst colspan =\n\t\t\t\tparseInt(item.getAttribute('data-gridiot-colspan') || '1', 10) || 1;\n\t\t\tconst rowspan =\n\t\t\t\tparseInt(item.getAttribute('data-gridiot-rowspan') || '1', 10) || 1;\n\n\t\t\t// Store initial state for visual dragging\n\t\t\tdragState = {\n\t\t\t\titem,\n\t\t\t\tpointerId: e.pointerId,\n\t\t\t\toffsetX: e.clientX - rect.left,\n\t\t\t\toffsetY: e.clientY - rect.top,\n\t\t\t\tinitialRect: rect,\n\t\t\t\tstartCell,\n\t\t\t\tlastCell: startCell,\n\t\t\t\tlastTargetChangeTime: 0,\n\t\t\t\tcolspan,\n\t\t\t\trowspan,\n\t\t\t\tlastPointerX: e.clientX,\n\t\t\t\tlastPointerY: e.clientY,\n\t\t\t};\n\n\t\t\titem.setPointerCapture(e.pointerId);\n\t\t\titem.setAttribute('data-gridiot-dragging', '');\n\n\t\t\t// Switch to fixed positioning for visual drag\n\t\t\titem.style.position = 'fixed';\n\t\t\titem.style.left = `${rect.left}px`;\n\t\t\titem.style.top = `${rect.top}px`;\n\t\t\titem.style.width = `${rect.width}px`;\n\t\t\titem.style.height = `${rect.height}px`;\n\t\t\titem.style.zIndex = '100';\n\t\t\titem.style.gridColumn = '';\n\t\t\titem.style.gridRow = '';\n\n\t\t\tlog('drag-start', { startCell, rect: { left: rect.left, top: rect.top } });\n\t\t\tcore.emit('drag-start', { item, cell: startCell });\n\n\t\t\titem.addEventListener('pointermove', onPointerMove);\n\t\t\titem.addEventListener('pointerup', onPointerUp);\n\t\t\titem.addEventListener('pointercancel', onPointerCancel);\n\t\t};\n\n\t\tconst onPointerMove = (e: PointerEvent) => {\n\t\t\tif (!dragState) return;\n\n\t\t\tconst { item, offsetX, offsetY, initialRect, colspan, rowspan } = dragState;\n\n\t\t\t// Calculate movement direction\n\t\t\tconst velocityX = e.clientX - dragState.lastPointerX;\n\t\t\tconst velocityY = e.clientY - dragState.lastPointerY;\n\n\t\t\t// Update last pointer position\n\t\t\tdragState.lastPointerX = e.clientX;\n\t\t\tdragState.lastPointerY = e.clientY;\n\n\t\t\t// Move item with cursor\n\t\t\tconst newLeft = e.clientX - offsetX;\n\t\t\tconst newTop = e.clientY - offsetY;\n\t\t\titem.style.left = `${newLeft}px`;\n\t\t\titem.style.top = `${newTop}px`;\n\n\t\t\t// Calculate target based on card center (feels more natural for multi-cell items)\n\t\t\tconst cardCenterX = newLeft + initialRect.width / 2;\n\t\t\tconst cardCenterY = newTop + initialRect.height / 2;\n\n\t\t\tconst rawCell = core.getCellFromPoint(cardCenterX, cardCenterY);\n\t\t\tif (rawCell) {\n\t\t\t\t// Clamp cell so item fits within grid bounds\n\t\t\t\tconst gridInfo = core.getGridInfo();\n\t\t\t\tconst maxColumn = Math.max(1, gridInfo.columns.length - colspan + 1);\n\t\t\t\tconst maxRow = Math.max(1, gridInfo.rows.length - rowspan + 1);\n\n\t\t\t\tconst cell: GridCell = {\n\t\t\t\t\tcolumn: Math.max(1, Math.min(maxColumn, rawCell.column)),\n\t\t\t\t\trow: Math.max(1, Math.min(maxRow, rawCell.row)),\n\t\t\t\t};\n\n\t\t\t\tconst now = performance.now();\n\t\t\t\tconst timeSinceLastChange = now - dragState.lastTargetChangeTime;\n\n\t\t\t\t// Check if cell actually changed\n\t\t\t\tconst cellChanged =\n\t\t\t\t\tcell.column !== dragState.lastCell.column ||\n\t\t\t\t\tcell.row !== dragState.lastCell.row;\n\n\t\t\t\tif (cellChanged && timeSinceLastChange >= TARGET_CHANGE_DEBOUNCE) {\n\t\t\t\t\tconst cellWidth = gridInfo.cellWidth + gridInfo.gap;\n\t\t\t\t\tconst cellHeight = gridInfo.cellHeight + gridInfo.gap;\n\n\t\t\t\t\t// Current cell center in pixels (CSS Grid is 1-indexed)\n\t\t\t\t\tconst currentCellCenterX =\n\t\t\t\t\t\tgridInfo.rect.left +\n\t\t\t\t\t\t(dragState.lastCell.column - 1) * cellWidth +\n\t\t\t\t\t\tgridInfo.cellWidth / 2;\n\t\t\t\t\tconst currentCellCenterY =\n\t\t\t\t\t\tgridInfo.rect.top +\n\t\t\t\t\t\t(dragState.lastCell.row - 1) * cellHeight +\n\t\t\t\t\t\tgridInfo.cellHeight / 2;\n\n\t\t\t\t\t// Signed distance from card center to current cell center (in grid units)\n\t\t\t\t\t// Positive = card is to the right/below cell center\n\t\t\t\t\tconst offsetFromCellX = (cardCenterX - currentCellCenterX) / cellWidth;\n\t\t\t\t\tconst offsetFromCellY = (cardCenterY - currentCellCenterY) / cellHeight;\n\n\t\t\t\t\t// Direction-aware hysteresis:\n\t\t\t\t\t// - Lower threshold (0.5 = cell edge) when moving toward the new cell\n\t\t\t\t\t// - Higher threshold (0.5 + HYSTERESIS) when moving against direction\n\t\t\t\t\tconst movingRight = velocityX > 0;\n\t\t\t\t\tconst movingDown = velocityY > 0;\n\t\t\t\t\tconst cardRightOfCenter = offsetFromCellX > 0;\n\t\t\t\t\tconst cardBelowCenter = offsetFromCellY > 0;\n\n\t\t\t\t\t// Moving with the offset direction = predictive, use lower threshold\n\t\t\t\t\tconst movingWithX = (movingRight && cardRightOfCenter) || (!movingRight && !cardRightOfCenter);\n\t\t\t\t\tconst movingWithY = (movingDown && cardBelowCenter) || (!movingDown && !cardBelowCenter);\n\n\t\t\t\t\tconst thresholdX = movingWithX ? 0.5 : 0.5 + HYSTERESIS;\n\t\t\t\t\tconst thresholdY = movingWithY ? 0.5 : 0.5 + HYSTERESIS;\n\n\t\t\t\t\tconst distX = Math.abs(offsetFromCellX);\n\t\t\t\t\tconst distY = Math.abs(offsetFromCellY);\n\n\t\t\t\t\t// Only change if we've moved past the direction-adjusted threshold\n\t\t\t\t\tif (distX < thresholdX && distY < thresholdY) {\n\t\t\t\t\t\treturn; // Stay in current cell\n\t\t\t\t\t}\n\n\t\t\t\t\tlog('drag-move', {\n\t\t\t\t\t\tcell,\n\t\t\t\t\t\tdistX: distX.toFixed(2),\n\t\t\t\t\t\tdistY: distY.toFixed(2),\n\t\t\t\t\t\tthresholdX: thresholdX.toFixed(2),\n\t\t\t\t\t\tthresholdY: thresholdY.toFixed(2),\n\t\t\t\t\t\tvelocity: { x: velocityX.toFixed(1), y: velocityY.toFixed(1) },\n\t\t\t\t\t});\n\t\t\t\t\tdragState.lastCell = cell;\n\t\t\t\t\tdragState.lastTargetChangeTime = now;\n\t\t\t\t\tcore.emit('drag-move', { item, cell, x: e.clientX, y: e.clientY });\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst onPointerUp = (e: PointerEvent) => {\n\t\t\tif (!dragState) return;\n\n\t\t\tconst { item, initialRect, colspan, rowspan, lastCell } = dragState;\n\t\t\tconst rawCell = core.getCellFromPoint(e.clientX, e.clientY);\n\n\t\t\t// FLIP: Capture current visual position (First)\n\t\t\tconst firstRect = item.getBoundingClientRect();\n\n\t\t\t// Emit event BEFORE cleanup so algorithm can set final position\n\t\t\tif (rawCell) {\n\t\t\t\t// Clamp cell so item fits within grid bounds\n\t\t\t\tconst gridInfo = core.getGridInfo();\n\t\t\t\tconst maxColumn = Math.max(1, gridInfo.columns.length - colspan + 1);\n\t\t\t\tconst maxRow = Math.max(1, gridInfo.rows.length - rowspan + 1);\n\n\t\t\t\tconst cell: GridCell = {\n\t\t\t\t\tcolumn: Math.max(1, Math.min(maxColumn, rawCell.column)),\n\t\t\t\t\trow: Math.max(1, Math.min(maxRow, rawCell.row)),\n\t\t\t\t};\n\n\t\t\t\tlog('drag-end', { cell });\n\t\t\t\tcore.emit('drag-end', { item, cell });\n\t\t\t} else {\n\t\t\t\t// If pointer is outside grid, use last known valid cell position\n\t\t\t\tlog('drag-end', { cell: lastCell, note: 'using lastCell (pointer outside grid)' });\n\t\t\t\tcore.emit('drag-end', { item, cell: lastCell });\n\t\t\t}\n\n\t\t\t// Exclude from View Transitions - we'll animate via FLIP\n\t\t\titem.style.viewTransitionName = 'none';\n\n\t\t\tcleanup();\n\n\t\t\t// FLIP: Measure new position and animate (Last, Invert, Play)\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tconst lastRect = item.getBoundingClientRect();\n\t\t\t\tconst deltaX = firstRect.left - lastRect.left;\n\t\t\t\tconst deltaY = firstRect.top - lastRect.top;\n\n\t\t\t\tlog('FLIP', {\n\t\t\t\t\tfirst: { left: firstRect.left.toFixed(0), top: firstRect.top.toFixed(0) },\n\t\t\t\t\tlast: { left: lastRect.left.toFixed(0), top: lastRect.top.toFixed(0) },\n\t\t\t\t\tdelta: { x: deltaX.toFixed(0), y: deltaY.toFixed(0) },\n\t\t\t\t});\n\n\t\t\t\t// Only animate if there's movement\n\t\t\t\tif (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {\n\t\t\t\t\titem.setAttribute('data-gridiot-dropping', '');\n\n\t\t\t\t\tconst animation = item.animate(\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t{ transform: `translate(${deltaX}px, ${deltaY}px)` },\n\t\t\t\t\t\t\t{ transform: 'translate(0, 0)' },\n\t\t\t\t\t\t],\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tduration: 200,\n\t\t\t\t\t\t\teasing: 'cubic-bezier(0.2, 0, 0, 1)',\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\n\t\t\t\t\tanimation.onfinish = () => {\n\t\t\t\t\t\titem.removeAttribute('data-gridiot-dropping');\n\t\t\t\t\t\t// Restore view-transition-name for future transitions\n\t\t\t\t\t\tconst itemId =\n\t\t\t\t\t\t\titem.style.getPropertyValue('--item-id') || item.id || item.dataset.id;\n\t\t\t\t\t\tif (itemId) {\n\t\t\t\t\t\t\titem.style.viewTransitionName = itemId;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\t// No movement, just restore view-transition-name\n\t\t\t\t\tconst itemId =\n\t\t\t\t\t\titem.style.getPropertyValue('--item-id') || item.id || item.dataset.id;\n\t\t\t\t\tif (itemId) {\n\t\t\t\t\t\titem.style.viewTransitionName = itemId;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tconst onPointerCancel = () => {\n\t\t\tif (!dragState) return;\n\n\t\t\tconst { item } = dragState;\n\t\t\tcleanup();\n\t\t\tcore.emit('drag-cancel', { item });\n\t\t};\n\n\t\tconst cleanup = () => {\n\t\t\tif (!dragState) return;\n\n\t\t\tconst { item, pointerId } = dragState;\n\n\t\t\t// Reset visual styles\n\t\t\titem.removeAttribute('data-gridiot-dragging');\n\t\t\titem.style.position = '';\n\t\t\titem.style.left = '';\n\t\t\titem.style.top = '';\n\t\t\titem.style.width = '';\n\t\t\titem.style.height = '';\n\t\t\titem.style.zIndex = '';\n\n\t\t\titem.releasePointerCapture(pointerId);\n\t\t\titem.removeEventListener('pointermove', onPointerMove);\n\t\t\titem.removeEventListener('pointerup', onPointerUp);\n\t\t\titem.removeEventListener('pointercancel', onPointerCancel);\n\n\t\t\tdragState = null;\n\t\t};\n\n\t\tcore.element.addEventListener('pointerdown', onPointerDown);\n\t\treturn () => {\n\t\t\tcore.element.removeEventListener('pointerdown', onPointerDown);\n\t\t\tif (dragState) cleanup();\n\t\t};\n\t},\n});\n"],
  "mappings": "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",
  "names": []
}
