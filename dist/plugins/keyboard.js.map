{
  "version": 3,
  "sources": ["../../engine.ts", "../../plugins/keyboard.ts"],
  "sourcesContent": ["import type { GridCell, GridiotCore, Plugin } from './types';\n\n// Global plugin registry\nconst plugins = new Map<string, Plugin>();\n\nexport function registerPlugin(plugin: Plugin): void {\n\tplugins.set(plugin.name, plugin);\n}\n\nexport function getPlugin(name: string): Plugin | undefined {\n\treturn plugins.get(name);\n}\n\n/**\n * Initialize Gridiot on a CSS Grid element\n */\nexport function init(element: HTMLElement): GridiotCore {\n\tconst cleanups: (() => void)[] = [];\n\n\tlet selectedItem: HTMLElement | null = null;\n\n\tconst core: GridiotCore = {\n\t\telement,\n\n\t\t// Selection state\n\t\tget selectedItem() {\n\t\t\treturn selectedItem;\n\t\t},\n\t\tset selectedItem(item: HTMLElement | null) {\n\t\t\tthis.select(item);\n\t\t},\n\n\t\tselect(item: HTMLElement | null): void {\n\t\t\tif (item === selectedItem) return;\n\n\t\t\tconst previousItem = selectedItem;\n\n\t\t\t// Remove selection from previous item\n\t\t\tif (previousItem) {\n\t\t\t\tpreviousItem.removeAttribute('data-gridiot-selected');\n\t\t\t}\n\n\t\t\t// Set new selection\n\t\t\tselectedItem = item;\n\n\t\t\tif (item) {\n\t\t\t\titem.setAttribute('data-gridiot-selected', '');\n\t\t\t\tthis.emit('select', { item });\n\t\t\t} else if (previousItem) {\n\t\t\t\tthis.emit('deselect', { item: previousItem });\n\t\t\t}\n\t\t},\n\n\t\tdeselect(): void {\n\t\t\tthis.select(null);\n\t\t},\n\n\t\tgetCellFromPoint(x: number, y: number): GridCell | null {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\tconst relX = x - rect.left + element.scrollLeft;\n\t\t\tconst relY = y - rect.top + element.scrollTop;\n\n\t\t\tconst column = getGridIndex(relX, columns, columnGap);\n\t\t\tconst row = getGridIndex(relY, rows, rowGap);\n\n\t\t\treturn { column, row };\n\t\t},\n\n\t\temit<T>(event: string, detail: T): void {\n\t\t\telement.dispatchEvent(\n\t\t\t\tnew CustomEvent(`gridiot:${event}`, {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tdetail,\n\t\t\t\t}),\n\t\t\t);\n\t\t},\n\n\t\tgetGridInfo() {\n\t\t\tconst rect = element.getBoundingClientRect();\n\t\t\tconst style = getComputedStyle(element);\n\t\t\tconst columns = parseGridTemplate(style.gridTemplateColumns);\n\t\t\tconst rows = parseGridTemplate(style.gridTemplateRows);\n\t\t\tconst columnGap = parseFloat(style.columnGap) || 0;\n\t\t\tconst rowGap = parseFloat(style.rowGap) || 0;\n\n\t\t\treturn {\n\t\t\t\trect,\n\t\t\t\tcolumns,\n\t\t\t\trows,\n\t\t\t\tgap: columnGap, // Assume uniform gap for simplicity\n\t\t\t\tcellWidth: columns[0] || 0,\n\t\t\t\tcellHeight: rows[0] || 0,\n\t\t\t};\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tobserver.disconnect();\n\t\t\tcleanups.forEach((cleanup) => cleanup());\n\t\t},\n\t};\n\n\t// Observe position changes and animate with View Transitions\n\tconst observer = new MutationObserver((mutations) => {\n\t\t// Collect items that changed position\n\t\tconst changedItems = new Set<HTMLElement>();\n\n\t\tfor (const mutation of mutations) {\n\t\t\tif (\n\t\t\t\tmutation.type === 'attributes' &&\n\t\t\t\tmutation.target instanceof HTMLElement\n\t\t\t) {\n\t\t\t\tconst item = mutation.target.closest(\n\t\t\t\t\t'[data-gridiot-item]',\n\t\t\t\t) as HTMLElement | null;\n\t\t\t\tif (item && element.contains(item)) {\n\t\t\t\t\tchangedItems.add(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Animate changes with View Transitions if available\n\t\tif (changedItems.size > 0 && 'startViewTransition' in document) {\n\t\t\t// Items already moved - View Transitions will handle animation\n\t\t\t// The browser captures before/after states automatically\n\t\t}\n\t});\n\n\tobserver.observe(element, {\n\t\tsubtree: true,\n\t\tattributes: true,\n\t\tattributeFilter: ['style', 'class'],\n\t});\n\n\t// Initialize all registered plugins\n\tfor (const plugin of plugins.values()) {\n\t\tconst cleanup = plugin.init(core);\n\t\tif (cleanup) {\n\t\t\tcleanups.push(cleanup);\n\t\t}\n\t}\n\n\treturn core;\n}\n\n/**\n * Parse CSS grid-template-columns/rows into pixel values\n */\nfunction parseGridTemplate(template: string): number[] {\n\t// Handle common cases: px values, fr units resolved to px\n\t// getComputedStyle returns resolved pixel values\n\tconst values = template.split(' ').filter(Boolean);\n\treturn values.map((v) => parseFloat(v) || 0);\n}\n\n/**\n * Get 1-based grid index from pixel position\n * The gap between cells is split at the midpoint - first half belongs to\n * the left/top cell, second half belongs to the right/bottom cell.\n * This makes cell detection symmetric for both directions.\n */\nfunction getGridIndex(pos: number, tracks: number[], gap: number): number {\n\tlet accumulated = 0;\n\tconst halfGap = gap / 2;\n\n\tfor (let i = 0; i < tracks.length; i++) {\n\t\tconst track = tracks[i]!;\n\t\t// Cell boundary extends to the midpoint of the gap\n\t\tconst trackEnd = accumulated + track + halfGap;\n\t\tif (pos <= trackEnd) {\n\t\t\treturn i + 1; // CSS Grid is 1-indexed\n\t\t}\n\t\taccumulated += track + gap;\n\t}\n\n\treturn tracks.length || 1; // Default to last track, or 1 if empty\n}\n\n/**\n * Get the current grid cell of an item\n */\nexport function getItemCell(item: HTMLElement): GridCell {\n\tconst style = getComputedStyle(item);\n\treturn {\n\t\tcolumn: parseInt(style.gridColumnStart, 10) || 1,\n\t\trow: parseInt(style.gridRowStart, 10) || 1,\n\t};\n}\n\n/**\n * Set an item's grid position\n */\nexport function setItemCell(item: HTMLElement, cell: GridCell): void {\n\titem.style.gridColumn = String(cell.column);\n\titem.style.gridRow = String(cell.row);\n}\n", "import { getItemCell, registerPlugin } from '../engine';\nimport type { GridCell } from '../types';\n\nconst DEBUG = false;\nfunction log(...args: unknown[]) {\n\tif (DEBUG) console.log('[keyboard]', ...args);\n}\n\nregisterPlugin({\n\tname: 'keyboard',\n\tinit(core) {\n\t\tlet keyboardMode = false;\n\t\tlet heldItem: HTMLElement | null = null;\n\n\t\t/**\n\t\t * Get direction from key, supporting both arrows and vim-style hjkl\n\t\t */\n\t\tconst getDirection = (\n\t\t\tkey: string,\n\t\t): 'up' | 'down' | 'left' | 'right' | null => {\n\t\t\tswitch (key) {\n\t\t\t\tcase 'ArrowUp':\n\t\t\t\tcase 'k':\n\t\t\t\t\treturn 'up';\n\t\t\t\tcase 'ArrowDown':\n\t\t\t\tcase 'j':\n\t\t\t\t\treturn 'down';\n\t\t\t\tcase 'ArrowLeft':\n\t\t\t\tcase 'h':\n\t\t\t\t\treturn 'left';\n\t\t\t\tcase 'ArrowRight':\n\t\t\t\tcase 'l':\n\t\t\t\t\treturn 'right';\n\t\t\t\tdefault:\n\t\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Get adjacent cell in a direction\n\t\t */\n\t\tconst getAdjacentCell = (\n\t\t\tcell: GridCell,\n\t\t\tdirection: 'up' | 'down' | 'left' | 'right',\n\t\t\tamount = 1,\n\t\t): GridCell => {\n\t\t\tswitch (direction) {\n\t\t\t\tcase 'up':\n\t\t\t\t\treturn { ...cell, row: Math.max(1, cell.row - amount) };\n\t\t\t\tcase 'down':\n\t\t\t\t\treturn { ...cell, row: cell.row + amount };\n\t\t\t\tcase 'left':\n\t\t\t\t\treturn { ...cell, column: Math.max(1, cell.column - amount) };\n\t\t\t\tcase 'right':\n\t\t\t\t\treturn { ...cell, column: cell.column + amount };\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Find the item at or closest to a cell position in a direction\n\t\t */\n\t\tconst findItemInDirection = (\n\t\t\tfromCell: GridCell,\n\t\t\tdirection: 'up' | 'down' | 'left' | 'right',\n\t\t\texcludeItem: HTMLElement,\n\t\t): HTMLElement | null => {\n\t\t\tconst items = Array.from(\n\t\t\t\tcore.element.querySelectorAll('[data-gridiot-item]'),\n\t\t\t) as HTMLElement[];\n\n\t\t\tlet bestItem: HTMLElement | null = null;\n\t\t\tlet bestDistance = Infinity;\n\n\t\t\tfor (const item of items) {\n\t\t\t\tif (item === excludeItem) continue;\n\n\t\t\t\tconst cell = getItemCell(item);\n\t\t\t\tlet distance: number;\n\t\t\t\tlet isInDirection: boolean;\n\n\t\t\t\tswitch (direction) {\n\t\t\t\t\tcase 'up':\n\t\t\t\t\t\tisInDirection = cell.row < fromCell.row;\n\t\t\t\t\t\tdistance = fromCell.row - cell.row + Math.abs(cell.column - fromCell.column) * 0.1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'down':\n\t\t\t\t\t\tisInDirection = cell.row > fromCell.row;\n\t\t\t\t\t\tdistance = cell.row - fromCell.row + Math.abs(cell.column - fromCell.column) * 0.1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'left':\n\t\t\t\t\t\tisInDirection = cell.column < fromCell.column;\n\t\t\t\t\t\tdistance = fromCell.column - cell.column + Math.abs(cell.row - fromCell.row) * 0.1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'right':\n\t\t\t\t\t\tisInDirection = cell.column > fromCell.column;\n\t\t\t\t\t\tdistance = cell.column - fromCell.column + Math.abs(cell.row - fromCell.row) * 0.1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isInDirection && distance < bestDistance) {\n\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\tbestItem = item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn bestItem;\n\t\t};\n\n\t\t/**\n\t\t * Get the size of an item for jump calculations\n\t\t */\n\t\tconst getItemSize = (item: HTMLElement): { colspan: number; rowspan: number } => {\n\t\t\treturn {\n\t\t\t\tcolspan: parseInt(item.getAttribute('data-gridiot-colspan') || '1', 10) || 1,\n\t\t\t\trowspan: parseInt(item.getAttribute('data-gridiot-rowspan') || '1', 10) || 1,\n\t\t\t};\n\t\t};\n\n\t\tconst onKeyDown = (e: KeyboardEvent) => {\n\t\t\t// Toggle keyboard mode with Shift+K\n\t\t\tif (e.key === 'K' && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {\n\t\t\t\te.preventDefault();\n\t\t\t\tkeyboardMode = !keyboardMode;\n\t\t\t\tlog('keyboard mode:', keyboardMode);\n\n\t\t\t\tif (keyboardMode) {\n\t\t\t\t\tcore.element.setAttribute('data-gridiot-keyboard-mode', '');\n\t\t\t\t\t// If no item is selected, select the first one\n\t\t\t\t\tif (!core.selectedItem) {\n\t\t\t\t\t\tconst firstItem = core.element.querySelector('[data-gridiot-item]') as HTMLElement | null;\n\t\t\t\t\t\tif (firstItem) {\n\t\t\t\t\t\t\tcore.select(firstItem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcore.element.removeAttribute('data-gridiot-keyboard-mode');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// All other keyboard shortcuts require keyboard mode, selected item, or focus inside grid\n\t\t\tconst focused = document.activeElement as HTMLElement | null;\n\t\t\tconst focusInGrid = focused && core.element.contains(focused);\n\t\t\tconst hasSelection = core.selectedItem !== null;\n\t\t\tif (!keyboardMode && !focusInGrid && !hasSelection) return;\n\n\t\t\tconst selectedItem = core.selectedItem;\n\t\t\tconst direction = getDirection(e.key);\n\n\t\t\t// Cancel drag or deselect with Escape\n\t\t\tif (e.key === 'Escape') {\n\t\t\t\te.preventDefault();\n\t\t\t\tif (heldItem) {\n\t\t\t\t\theldItem.removeAttribute('data-gridiot-dragging');\n\t\t\t\t\tcore.emit('drag-cancel', { item: heldItem });\n\t\t\t\t\theldItem = null;\n\t\t\t\t} else if (selectedItem) {\n\t\t\t\t\tcore.deselect();\n\t\t\t\t}\n\t\t\t\tkeyboardMode = false;\n\t\t\t\tcore.element.removeAttribute('data-gridiot-keyboard-mode');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Pick up / drop with Enter or Space\n\t\t\tif (e.key === 'Enter' || e.key === ' ') {\n\t\t\t\tif (!selectedItem) return;\n\t\t\t\te.preventDefault();\n\n\t\t\t\tif (heldItem) {\n\t\t\t\t\t// Drop the held item\n\t\t\t\t\tconst cell = getItemCell(heldItem);\n\t\t\t\t\tconst size = getItemSize(heldItem);\n\t\t\t\t\theldItem.removeAttribute('data-gridiot-dragging');\n\t\t\t\t\tcore.emit('drag-end', { item: heldItem, cell, colspan: size.colspan, rowspan: size.rowspan });\n\t\t\t\t\tlog('drop', { cell });\n\t\t\t\t\theldItem = null;\n\t\t\t\t} else {\n\t\t\t\t\t// Pick up the selected item\n\t\t\t\t\theldItem = selectedItem;\n\t\t\t\t\tconst size = getItemSize(heldItem);\n\t\t\t\t\theldItem.setAttribute('data-gridiot-dragging', '');\n\t\t\t\t\tcore.emit('drag-start', { item: heldItem, cell: getItemCell(heldItem), colspan: size.colspan, rowspan: size.rowspan });\n\t\t\t\t\tlog('pick up');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Navigation keys\n\t\t\tif (direction) {\n\t\t\t\te.preventDefault();\n\n\t\t\t\t// Alt+nav: Select adjacent item\n\t\t\t\tif (e.altKey && !e.ctrlKey && selectedItem) {\n\t\t\t\t\tconst fromCell = getItemCell(selectedItem);\n\t\t\t\t\tconst adjacentItem = findItemInDirection(fromCell, direction, selectedItem);\n\t\t\t\t\tif (adjacentItem) {\n\t\t\t\t\t\tcore.select(adjacentItem);\n\t\t\t\t\t\tlog('select adjacent', direction);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Must have a selected item for other nav actions\n\t\t\t\tif (!selectedItem) return;\n\n\t\t\t\tconst currentCell = getItemCell(selectedItem);\n\t\t\t\tconst itemSize = getItemSize(selectedItem);\n\t\t\t\tconst gridInfo = core.getGridInfo();\n\n\t\t\t\t// Calculate move amount\n\t\t\t\tlet amount = 1;\n\t\t\t\tif (e.ctrlKey || e.metaKey) {\n\t\t\t\t\t// Ctrl+nav: Jump by item size\n\t\t\t\t\tamount = direction === 'up' || direction === 'down'\n\t\t\t\t\t\t? itemSize.rowspan\n\t\t\t\t\t\t: itemSize.colspan;\n\t\t\t\t}\n\n\t\t\t\tconst rawCell = getAdjacentCell(currentCell, direction, amount);\n\n\t\t\t\t// Clamp cell so item fits within grid bounds\n\t\t\t\tconst maxColumn = Math.max(1, gridInfo.columns.length - itemSize.colspan + 1);\n\t\t\t\tconst maxRow = Math.max(1, gridInfo.rows.length - itemSize.rowspan + 1);\n\t\t\t\tconst targetCell = {\n\t\t\t\t\tcolumn: Math.max(1, Math.min(maxColumn, rawCell.column)),\n\t\t\t\t\trow: Math.max(1, Math.min(maxRow, rawCell.row)),\n\t\t\t\t};\n\n\t\t\t\t// Skip if clamped position is same as current (at edge, can't move further)\n\t\t\t\tif (targetCell.column === currentCell.column && targetCell.row === currentCell.row) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (heldItem) {\n\t\t\t\t\t// Moving a held item\n\t\t\t\t\tcore.emit('drag-move', { item: heldItem, cell: targetCell, x: 0, y: 0, colspan: itemSize.colspan, rowspan: itemSize.rowspan });\n\t\t\t\t\tlog('move', { direction, amount, targetCell });\n\t\t\t\t} else {\n\t\t\t\t\t// Nudge: Move item directly\n\t\t\t\t\t// Emit drag-start then drag-end (skip drag-move since we don't need preview)\n\t\t\t\t\tcore.emit('drag-start', { item: selectedItem, cell: currentCell, colspan: itemSize.colspan, rowspan: itemSize.rowspan });\n\t\t\t\t\tcore.emit('drag-end', { item: selectedItem, cell: targetCell, colspan: itemSize.colspan, rowspan: itemSize.rowspan });\n\t\t\t\t\tlog('nudge', { direction, amount, targetCell });\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t};\n\n\t\tdocument.addEventListener('keydown', onKeyDown);\n\n\t\treturn () => {\n\t\t\tdocument.removeEventListener('keydown', onKeyDown);\n\t\t\tcore.element.removeAttribute('data-gridiot-keyboard-mode');\n\t\t};\n\t},\n});\n"],
  "mappings": "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",
  "names": []
}
