{
  "version": 3,
  "sources": ["../../plugins/algorithm-push-core.ts", "../../plugins/algorithm-push.ts"],
  "sourcesContent": ["/**\n * Pure push-down layout algorithm - no DOM dependencies\n * This module contains the core layout logic that can be tested independently.\n */\n\nexport interface GridCell {\n\tcolumn: number;\n\trow: number;\n}\n\nexport interface ItemRect {\n\tid: string;\n\tcolumn: number;\n\trow: number;\n\twidth: number;\n\theight: number;\n}\n\n/**\n * Check if two items overlap\n */\nexport function itemsOverlap(a: ItemRect, b: ItemRect): boolean {\n\treturn !(\n\t\ta.column + a.width <= b.column ||\n\t\tb.column + b.width <= a.column ||\n\t\ta.row + a.height <= b.row ||\n\t\tb.row + b.height <= a.row\n\t);\n}\n\n/**\n * Check if any items in the layout overlap\n * @returns Array of overlapping pairs, empty if no overlaps\n */\nexport function findOverlaps(items: ItemRect[]): Array<[ItemRect, ItemRect]> {\n\tconst overlaps: Array<[ItemRect, ItemRect]> = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tfor (let j = i + 1; j < items.length; j++) {\n\t\t\tif (itemsOverlap(items[i], items[j])) {\n\t\t\t\toverlaps.push([items[i], items[j]]);\n\t\t\t}\n\t\t}\n\t}\n\treturn overlaps;\n}\n\n/**\n * Push items down recursively to resolve collisions\n * Mutates the items array in place\n */\nexport function pushDown(\n\titems: ItemRect[],\n\tmoved: ItemRect,\n\tmovedId: string,\n\tdepth = 0,\n): void {\n\tif (depth > 50) {\n\t\treturn;\n\t}\n\n\t// Sort by row descending - push bottom items first so upper items settle on top\n\t// This preserves the original relative ordering of items\n\tconst colliders = items\n\t\t.filter((it) => it.id !== movedId && it.id !== moved.id && itemsOverlap(moved, it))\n\t\t.sort((a, b) => b.row - a.row || a.column - b.column);\n\n\tfor (const collider of colliders) {\n\t\tconst newRow = moved.row + moved.height;\n\t\tif (collider.row < newRow) {\n\t\t\tcollider.row = newRow;\n\t\t\tpushDown(items, collider, movedId, depth + 1);\n\t\t}\n\t}\n}\n\n/**\n * Compact items upward to fill gaps\n * Mutates the items array in place\n */\nexport function compactUp(items: ItemRect[], excludeId: string): void {\n\tconst sorted = [...items]\n\t\t.filter((it) => it.id !== excludeId)\n\t\t.sort((a, b) => a.row - b.row || a.column - b.column);\n\n\tfor (const item of sorted) {\n\t\tlet iterations = 0;\n\t\twhile (item.row > 1 && iterations < 100) {\n\t\t\titerations++;\n\t\t\titem.row -= 1;\n\t\t\tconst hasCollision = items.some(\n\t\t\t\t(other) => other.id !== item.id && itemsOverlap(item, other),\n\t\t\t);\n\t\t\tif (hasCollision) {\n\t\t\t\titem.row += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Calculate new layout after moving an item\n * Returns a new array with updated positions\n */\nexport function calculateLayout(\n\titems: ItemRect[],\n\tmovedId: string,\n\ttargetCell: GridCell,\n): ItemRect[] {\n\t// Deep copy items\n\tconst result = items.map((item) => ({ ...item }));\n\n\tconst movedItem = result.find((it) => it.id === movedId);\n\tif (!movedItem) return result;\n\n\tmovedItem.column = targetCell.column;\n\tmovedItem.row = targetCell.row;\n\n\tpushDown(result, movedItem, movedId);\n\tcompactUp(result, movedId);\n\n\treturn result;\n}\n\n/**\n * Options for CSS generation\n */\nexport interface LayoutToCSSOptions {\n\t/**\n\t * CSS selector prefix for items (default: '#')\n\t * Use '#' for id selectors, '.' for class selectors, or '[data-id=\"' for attribute selectors\n\t */\n\tselectorPrefix?: string;\n\t/**\n\t * CSS selector suffix for items (default: '')\n\t * Use ']' to close attribute selectors\n\t */\n\tselectorSuffix?: string;\n\t/**\n\t * Additional selector to exclude (e.g., ':not(.dragging)')\n\t */\n\texcludeSelector?: string;\n\t/**\n\t * Maximum column count for width clamping (optional)\n\t */\n\tmaxColumns?: number;\n}\n\n/**\n * Convert layout to CSS rules for injection into a <style> tag.\n * This enables the \"CSS-driven layout\" pattern where:\n * 1. Algorithm returns pure ItemRect[] data\n * 2. Caller converts to CSS string\n * 3. CSS injected into <style> tag\n * 4. View Transitions animate the change\n *\n * @param items - The layout items with positions\n * @param options - CSS generation options\n * @returns CSS rules string ready for injection\n *\n * @example\n * // Basic usage with id selectors\n * const css = layoutToCSS(items);\n * styleElement.textContent = css;\n *\n * @example\n * // During drag, exclude the dragging item\n * const css = layoutToCSS(items, { excludeSelector: ':not(.dragging)' });\n *\n * @example\n * // With data-id attribute selectors\n * const css = layoutToCSS(items, {\n *   selectorPrefix: '[data-id=\"',\n *   selectorSuffix: '\"]'\n * });\n */\nexport function layoutToCSS(\n\titems: ItemRect[],\n\toptions: LayoutToCSSOptions = {},\n): string {\n\tconst {\n\t\tselectorPrefix = '#',\n\t\tselectorSuffix = '',\n\t\texcludeSelector = '',\n\t\tmaxColumns,\n\t} = options;\n\n\tconst rules: string[] = [];\n\n\tfor (const item of items) {\n\t\tconst width = maxColumns ? Math.min(item.width, maxColumns) : item.width;\n\t\tconst selector = `${selectorPrefix}${item.id}${selectorSuffix}${excludeSelector}`;\n\t\tconst gridColumn = `${item.column} / span ${width}`;\n\t\tconst gridRow = `${item.row} / span ${item.height}`;\n\n\t\trules.push(`${selector} { grid-column: ${gridColumn}; grid-row: ${gridRow}; }`);\n\t}\n\n\treturn rules.join('\\n');\n}\n", "/**\n * Push-down layout algorithm for Gridiot\n *\n * This module provides both:\n * 1. Pure algorithm functions (re-exported from algorithm-push-core)\n * 2. DOM integration helper for attaching the algorithm to a grid element\n *\n * Usage (pure functions):\n *   import { calculateLayout, layoutToCSS } from 'gridiot/algorithm-push';\n *   const newLayout = calculateLayout(items, movedId, targetCell);\n *   styleElement.textContent = layoutToCSS(newLayout);\n *\n * Usage (DOM integration):\n *   import { init } from 'gridiot';\n *   import { attachPushAlgorithm } from 'gridiot/algorithm-push';\n *\n *   const grid = init(element);\n *   const detach = attachPushAlgorithm(grid.element);\n */\n\n// Re-export pure algorithm functions\nexport {\n\tcalculateLayout,\n\tcompactUp,\n\tfindOverlaps,\n\titemsOverlap,\n\tlayoutToCSS,\n\tpushDown,\n\ttype GridCell,\n\ttype ItemRect,\n\ttype LayoutToCSSOptions,\n} from './algorithm-push-core';\n\nimport type {\n\tDragCancelDetail,\n\tDragEndDetail,\n\tDragMoveDetail,\n\tDragStartDetail,\n\tGridCell,\n} from '../types';\n\nimport {\n\tcalculateLayout,\n\tlayoutToCSS,\n\ttype ItemRect,\n} from './algorithm-push-core';\n\nconst DEBUG = false;\nfunction log(...args: unknown[]) {\n\tif (DEBUG) console.log('[algorithm-push]', ...args);\n}\n\n/**\n * Read item positions from DOM elements\n */\nexport function readItemsFromDOM(container: HTMLElement): ItemRect[] {\n\tconst elements = container.querySelectorAll('[data-gridiot-item]');\n\treturn Array.from(elements).map((el) => {\n\t\tconst element = el as HTMLElement;\n\t\tconst style = getComputedStyle(element);\n\t\tconst column = parseInt(style.gridColumnStart, 10) || 1;\n\t\tconst row = parseInt(style.gridRowStart, 10) || 1;\n\t\tconst width =\n\t\t\tparseInt(element.getAttribute('data-gridiot-colspan') || '1', 10) || 1;\n\t\tconst height =\n\t\t\tparseInt(element.getAttribute('data-gridiot-rowspan') || '1', 10) || 1;\n\t\tconst id = element.dataset.id || element.dataset.gridiotItem || '';\n\n\t\treturn { id, column, row, width, height };\n\t});\n}\n\n/**\n * Options for attachPushAlgorithm\n */\nexport interface AttachPushAlgorithmOptions {\n\t/**\n\t * Style element to inject layout CSS into.\n\t * If not provided, positions are applied directly to element.style\n\t */\n\tstyleElement?: HTMLStyleElement;\n\t/**\n\t * CSS selector options for layoutToCSS\n\t */\n\tselectorPrefix?: string;\n\tselectorSuffix?: string;\n}\n\n/**\n * Attach push-down algorithm to a grid element.\n *\n * This creates event listeners for gridiot drag events and updates\n * the layout when items are moved. Layout changes are animated\n * via View Transitions.\n *\n * @param gridElement - The grid container element\n * @param options - Configuration options\n * @returns Cleanup function to detach the algorithm\n */\nexport function attachPushAlgorithm(\n\tgridElement: HTMLElement,\n\toptions: AttachPushAlgorithmOptions = {},\n): () => void {\n\tconst { styleElement, selectorPrefix = '#', selectorSuffix = '' } = options;\n\n\tlet originalPositions: Map<string, { column: number; row: number }> | null =\n\t\tnull;\n\tlet draggedItemId: string | null = null;\n\tlet draggedElement: HTMLElement | null = null;\n\tlet layoutVersion = 0; // Prevent stale async view transitions from overwriting newer layouts\n\n\tfunction getItemId(element: HTMLElement): string {\n\t\treturn element.dataset.id || element.dataset.gridiotItem || '';\n\t}\n\n\tfunction setItemCell(item: HTMLElement, cell: GridCell): void {\n\t\tconst colspan =\n\t\t\tparseInt(item.getAttribute('data-gridiot-colspan') || '1', 10) || 1;\n\t\tconst rowspan =\n\t\t\tparseInt(item.getAttribute('data-gridiot-rowspan') || '1', 10) || 1;\n\t\tconst colValue = `${cell.column} / span ${colspan}`;\n\t\tconst rowValue = `${cell.row} / span ${rowspan}`;\n\t\tlog('setItemCell', { id: getItemId(item), colValue, rowValue });\n\t\titem.style.gridColumn = colValue;\n\t\titem.style.gridRow = rowValue;\n\t}\n\n\tfunction applyLayout(\n\t\tlayout: ItemRect[],\n\t\texcludeId: string | null,\n\t\tuseViewTransition: boolean,\n\t): void {\n\t\t// Increment version to invalidate any pending async transitions\n\t\tconst thisVersion = ++layoutVersion;\n\n\t\tconst applyChanges = () => {\n\t\t\t// Skip if a newer layout has been applied (stale async view transition)\n\t\t\tif (thisVersion !== layoutVersion) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (styleElement) {\n\t\t\t\t// CSS injection mode - preferred\n\t\t\t\t// Filter out the excluded item (being dragged) from CSS generation\n\t\t\t\tconst itemsToStyle = excludeId\n\t\t\t\t\t? layout.filter((item) => item.id !== excludeId)\n\t\t\t\t\t: layout;\n\t\t\t\tconst css = layoutToCSS(itemsToStyle, {\n\t\t\t\t\tselectorPrefix,\n\t\t\t\t\tselectorSuffix,\n\t\t\t\t});\n\t\t\t\tstyleElement.textContent = css;\n\n\t\t\t\t// Clear inline grid styles so CSS rules take effect\n\t\t\t\t// (inline styles have higher specificity than stylesheet rules)\n\t\t\t\tconst elements = gridElement.querySelectorAll('[data-gridiot-item]');\n\t\t\t\tfor (const el of elements) {\n\t\t\t\t\tconst element = el as HTMLElement;\n\t\t\t\t\tconst id = getItemId(element);\n\t\t\t\t\tif (id !== excludeId) {\n\t\t\t\t\t\telement.style.gridColumn = '';\n\t\t\t\t\t\telement.style.gridRow = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Direct style mutation mode - fallback\n\t\t\t\tconst elements = gridElement.querySelectorAll('[data-gridiot-item]');\n\t\t\t\tfor (const el of elements) {\n\t\t\t\t\tconst element = el as HTMLElement;\n\t\t\t\t\tconst id = getItemId(element);\n\t\t\t\t\tif (id === excludeId) continue;\n\n\t\t\t\t\tconst item = layout.find((it) => it.id === id);\n\t\t\t\t\tif (item) {\n\t\t\t\t\t\tsetItemCell(element, { column: item.column, row: item.row });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif (useViewTransition && 'startViewTransition' in document) {\n\t\t\tlog('starting view transition, excludeId:', excludeId);\n\t\t\t// Only suppress animation for item being pointer-dragged (not keyboard nudges)\n\t\t\t// During pointer drag, excludeId is set; during keyboard nudge or final drop, it's null\n\t\t\tif (draggedElement && excludeId) {\n\t\t\t\tdraggedElement.style.viewTransitionName = 'dragging';\n\t\t\t}\n\t\t\t(document as any).startViewTransition(applyChanges);\n\t\t} else {\n\t\t\tlog('applying without view transition');\n\t\t\tapplyChanges();\n\t\t}\n\t}\n\n\tconst onDragStart = (e: Event) => {\n\t\tconst detail = (e as CustomEvent<DragStartDetail>).detail;\n\t\tdraggedElement = detail.item;\n\t\tdraggedItemId = getItemId(detail.item);\n\n\t\t// Store original positions to reset from during drag\n\t\tconst items = readItemsFromDOM(gridElement);\n\t\toriginalPositions = new Map();\n\t\tfor (const item of items) {\n\t\t\toriginalPositions.set(item.id, { column: item.column, row: item.row });\n\t\t}\n\n\t\t// In CSS injection mode, clear inline styles so CSS rules take effect\n\t\tif (styleElement) {\n\t\t\tconst elements = gridElement.querySelectorAll('[data-gridiot-item]');\n\t\t\tfor (const el of elements) {\n\t\t\t\tconst element = el as HTMLElement;\n\t\t\t\tif (element !== draggedElement) {\n\t\t\t\t\telement.style.gridColumn = '';\n\t\t\t\t\telement.style.gridRow = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Generate initial CSS for current positions\n\t\t\tconst css = layoutToCSS(items, { selectorPrefix, selectorSuffix });\n\t\t\tstyleElement.textContent = css;\n\t\t}\n\n\t\tlog('drag-start', {\n\t\t\titem: draggedItemId,\n\t\t\tpositions: Array.from(originalPositions.entries()),\n\t\t});\n\t};\n\n\tconst onDragMove = (e: Event) => {\n\t\tif (!draggedItemId || !originalPositions) return;\n\t\tconst detail = (e as CustomEvent<DragMoveDetail>).detail;\n\n\t\t// Build items array from original positions\n\t\tconst items: ItemRect[] = readItemsFromDOM(gridElement).map((item) => {\n\t\t\tconst original = originalPositions!.get(item.id);\n\t\t\tif (original && item.id !== draggedItemId) {\n\t\t\t\treturn { ...item, column: original.column, row: original.row };\n\t\t\t}\n\t\t\treturn item;\n\t\t});\n\n\t\tlog('drag-move', { targetCell: detail.cell });\n\t\tconst newLayout = calculateLayout(items, draggedItemId, detail.cell);\n\t\tlog(\n\t\t\t'calculated layout',\n\t\t\tnewLayout.map((it) => ({ id: it.id, col: it.column, row: it.row })),\n\t\t);\n\t\tapplyLayout(newLayout, draggedItemId, true);\n\t};\n\n\tconst onDragEnd = (e: Event) => {\n\t\tif (!draggedItemId || !originalPositions) return;\n\t\tconst detail = (e as CustomEvent<DragEndDetail>).detail;\n\n\t\tlog('drag-end', { finalCell: detail.cell });\n\n\t\t// Build items array from original positions\n\t\tconst items: ItemRect[] = readItemsFromDOM(gridElement).map((item) => {\n\t\t\tconst original = originalPositions!.get(item.id);\n\t\t\tif (original && item.id !== draggedItemId) {\n\t\t\t\treturn { ...item, column: original.column, row: original.row };\n\t\t\t}\n\t\t\treturn item;\n\t\t});\n\n\t\tconst finalLayout = calculateLayout(items, draggedItemId, detail.cell);\n\t\tlog(\n\t\t\t'final layout',\n\t\t\tfinalLayout.map((it) => ({ id: it.id, col: it.column, row: it.row })),\n\t\t);\n\n\t\t// Check if this is a pointer drag (item is in fixed position) or keyboard nudge\n\t\tconst isPointerDrag = draggedElement?.style.position === 'fixed';\n\t\tlog('drag-end isPointerDrag:', isPointerDrag, 'position:', draggedElement?.style.position);\n\n\t\t// Clear the 'dragging' viewTransitionName only if it was set (during pointer drag)\n\t\t// Don't clear for keyboard nudges - they need the CSS view-transition-name to animate\n\t\tif (draggedElement && draggedElement.style.viewTransitionName === 'dragging') {\n\t\t\tdraggedElement.style.viewTransitionName = '';\n\t\t}\n\n\t\t// For pointer drags, apply synchronously (pointer's FLIP animates the dropped item)\n\t\t// For keyboard nudges, use view transitions to animate\n\t\tconst useViewTransition = !isPointerDrag;\n\t\tlog('drag-end useViewTransition:', useViewTransition);\n\t\tapplyLayout(finalLayout, null, useViewTransition);\n\n\t\tdraggedItemId = null;\n\t\tdraggedElement = null;\n\t\toriginalPositions = null;\n\t};\n\n\tconst onDragCancel = () => {\n\t\tif (!draggedItemId || !originalPositions) return;\n\n\t\t// Clear the 'dragging' viewTransitionName only if it was set (during pointer drag)\n\t\tif (draggedElement && draggedElement.style.viewTransitionName === 'dragging') {\n\t\t\tdraggedElement.style.viewTransitionName = '';\n\t\t}\n\n\t\t// Restore original positions\n\t\tconst restoreLayout: ItemRect[] = readItemsFromDOM(gridElement).map(\n\t\t\t(item) => {\n\t\t\t\tconst original = originalPositions!.get(item.id);\n\t\t\t\tif (original) {\n\t\t\t\t\treturn { ...item, column: original.column, row: original.row };\n\t\t\t\t}\n\t\t\t\treturn item;\n\t\t\t},\n\t\t);\n\n\t\tconst restore = () => {\n\t\t\tapplyLayout(restoreLayout, null, false);\n\t\t};\n\n\t\tif ('startViewTransition' in document) {\n\t\t\t(document as any).startViewTransition(restore);\n\t\t} else {\n\t\t\trestore();\n\t\t}\n\n\t\tdraggedItemId = null;\n\t\tdraggedElement = null;\n\t\toriginalPositions = null;\n\t};\n\n\tgridElement.addEventListener('gridiot:drag-start', onDragStart);\n\tgridElement.addEventListener('gridiot:drag-move', onDragMove);\n\tgridElement.addEventListener('gridiot:drag-end', onDragEnd);\n\tgridElement.addEventListener('gridiot:drag-cancel', onDragCancel);\n\n\treturn () => {\n\t\tgridElement.removeEventListener('gridiot:drag-start', onDragStart);\n\t\tgridElement.removeEventListener('gridiot:drag-move', onDragMove);\n\t\tgridElement.removeEventListener('gridiot:drag-end', onDragEnd);\n\t\tgridElement.removeEventListener('gridiot:drag-cancel', onDragCancel);\n\t};\n}\n"],
  "mappings": "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",
  "names": []
}
